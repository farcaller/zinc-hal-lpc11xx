// Zinc, the bare metal stack for rust.
// Copyright 2015 Vladimir "farcaller" Pouzanov <farcaller@gmail.com>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.





// Registers for I2C





// Register CONSET implementation


/// Register `CONSET`: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_conset {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_conset { }

impl I2C_conset {
    
    // Getters
    /// Fetch the value of the `CONSET` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_conset_Get {
        I2C_conset_Get::new(self)
    }

    
    /// Get value of `AA` field.
    #[inline(always)]
    pub fn aa(&self) -> bool {
        I2C_conset_Get::new(self).aa()
    }
    
    /// Get value of `SI` field.
    #[inline(always)]
    pub fn si(&self) -> bool {
        I2C_conset_Get::new(self).si()
    }
    
    /// Get value of `STO` field.
    #[inline(always)]
    pub fn sto(&self) -> bool {
        I2C_conset_Get::new(self).sto()
    }
    
    /// Get value of `STA` field.
    #[inline(always)]
    pub fn sta(&self) -> bool {
        I2C_conset_Get::new(self).sta()
    }
    
    /// Get value of `I2EN` field.
    #[inline(always)]
    pub fn i2en(&self) -> bool {
        I2C_conset_Get::new(self).i2en()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CONSET` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_conset_Update {
        I2C_conset_Update::new_ignoring_state(self)
    }

    
    /// Set value of `AA` field.
    #[inline(always)]
    pub fn set_aa<'a>(&'a mut self, new_value: bool) -> I2C_conset_Update<'a> {
        let mut setter: I2C_conset_Update = I2C_conset_Update::new(self);
        setter.set_aa(new_value);
        setter
    }
    
    /// Set value of `SI` field.
    #[inline(always)]
    pub fn set_si<'a>(&'a mut self, new_value: bool) -> I2C_conset_Update<'a> {
        let mut setter: I2C_conset_Update = I2C_conset_Update::new(self);
        setter.set_si(new_value);
        setter
    }
    
    /// Set value of `STO` field.
    #[inline(always)]
    pub fn set_sto<'a>(&'a mut self, new_value: bool) -> I2C_conset_Update<'a> {
        let mut setter: I2C_conset_Update = I2C_conset_Update::new(self);
        setter.set_sto(new_value);
        setter
    }
    
    /// Set value of `STA` field.
    #[inline(always)]
    pub fn set_sta<'a>(&'a mut self, new_value: bool) -> I2C_conset_Update<'a> {
        let mut setter: I2C_conset_Update = I2C_conset_Update::new(self);
        setter.set_sta(new_value);
        setter
    }
    
    /// Set value of `I2EN` field.
    #[inline(always)]
    pub fn set_i2en<'a>(&'a mut self, new_value: bool) -> I2C_conset_Update<'a> {
        let mut setter: I2C_conset_Update = I2C_conset_Update::new(self);
        setter.set_i2en(new_value);
        setter
    }
    

    }


// Getter for I2C_conset
/// `CONSET`: I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_conset_Get {
    value: u32,
}

impl I2C_conset_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_conset) -> I2C_conset_Get {
        I2C_conset_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `AA` field: Assert acknowledge flag.
    #[inline(always)]
    pub fn aa(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `SI` field: I2C interrupt flag.
    #[inline(always)]
    pub fn si(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `STO` field: STOP flag.
    #[inline(always)]
    pub fn sto(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `STA` field: START flag.
    #[inline(always)]
    pub fn sta(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `I2EN` field: I2C interface enable.
    #[inline(always)]
    pub fn i2en(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    }

impl ::core::marker::Copy for I2C_conset_Get { }


// Updater for I2C_conset
/// Updater for `CONSET` register.
#[allow(non_camel_case_types)]
pub struct I2C_conset_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_conset,
}

/// This performs the register update.
impl <'a> Drop for I2C_conset_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_conset_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_conset) -> I2C_conset_Update<'a> {
        I2C_conset_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_conset) -> I2C_conset_Update<'a> {
        I2C_conset_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `AA` field.
    #[inline(always)]
    pub fn set_aa<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conset_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `SI` field.
    #[inline(always)]
    pub fn set_si<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conset_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `STO` field.
    #[inline(always)]
    pub fn set_sto<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conset_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `STA` field.
    #[inline(always)]
    pub fn set_sta<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conset_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `I2EN` field.
    #[inline(always)]
    pub fn set_i2en<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conset_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register STAT implementation


/// Register `STAT`: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_stat {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_stat { }

impl I2C_stat {
    
    // Getters
    /// Fetch the value of the `STAT` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_stat_Get {
        I2C_stat_Get::new(self)
    }

    
    /// Get value of `Status` field.
    #[inline(always)]
    pub fn status(&self) -> u32 {
        I2C_stat_Get::new(self).status()
    }
    

    }


// Getter for I2C_stat
/// `STAT`: I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_stat_Get {
    value: u32,
}

impl I2C_stat_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_stat) -> I2C_stat_Get {
        I2C_stat_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `Status` field: These bits give the actual status information about the I 2C interface.
    #[inline(always)]
    pub fn status(&self) -> u32 {
        (self.value >> 3) & 31
        }
    }

impl ::core::marker::Copy for I2C_stat_Get { }







// Register DAT implementation


/// Register `DAT`: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_dat {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_dat { }

impl I2C_dat {
    
    // Getters
    /// Fetch the value of the `DAT` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_dat_Get {
        I2C_dat_Get::new(self)
    }

    
    /// Get value of `Data` field.
    #[inline(always)]
    pub fn data(&self) -> u32 {
        I2C_dat_Get::new(self).data()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DAT` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_dat_Update {
        I2C_dat_Update::new_ignoring_state(self)
    }

    
    /// Set value of `Data` field.
    #[inline(always)]
    pub fn set_data<'a>(&'a mut self, new_value: u32) -> I2C_dat_Update<'a> {
        let mut setter: I2C_dat_Update = I2C_dat_Update::new(self);
        setter.set_data(new_value);
        setter
    }
    

    }


// Getter for I2C_dat
/// `DAT`: I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_dat_Get {
    value: u32,
}

impl I2C_dat_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_dat) -> I2C_dat_Get {
        I2C_dat_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `Data` field: This register holds data values that have been received or are to be transmitted.
    #[inline(always)]
    pub fn data(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for I2C_dat_Get { }


// Updater for I2C_dat
/// Updater for `DAT` register.
#[allow(non_camel_case_types)]
pub struct I2C_dat_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_dat,
}

/// This performs the register update.
impl <'a> Drop for I2C_dat_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_dat_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_dat) -> I2C_dat_Update<'a> {
        I2C_dat_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_dat) -> I2C_dat_Update<'a> {
        I2C_dat_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `Data` field.
    #[inline(always)]
    pub fn set_data<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_dat_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register ADR0 implementation


/// Register `ADR0`: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_adr0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_adr0 { }

impl I2C_adr0 {
    
    // Getters
    /// Fetch the value of the `ADR0` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_adr0_Get {
        I2C_adr0_Get::new(self)
    }

    
    /// Get value of `GC` field.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        I2C_adr0_Get::new(self).gc()
    }
    
    /// Get value of `Address` field.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        I2C_adr0_Get::new(self).address()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `ADR0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_adr0_Update {
        I2C_adr0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'a>(&'a mut self, new_value: bool) -> I2C_adr0_Update<'a> {
        let mut setter: I2C_adr0_Update = I2C_adr0_Update::new(self);
        setter.set_gc(new_value);
        setter
    }
    
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'a>(&'a mut self, new_value: u32) -> I2C_adr0_Update<'a> {
        let mut setter: I2C_adr0_Update = I2C_adr0_Update::new(self);
        setter.set_address(new_value);
        setter
    }
    

    }


// Getter for I2C_adr0
/// `ADR0`: I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_adr0_Get {
    value: u32,
}

impl I2C_adr0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_adr0) -> I2C_adr0_Get {
        I2C_adr0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GC` field: General Call enable bit.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `Address` field: The I2C device address for slave mode.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_adr0_Get { }


// Updater for I2C_adr0
/// Updater for `ADR0` register.
#[allow(non_camel_case_types)]
pub struct I2C_adr0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_adr0,
}

/// This performs the register update.
impl <'a> Drop for I2C_adr0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_adr0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_adr0) -> I2C_adr0_Update<'a> {
        I2C_adr0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_adr0) -> I2C_adr0_Update<'a> {
        I2C_adr0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_adr0_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_adr0_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register SCLH implementation


/// Register `SCLH`: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_sclh {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_sclh { }

impl I2C_sclh {
    
    // Getters
    /// Fetch the value of the `SCLH` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_sclh_Get {
        I2C_sclh_Get::new(self)
    }

    
    /// Get value of `SCLH` field.
    #[inline(always)]
    pub fn sclh(&self) -> u32 {
        I2C_sclh_Get::new(self).sclh()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SCLH` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_sclh_Update {
        I2C_sclh_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SCLH` field.
    #[inline(always)]
    pub fn set_sclh<'a>(&'a mut self, new_value: u32) -> I2C_sclh_Update<'a> {
        let mut setter: I2C_sclh_Update = I2C_sclh_Update::new(self);
        setter.set_sclh(new_value);
        setter
    }
    

    }


// Getter for I2C_sclh
/// `SCLH`: SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_sclh_Get {
    value: u32,
}

impl I2C_sclh_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_sclh) -> I2C_sclh_Get {
        I2C_sclh_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SCLH` field: Count for SCL HIGH time period selection.
    #[inline(always)]
    pub fn sclh(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for I2C_sclh_Get { }


// Updater for I2C_sclh
/// Updater for `SCLH` register.
#[allow(non_camel_case_types)]
pub struct I2C_sclh_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_sclh,
}

/// This performs the register update.
impl <'a> Drop for I2C_sclh_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_sclh_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_sclh) -> I2C_sclh_Update<'a> {
        I2C_sclh_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_sclh) -> I2C_sclh_Update<'a> {
        I2C_sclh_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SCLH` field.
    #[inline(always)]
    pub fn set_sclh<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_sclh_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register SCLL implementation


/// Register `SCLL`: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_scll {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_scll { }

impl I2C_scll {
    
    // Getters
    /// Fetch the value of the `SCLL` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_scll_Get {
        I2C_scll_Get::new(self)
    }

    
    /// Get value of `SCLL` field.
    #[inline(always)]
    pub fn scll(&self) -> u32 {
        I2C_scll_Get::new(self).scll()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SCLL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_scll_Update {
        I2C_scll_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SCLL` field.
    #[inline(always)]
    pub fn set_scll<'a>(&'a mut self, new_value: u32) -> I2C_scll_Update<'a> {
        let mut setter: I2C_scll_Update = I2C_scll_Update::new(self);
        setter.set_scll(new_value);
        setter
    }
    

    }


// Getter for I2C_scll
/// `SCLL`: SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_scll_Get {
    value: u32,
}

impl I2C_scll_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_scll) -> I2C_scll_Get {
        I2C_scll_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SCLL` field: Count for SCL low time period selection.
    #[inline(always)]
    pub fn scll(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for I2C_scll_Get { }


// Updater for I2C_scll
/// Updater for `SCLL` register.
#[allow(non_camel_case_types)]
pub struct I2C_scll_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_scll,
}

/// This performs the register update.
impl <'a> Drop for I2C_scll_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_scll_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_scll) -> I2C_scll_Update<'a> {
        I2C_scll_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_scll) -> I2C_scll_Update<'a> {
        I2C_scll_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SCLL` field.
    #[inline(always)]
    pub fn set_scll<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_scll_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CONCLR implementation


/// Register `CONCLR`: I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_conclr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_conclr { }

impl I2C_conclr {
    
    // Setters
    /// Create new updater that ignores current value of the `CONCLR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_conclr_Update {
        I2C_conclr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `AAC` field.
    #[inline(always)]
    pub fn set_aac<'a>(&'a mut self, new_value: bool) -> I2C_conclr_Update<'a> {
        let mut setter: I2C_conclr_Update = I2C_conclr_Update::new(self);
        setter.set_aac(new_value);
        setter
    }
    
    /// Set value of `SIC` field.
    #[inline(always)]
    pub fn set_sic<'a>(&'a mut self, new_value: bool) -> I2C_conclr_Update<'a> {
        let mut setter: I2C_conclr_Update = I2C_conclr_Update::new(self);
        setter.set_sic(new_value);
        setter
    }
    
    /// Set value of `STAC` field.
    #[inline(always)]
    pub fn set_stac<'a>(&'a mut self, new_value: bool) -> I2C_conclr_Update<'a> {
        let mut setter: I2C_conclr_Update = I2C_conclr_Update::new(self);
        setter.set_stac(new_value);
        setter
    }
    
    /// Set value of `I2ENC` field.
    #[inline(always)]
    pub fn set_i2enc<'a>(&'a mut self, new_value: bool) -> I2C_conclr_Update<'a> {
        let mut setter: I2C_conclr_Update = I2C_conclr_Update::new(self);
        setter.set_i2enc(new_value);
        setter
    }
    

    }


// Updater for I2C_conclr
/// Updater for `CONCLR` register.
#[allow(non_camel_case_types)]
pub struct I2C_conclr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_conclr,
}

/// This performs the register update.
impl <'a> Drop for I2C_conclr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_conclr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_conclr) -> I2C_conclr_Update<'a> {
        I2C_conclr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_conclr) -> I2C_conclr_Update<'a> {
        I2C_conclr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `AAC` field.
    #[inline(always)]
    pub fn set_aac<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conclr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `SIC` field.
    #[inline(always)]
    pub fn set_sic<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conclr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `STAC` field.
    #[inline(always)]
    pub fn set_stac<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conclr_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `I2ENC` field.
    #[inline(always)]
    pub fn set_i2enc<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_conclr_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MMCTRL implementation


/// Register `MMCTRL`: Monitor mode control register.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_mmctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_mmctrl { }

impl I2C_mmctrl {
    
    // Getters
    /// Fetch the value of the `MMCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_mmctrl_Get {
        I2C_mmctrl_Get::new(self)
    }

    
    /// Get value of `MM_ENA` field.
    #[inline(always)]
    pub fn mm_ena(&self) -> I2C_mmctrl_mm_ena {
        I2C_mmctrl_Get::new(self).mm_ena()
    }
    
    /// Get value of `ENA_SCL` field.
    #[inline(always)]
    pub fn ena_scl(&self) -> I2C_mmctrl_ena_scl {
        I2C_mmctrl_Get::new(self).ena_scl()
    }
    
    /// Get value of `MATCH_ALL` field.
    #[inline(always)]
    pub fn match_all(&self) -> I2C_mmctrl_match_all {
        I2C_mmctrl_Get::new(self).match_all()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MMCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_mmctrl_Update {
        I2C_mmctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MM_ENA` field.
    #[inline(always)]
    pub fn set_mm_ena<'a>(&'a mut self, new_value: I2C_mmctrl_mm_ena) -> I2C_mmctrl_Update<'a> {
        let mut setter: I2C_mmctrl_Update = I2C_mmctrl_Update::new(self);
        setter.set_mm_ena(new_value);
        setter
    }
    
    /// Set value of `ENA_SCL` field.
    #[inline(always)]
    pub fn set_ena_scl<'a>(&'a mut self, new_value: I2C_mmctrl_ena_scl) -> I2C_mmctrl_Update<'a> {
        let mut setter: I2C_mmctrl_Update = I2C_mmctrl_Update::new(self);
        setter.set_ena_scl(new_value);
        setter
    }
    
    /// Set value of `MATCH_ALL` field.
    #[inline(always)]
    pub fn set_match_all<'a>(&'a mut self, new_value: I2C_mmctrl_match_all) -> I2C_mmctrl_Update<'a> {
        let mut setter: I2C_mmctrl_Update = I2C_mmctrl_Update::new(self);
        setter.set_match_all(new_value);
        setter
    }
    

    }


// Getter for I2C_mmctrl
/// `MMCTRL`: Monitor mode control register.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_mmctrl_Get {
    value: u32,
}

impl I2C_mmctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_mmctrl) -> I2C_mmctrl_Get {
        I2C_mmctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MM_ENA` field: Monitor mode enable.
    #[inline(always)]
    pub fn mm_ena(&self) -> I2C_mmctrl_mm_ena {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(I2C_mmctrl_mm_ena::Disabled),
            1 => ::core::option::Option::Some(I2C_mmctrl_mm_ena::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ENA_SCL` field: SCL output enable.
    #[inline(always)]
    pub fn ena_scl(&self) -> I2C_mmctrl_ena_scl {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(I2C_mmctrl_ena_scl::High),
            1 => ::core::option::Option::Some(I2C_mmctrl_ena_scl::Normal),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MATCH_ALL` field: Select interrupt register match.
    #[inline(always)]
    pub fn match_all(&self) -> I2C_mmctrl_match_all {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(I2C_mmctrl_match_all::MatchConfigured),
            1 => ::core::option::Option::Some(I2C_mmctrl_match_all::MatchAnyAddress),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for I2C_mmctrl_Get { }


// Updater for I2C_mmctrl
/// Updater for `MMCTRL` register.
#[allow(non_camel_case_types)]
pub struct I2C_mmctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_mmctrl,
}

/// This performs the register update.
impl <'a> Drop for I2C_mmctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_mmctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_mmctrl) -> I2C_mmctrl_Update<'a> {
        I2C_mmctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_mmctrl) -> I2C_mmctrl_Update<'a> {
        I2C_mmctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MM_ENA` field.
    #[inline(always)]
    pub fn set_mm_ena<'b>(&'b mut self, new_value: I2C_mmctrl_mm_ena) -> &'b mut I2C_mmctrl_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `ENA_SCL` field.
    #[inline(always)]
    pub fn set_ena_scl<'b>(&'b mut self, new_value: I2C_mmctrl_ena_scl) -> &'b mut I2C_mmctrl_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `MATCH_ALL` field.
    #[inline(always)]
    pub fn set_match_all<'b>(&'b mut self, new_value: I2C_mmctrl_match_all) -> &'b mut I2C_mmctrl_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum I2C_mmctrl_mm_ena {
    /// Monitor mode disabled.
    Disabled = 0,
    /// The I2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I 2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum I2C_mmctrl_ena_scl {
    /// When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line.
    High = 0,
    /// When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]
    Normal = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum I2C_mmctrl_match_all {
    /// When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned.
    MatchConfigured = 0,
    /// When this bit is set to 1 and the I2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus.
    MatchAnyAddress = 1,
    }







// Register ADR1 implementation


/// Register `ADR1`: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_adr1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_adr1 { }

impl I2C_adr1 {
    
    // Getters
    /// Fetch the value of the `ADR1` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_adr1_Get {
        I2C_adr1_Get::new(self)
    }

    
    /// Get value of `GC` field.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        I2C_adr1_Get::new(self).gc()
    }
    
    /// Get value of `Address` field.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        I2C_adr1_Get::new(self).address()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `ADR1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_adr1_Update {
        I2C_adr1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'a>(&'a mut self, new_value: bool) -> I2C_adr1_Update<'a> {
        let mut setter: I2C_adr1_Update = I2C_adr1_Update::new(self);
        setter.set_gc(new_value);
        setter
    }
    
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'a>(&'a mut self, new_value: u32) -> I2C_adr1_Update<'a> {
        let mut setter: I2C_adr1_Update = I2C_adr1_Update::new(self);
        setter.set_address(new_value);
        setter
    }
    

    }


// Getter for I2C_adr1
/// `ADR1`: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_adr1_Get {
    value: u32,
}

impl I2C_adr1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_adr1) -> I2C_adr1_Get {
        I2C_adr1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GC` field: General Call enable bit.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `Address` field: The I2C device address for slave mode.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_adr1_Get { }


// Updater for I2C_adr1
/// Updater for `ADR1` register.
#[allow(non_camel_case_types)]
pub struct I2C_adr1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_adr1,
}

/// This performs the register update.
impl <'a> Drop for I2C_adr1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_adr1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_adr1) -> I2C_adr1_Update<'a> {
        I2C_adr1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_adr1) -> I2C_adr1_Update<'a> {
        I2C_adr1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_adr1_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_adr1_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register ADR2 implementation


/// Register `ADR2`: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_adr2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_adr2 { }

impl I2C_adr2 {
    
    // Getters
    /// Fetch the value of the `ADR2` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_adr2_Get {
        I2C_adr2_Get::new(self)
    }

    
    /// Get value of `GC` field.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        I2C_adr2_Get::new(self).gc()
    }
    
    /// Get value of `Address` field.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        I2C_adr2_Get::new(self).address()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `ADR2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_adr2_Update {
        I2C_adr2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'a>(&'a mut self, new_value: bool) -> I2C_adr2_Update<'a> {
        let mut setter: I2C_adr2_Update = I2C_adr2_Update::new(self);
        setter.set_gc(new_value);
        setter
    }
    
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'a>(&'a mut self, new_value: u32) -> I2C_adr2_Update<'a> {
        let mut setter: I2C_adr2_Update = I2C_adr2_Update::new(self);
        setter.set_address(new_value);
        setter
    }
    

    }


// Getter for I2C_adr2
/// `ADR2`: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_adr2_Get {
    value: u32,
}

impl I2C_adr2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_adr2) -> I2C_adr2_Get {
        I2C_adr2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GC` field: General Call enable bit.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `Address` field: The I2C device address for slave mode.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_adr2_Get { }


// Updater for I2C_adr2
/// Updater for `ADR2` register.
#[allow(non_camel_case_types)]
pub struct I2C_adr2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_adr2,
}

/// This performs the register update.
impl <'a> Drop for I2C_adr2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_adr2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_adr2) -> I2C_adr2_Update<'a> {
        I2C_adr2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_adr2) -> I2C_adr2_Update<'a> {
        I2C_adr2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_adr2_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_adr2_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register ADR3 implementation


/// Register `ADR3`: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_adr3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_adr3 { }

impl I2C_adr3 {
    
    // Getters
    /// Fetch the value of the `ADR3` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_adr3_Get {
        I2C_adr3_Get::new(self)
    }

    
    /// Get value of `GC` field.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        I2C_adr3_Get::new(self).gc()
    }
    
    /// Get value of `Address` field.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        I2C_adr3_Get::new(self).address()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `ADR3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_adr3_Update {
        I2C_adr3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'a>(&'a mut self, new_value: bool) -> I2C_adr3_Update<'a> {
        let mut setter: I2C_adr3_Update = I2C_adr3_Update::new(self);
        setter.set_gc(new_value);
        setter
    }
    
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'a>(&'a mut self, new_value: u32) -> I2C_adr3_Update<'a> {
        let mut setter: I2C_adr3_Update = I2C_adr3_Update::new(self);
        setter.set_address(new_value);
        setter
    }
    

    }


// Getter for I2C_adr3
/// `ADR3`: I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_adr3_Get {
    value: u32,
}

impl I2C_adr3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_adr3) -> I2C_adr3_Get {
        I2C_adr3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GC` field: General Call enable bit.
    #[inline(always)]
    pub fn gc(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `Address` field: The I2C device address for slave mode.
    #[inline(always)]
    pub fn address(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_adr3_Get { }


// Updater for I2C_adr3
/// Updater for `ADR3` register.
#[allow(non_camel_case_types)]
pub struct I2C_adr3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_adr3,
}

/// This performs the register update.
impl <'a> Drop for I2C_adr3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_adr3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_adr3) -> I2C_adr3_Update<'a> {
        I2C_adr3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_adr3) -> I2C_adr3_Update<'a> {
        I2C_adr3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GC` field.
    #[inline(always)]
    pub fn set_gc<'b>(&'b mut self, new_value: bool) -> &'b mut I2C_adr3_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `Address` field.
    #[inline(always)]
    pub fn set_address<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_adr3_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DATA_BUFFER implementation


/// Register `DATA_BUFFER`: Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_data_buffer {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_data_buffer { }

impl I2C_data_buffer {
    
    // Getters
    /// Fetch the value of the `DATA_BUFFER` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_data_buffer_Get {
        I2C_data_buffer_Get::new(self)
    }

    
    /// Get value of `Data` field.
    #[inline(always)]
    pub fn data(&self) -> u32 {
        I2C_data_buffer_Get::new(self).data()
    }
    

    }


// Getter for I2C_data_buffer
/// `DATA_BUFFER`: Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_data_buffer_Get {
    value: u32,
}

impl I2C_data_buffer_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_data_buffer) -> I2C_data_buffer_Get {
        I2C_data_buffer_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `Data` field: This register holds contents of the 8 MSBs of the DAT shift register.
    #[inline(always)]
    pub fn data(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for I2C_data_buffer_Get { }







// Register MASK0 implementation


/// Register `MASK0`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_mask0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_mask0 { }

impl I2C_mask0 {
    
    // Getters
    /// Fetch the value of the `MASK0` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_mask0_Get {
        I2C_mask0_Get::new(self)
    }

    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        I2C_mask0_Get::new(self).mask()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MASK0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_mask0_Update {
        I2C_mask0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: u32) -> I2C_mask0_Update<'a> {
        let mut setter: I2C_mask0_Update = I2C_mask0_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    

    }


// Getter for I2C_mask0
/// `MASK0`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_mask0_Get {
    value: u32,
}

impl I2C_mask0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_mask0) -> I2C_mask0_Get {
        I2C_mask0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MASK` field: Mask bits.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_mask0_Get { }


// Updater for I2C_mask0
/// Updater for `MASK0` register.
#[allow(non_camel_case_types)]
pub struct I2C_mask0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_mask0,
}

/// This performs the register update.
impl <'a> Drop for I2C_mask0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_mask0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_mask0) -> I2C_mask0_Update<'a> {
        I2C_mask0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_mask0) -> I2C_mask0_Update<'a> {
        I2C_mask0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_mask0_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MASK1 implementation


/// Register `MASK1`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_mask1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_mask1 { }

impl I2C_mask1 {
    
    // Getters
    /// Fetch the value of the `MASK1` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_mask1_Get {
        I2C_mask1_Get::new(self)
    }

    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        I2C_mask1_Get::new(self).mask()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MASK1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_mask1_Update {
        I2C_mask1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: u32) -> I2C_mask1_Update<'a> {
        let mut setter: I2C_mask1_Update = I2C_mask1_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    

    }


// Getter for I2C_mask1
/// `MASK1`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_mask1_Get {
    value: u32,
}

impl I2C_mask1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_mask1) -> I2C_mask1_Get {
        I2C_mask1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MASK` field: Mask bits.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_mask1_Get { }


// Updater for I2C_mask1
/// Updater for `MASK1` register.
#[allow(non_camel_case_types)]
pub struct I2C_mask1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_mask1,
}

/// This performs the register update.
impl <'a> Drop for I2C_mask1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_mask1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_mask1) -> I2C_mask1_Update<'a> {
        I2C_mask1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_mask1) -> I2C_mask1_Update<'a> {
        I2C_mask1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_mask1_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MASK2 implementation


/// Register `MASK2`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_mask2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_mask2 { }

impl I2C_mask2 {
    
    // Getters
    /// Fetch the value of the `MASK2` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_mask2_Get {
        I2C_mask2_Get::new(self)
    }

    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        I2C_mask2_Get::new(self).mask()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MASK2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_mask2_Update {
        I2C_mask2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: u32) -> I2C_mask2_Update<'a> {
        let mut setter: I2C_mask2_Update = I2C_mask2_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    

    }


// Getter for I2C_mask2
/// `MASK2`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_mask2_Get {
    value: u32,
}

impl I2C_mask2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_mask2) -> I2C_mask2_Get {
        I2C_mask2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MASK` field: Mask bits.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_mask2_Get { }


// Updater for I2C_mask2
/// Updater for `MASK2` register.
#[allow(non_camel_case_types)]
pub struct I2C_mask2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_mask2,
}

/// This performs the register update.
impl <'a> Drop for I2C_mask2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_mask2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_mask2) -> I2C_mask2_Update<'a> {
        I2C_mask2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_mask2) -> I2C_mask2_Update<'a> {
        I2C_mask2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_mask2_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MASK3 implementation


/// Register `MASK3`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct I2C_mask3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for I2C_mask3 { }

impl I2C_mask3 {
    
    // Getters
    /// Fetch the value of the `MASK3` register.
    #[inline(always)]
    pub fn get(&self) -> I2C_mask3_Get {
        I2C_mask3_Get::new(self)
    }

    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        I2C_mask3_Get::new(self).mask()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MASK3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> I2C_mask3_Update {
        I2C_mask3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: u32) -> I2C_mask3_Update<'a> {
        let mut setter: I2C_mask3_Update = I2C_mask3_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    

    }


// Getter for I2C_mask3
/// `MASK3`: I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct I2C_mask3_Get {
    value: u32,
}

impl I2C_mask3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &I2C_mask3) -> I2C_mask3_Get {
        I2C_mask3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MASK` field: Mask bits.
    #[inline(always)]
    pub fn mask(&self) -> u32 {
        (self.value >> 1) & 127
        }
    }

impl ::core::marker::Copy for I2C_mask3_Get { }


// Updater for I2C_mask3
/// Updater for `MASK3` register.
#[allow(non_camel_case_types)]
pub struct I2C_mask3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a I2C_mask3,
}

/// This performs the register update.
impl <'a> Drop for I2C_mask3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> I2C_mask3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a I2C_mask3) -> I2C_mask3_Update<'a> {
        I2C_mask3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a I2C_mask3) -> I2C_mask3_Update<'a> {
        I2C_mask3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: u32) -> &'b mut I2C_mask3_Update<'a> {
        self.value = (self.value & !(127 << 1))
                   | ((new_value as u32) & 127) << 1;
        self.mask |= 127 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral I2C implementation

/// I2C
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct I2C;

impl I2C {
    /// I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register.
    #[inline(always)]
    pub fn conset() -> &'static mut I2C_conset {
        unsafe { ::core::intrinsics::transmute(0x40000000 as usize) }
    }
    /// I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed.
    #[inline(always)]
    pub fn stat() -> &'static mut I2C_stat {
        unsafe { ::core::intrinsics::transmute(0x40000004 as usize) }
    }
    /// I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register.
    #[inline(always)]
    pub fn dat() -> &'static mut I2C_dat {
        unsafe { ::core::intrinsics::transmute(0x40000008 as usize) }
    }
    /// I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    #[inline(always)]
    pub fn adr0() -> &'static mut I2C_adr0 {
        unsafe { ::core::intrinsics::transmute(0x4000000c as usize) }
    }
    /// SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock.
    #[inline(always)]
    pub fn sclh() -> &'static mut I2C_sclh {
        unsafe { ::core::intrinsics::transmute(0x40000010 as usize) }
    }
    /// SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode.
    #[inline(always)]
    pub fn scll() -> &'static mut I2C_scll {
        unsafe { ::core::intrinsics::transmute(0x40000014 as usize) }
    }
    /// I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register.
    #[inline(always)]
    pub fn conclr() -> &'static mut I2C_conclr {
        unsafe { ::core::intrinsics::transmute(0x40000018 as usize) }
    }
    /// Monitor mode control register.
    #[inline(always)]
    pub fn mmctrl() -> &'static mut I2C_mmctrl {
        unsafe { ::core::intrinsics::transmute(0x4000001c as usize) }
    }
    /// I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    #[inline(always)]
    pub fn adr1() -> &'static mut I2C_adr1 {
        unsafe { ::core::intrinsics::transmute(0x40000020 as usize) }
    }
    /// I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    #[inline(always)]
    pub fn adr2() -> &'static mut I2C_adr2 {
        unsafe { ::core::intrinsics::transmute(0x40000024 as usize) }
    }
    /// I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address.
    #[inline(always)]
    pub fn adr3() -> &'static mut I2C_adr3 {
        unsafe { ::core::intrinsics::transmute(0x40000028 as usize) }
    }
    /// Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus.
    #[inline(always)]
    pub fn data_buffer() -> &'static mut I2C_data_buffer {
        unsafe { ::core::intrinsics::transmute(0x4000002c as usize) }
    }
    /// I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
    #[inline(always)]
    pub fn mask0() -> &'static mut I2C_mask0 {
        unsafe { ::core::intrinsics::transmute(0x40000030 as usize) }
    }
    /// I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
    #[inline(always)]
    pub fn mask1() -> &'static mut I2C_mask1 {
        unsafe { ::core::intrinsics::transmute(0x40000034 as usize) }
    }
    /// I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
    #[inline(always)]
    pub fn mask2() -> &'static mut I2C_mask2 {
        unsafe { ::core::intrinsics::transmute(0x40000038 as usize) }
    }
    /// I2C Slave address mask register 0. This mask register is associated with I2ADR0 to determine an address match. The mask register has no effect when comparing to the General Call address (0000000).
    #[inline(always)]
    pub fn mask3() -> &'static mut I2C_mask3 {
        unsafe { ::core::intrinsics::transmute(0x4000003c as usize) }
    }
    }



// Registers for WWDT





// Register WDMOD implementation


/// Register `WDMOD`: Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct WWDT_wdmod {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for WWDT_wdmod { }

impl WWDT_wdmod {
    
    // Getters
    /// Fetch the value of the `WDMOD` register.
    #[inline(always)]
    pub fn get(&self) -> WWDT_wdmod_Get {
        WWDT_wdmod_Get::new(self)
    }

    
    /// Get value of `WDEN` field.
    #[inline(always)]
    pub fn wden(&self) -> WWDT_wdmod_wden {
        WWDT_wdmod_Get::new(self).wden()
    }
    
    /// Get value of `WDRESET` field.
    #[inline(always)]
    pub fn wdreset(&self) -> WWDT_wdmod_wdreset {
        WWDT_wdmod_Get::new(self).wdreset()
    }
    
    /// Get value of `WDTOF` field.
    #[inline(always)]
    pub fn wdtof(&self) -> bool {
        WWDT_wdmod_Get::new(self).wdtof()
    }
    
    /// Get value of `WDINT` field.
    #[inline(always)]
    pub fn wdint(&self) -> bool {
        WWDT_wdmod_Get::new(self).wdint()
    }
    
    /// Get value of `WDPROTECT` field.
    #[inline(always)]
    pub fn wdprotect(&self) -> WWDT_wdmod_wdprotect {
        WWDT_wdmod_Get::new(self).wdprotect()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDMOD` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> WWDT_wdmod_Update {
        WWDT_wdmod_Update::new_ignoring_state(self)
    }

    
    /// Set value of `WDEN` field.
    #[inline(always)]
    pub fn set_wden<'a>(&'a mut self, new_value: WWDT_wdmod_wden) -> WWDT_wdmod_Update<'a> {
        let mut setter: WWDT_wdmod_Update = WWDT_wdmod_Update::new(self);
        setter.set_wden(new_value);
        setter
    }
    
    /// Set value of `WDRESET` field.
    #[inline(always)]
    pub fn set_wdreset<'a>(&'a mut self, new_value: WWDT_wdmod_wdreset) -> WWDT_wdmod_Update<'a> {
        let mut setter: WWDT_wdmod_Update = WWDT_wdmod_Update::new(self);
        setter.set_wdreset(new_value);
        setter
    }
    
    /// Set value of `WDTOF` field.
    #[inline(always)]
    pub fn set_wdtof<'a>(&'a mut self, new_value: bool) -> WWDT_wdmod_Update<'a> {
        let mut setter: WWDT_wdmod_Update = WWDT_wdmod_Update::new(self);
        setter.set_wdtof(new_value);
        setter
    }
    
    /// Set value of `WDINT` field.
    #[inline(always)]
    pub fn set_wdint<'a>(&'a mut self, new_value: bool) -> WWDT_wdmod_Update<'a> {
        let mut setter: WWDT_wdmod_Update = WWDT_wdmod_Update::new(self);
        setter.set_wdint(new_value);
        setter
    }
    
    /// Set value of `WDPROTECT` field.
    #[inline(always)]
    pub fn set_wdprotect<'a>(&'a mut self, new_value: WWDT_wdmod_wdprotect) -> WWDT_wdmod_Update<'a> {
        let mut setter: WWDT_wdmod_Update = WWDT_wdmod_Update::new(self);
        setter.set_wdprotect(new_value);
        setter
    }
    

    }


// Getter for WWDT_wdmod
/// `WDMOD`: Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct WWDT_wdmod_Get {
    value: u32,
}

impl WWDT_wdmod_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &WWDT_wdmod) -> WWDT_wdmod_Get {
        WWDT_wdmod_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `WDEN` field: Watchdog enable bit. This bit is Set Only. Setting this bit to one also locks the watchdog clock source. Once the watchdog timer is enabled, the watchdog timer clock source cannot be changed. If the watchdog timer is needed in Deep-sleep mode, the watchdog clock source must be changed to the watchdog oscillator before setting this bit to one.
    #[inline(always)]
    pub fn wden(&self) -> WWDT_wdmod_wden {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(WWDT_wdmod_wden::Stopped),
            1 => ::core::option::Option::Some(WWDT_wdmod_wden::Running),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WDRESET` field: Watchdog reset enable bit. This bit is Set Only.
    #[inline(always)]
    pub fn wdreset(&self) -> WWDT_wdmod_wdreset {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(WWDT_wdmod_wdreset::NoReset),
            1 => ::core::option::Option::Some(WWDT_wdmod_wdreset::Reset),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WDTOF` field: Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT, cleared by software. Causes a chip reset if WDRESET = 1.
    #[inline(always)]
    pub fn wdtof(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `WDINT` field: Watchdog interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software.
    #[inline(always)]
    pub fn wdint(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `WDPROTECT` field: Watchdog update mode. This bit is Set Only.
    #[inline(always)]
    pub fn wdprotect(&self) -> WWDT_wdmod_wdprotect {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(WWDT_wdmod_wdprotect::Anytime),
            1 => ::core::option::Option::Some(WWDT_wdmod_wdprotect::LowCounter),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for WWDT_wdmod_Get { }


// Updater for WWDT_wdmod
/// Updater for `WDMOD` register.
#[allow(non_camel_case_types)]
pub struct WWDT_wdmod_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a WWDT_wdmod,
}

/// This performs the register update.
impl <'a> Drop for WWDT_wdmod_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> WWDT_wdmod_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a WWDT_wdmod) -> WWDT_wdmod_Update<'a> {
        WWDT_wdmod_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a WWDT_wdmod) -> WWDT_wdmod_Update<'a> {
        WWDT_wdmod_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `WDEN` field.
    #[inline(always)]
    pub fn set_wden<'b>(&'b mut self, new_value: WWDT_wdmod_wden) -> &'b mut WWDT_wdmod_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `WDRESET` field.
    #[inline(always)]
    pub fn set_wdreset<'b>(&'b mut self, new_value: WWDT_wdmod_wdreset) -> &'b mut WWDT_wdmod_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `WDTOF` field.
    #[inline(always)]
    pub fn set_wdtof<'b>(&'b mut self, new_value: bool) -> &'b mut WWDT_wdmod_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `WDINT` field.
    #[inline(always)]
    pub fn set_wdint<'b>(&'b mut self, new_value: bool) -> &'b mut WWDT_wdmod_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `WDPROTECT` field.
    #[inline(always)]
    pub fn set_wdprotect<'b>(&'b mut self, new_value: WWDT_wdmod_wdprotect) -> &'b mut WWDT_wdmod_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum WWDT_wdmod_wden {
    /// The watchdog timer is stopped.
    Stopped = 0,
    /// The watchdog timer is running.
    Running = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum WWDT_wdmod_wdreset {
    /// A watchdog timeout will not cause a chip reset.
    NoReset = 0,
    /// A watchdog timeout will cause a chip reset.
    Reset = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum WWDT_wdmod_wdprotect {
    /// The watchdog reload value (WDTC) can be changed at any time.
    Anytime = 0,
    /// The watchdog reload value (WDTC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW. Note: this mode is intended for use only when WDRESET =1.
    LowCounter = 1,
    }







// Register WDTC implementation


/// Register `WDTC`: Watchdog timer constant register. This register determines the time-out value.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct WWDT_wdtc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for WWDT_wdtc { }

impl WWDT_wdtc {
    
    // Getters
    /// Fetch the value of the `WDTC` register.
    #[inline(always)]
    pub fn get(&self) -> WWDT_wdtc_Get {
        WWDT_wdtc_Get::new(self)
    }

    
    /// Get value of `Count` field.
    #[inline(always)]
    pub fn count(&self) -> u32 {
        WWDT_wdtc_Get::new(self).count()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDTC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> WWDT_wdtc_Update {
        WWDT_wdtc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `Count` field.
    #[inline(always)]
    pub fn set_count<'a>(&'a mut self, new_value: u32) -> WWDT_wdtc_Update<'a> {
        let mut setter: WWDT_wdtc_Update = WWDT_wdtc_Update::new(self);
        setter.set_count(new_value);
        setter
    }
    

    }


// Getter for WWDT_wdtc
/// `WDTC`: Watchdog timer constant register. This register determines the time-out value.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct WWDT_wdtc_Get {
    value: u32,
}

impl WWDT_wdtc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &WWDT_wdtc) -> WWDT_wdtc_Get {
        WWDT_wdtc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `Count` field: Watchdog time-out interval.
    #[inline(always)]
    pub fn count(&self) -> u32 {
        (self.value >> 0) & 16777215
        }
    }

impl ::core::marker::Copy for WWDT_wdtc_Get { }


// Updater for WWDT_wdtc
/// Updater for `WDTC` register.
#[allow(non_camel_case_types)]
pub struct WWDT_wdtc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a WWDT_wdtc,
}

/// This performs the register update.
impl <'a> Drop for WWDT_wdtc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> WWDT_wdtc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a WWDT_wdtc) -> WWDT_wdtc_Update<'a> {
        WWDT_wdtc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a WWDT_wdtc) -> WWDT_wdtc_Update<'a> {
        WWDT_wdtc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `Count` field.
    #[inline(always)]
    pub fn set_count<'b>(&'b mut self, new_value: u32) -> &'b mut WWDT_wdtc_Update<'a> {
        self.value = (self.value & !(16777215 << 0))
                   | ((new_value as u32) & 16777215) << 0;
        self.mask |= 16777215 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register WDFEED implementation


/// Register `WDFEED`: Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct WWDT_wdfeed {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for WWDT_wdfeed { }

impl WWDT_wdfeed {
    
    // Setters
    /// Create new updater that ignores current value of the `WDFEED` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> WWDT_wdfeed_Update {
        WWDT_wdfeed_Update::new_ignoring_state(self)
    }

    
    /// Set value of `Feed` field.
    #[inline(always)]
    pub fn set_feed<'a>(&'a mut self, new_value: u32) -> WWDT_wdfeed_Update<'a> {
        let mut setter: WWDT_wdfeed_Update = WWDT_wdfeed_Update::new(self);
        setter.set_feed(new_value);
        setter
    }
    

    }


// Updater for WWDT_wdfeed
/// Updater for `WDFEED` register.
#[allow(non_camel_case_types)]
pub struct WWDT_wdfeed_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a WWDT_wdfeed,
}

/// This performs the register update.
impl <'a> Drop for WWDT_wdfeed_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> WWDT_wdfeed_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a WWDT_wdfeed) -> WWDT_wdfeed_Update<'a> {
        WWDT_wdfeed_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a WWDT_wdfeed) -> WWDT_wdfeed_Update<'a> {
        WWDT_wdfeed_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `Feed` field.
    #[inline(always)]
    pub fn set_feed<'b>(&'b mut self, new_value: u32) -> &'b mut WWDT_wdfeed_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register WDTV implementation


/// Register `WDTV`: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct WWDT_wdtv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for WWDT_wdtv { }

impl WWDT_wdtv {
    
    // Getters
    /// Fetch the value of the `WDTV` register.
    #[inline(always)]
    pub fn get(&self) -> WWDT_wdtv_Get {
        WWDT_wdtv_Get::new(self)
    }

    
    /// Get value of `Count` field.
    #[inline(always)]
    pub fn count(&self) -> u32 {
        WWDT_wdtv_Get::new(self).count()
    }
    

    }


// Getter for WWDT_wdtv
/// `WDTV`: Watchdog timer value register. This register reads out the current value of the Watchdog timer.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct WWDT_wdtv_Get {
    value: u32,
}

impl WWDT_wdtv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &WWDT_wdtv) -> WWDT_wdtv_Get {
        WWDT_wdtv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `Count` field: Counter timer value.
    #[inline(always)]
    pub fn count(&self) -> u32 {
        (self.value >> 0) & 16777215
        }
    }

impl ::core::marker::Copy for WWDT_wdtv_Get { }







// Register WDWARNINT implementation


/// Register `WDWARNINT`: Watchdog Warning Interrupt compare value.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct WWDT_wdwarnint {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for WWDT_wdwarnint { }

impl WWDT_wdwarnint {
    
    // Getters
    /// Fetch the value of the `WDWARNINT` register.
    #[inline(always)]
    pub fn get(&self) -> WWDT_wdwarnint_Get {
        WWDT_wdwarnint_Get::new(self)
    }

    
    /// Get value of `WARNINT` field.
    #[inline(always)]
    pub fn warnint(&self) -> u32 {
        WWDT_wdwarnint_Get::new(self).warnint()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDWARNINT` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> WWDT_wdwarnint_Update {
        WWDT_wdwarnint_Update::new_ignoring_state(self)
    }

    
    /// Set value of `WARNINT` field.
    #[inline(always)]
    pub fn set_warnint<'a>(&'a mut self, new_value: u32) -> WWDT_wdwarnint_Update<'a> {
        let mut setter: WWDT_wdwarnint_Update = WWDT_wdwarnint_Update::new(self);
        setter.set_warnint(new_value);
        setter
    }
    

    }


// Getter for WWDT_wdwarnint
/// `WDWARNINT`: Watchdog Warning Interrupt compare value.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct WWDT_wdwarnint_Get {
    value: u32,
}

impl WWDT_wdwarnint_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &WWDT_wdwarnint) -> WWDT_wdwarnint_Get {
        WWDT_wdwarnint_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `WARNINT` field: Watchdog warning interrupt compare value.
    #[inline(always)]
    pub fn warnint(&self) -> u32 {
        (self.value >> 0) & 1023
        }
    }

impl ::core::marker::Copy for WWDT_wdwarnint_Get { }


// Updater for WWDT_wdwarnint
/// Updater for `WDWARNINT` register.
#[allow(non_camel_case_types)]
pub struct WWDT_wdwarnint_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a WWDT_wdwarnint,
}

/// This performs the register update.
impl <'a> Drop for WWDT_wdwarnint_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> WWDT_wdwarnint_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a WWDT_wdwarnint) -> WWDT_wdwarnint_Update<'a> {
        WWDT_wdwarnint_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a WWDT_wdwarnint) -> WWDT_wdwarnint_Update<'a> {
        WWDT_wdwarnint_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `WARNINT` field.
    #[inline(always)]
    pub fn set_warnint<'b>(&'b mut self, new_value: u32) -> &'b mut WWDT_wdwarnint_Update<'a> {
        self.value = (self.value & !(1023 << 0))
                   | ((new_value as u32) & 1023) << 0;
        self.mask |= 1023 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register WDWINDOW implementation


/// Register `WDWINDOW`: Watchdog Window compare value.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct WWDT_wdwindow {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for WWDT_wdwindow { }

impl WWDT_wdwindow {
    
    // Getters
    /// Fetch the value of the `WDWINDOW` register.
    #[inline(always)]
    pub fn get(&self) -> WWDT_wdwindow_Get {
        WWDT_wdwindow_Get::new(self)
    }

    
    /// Get value of `WINDOW` field.
    #[inline(always)]
    pub fn window(&self) -> u32 {
        WWDT_wdwindow_Get::new(self).window()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDWINDOW` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> WWDT_wdwindow_Update {
        WWDT_wdwindow_Update::new_ignoring_state(self)
    }

    
    /// Set value of `WINDOW` field.
    #[inline(always)]
    pub fn set_window<'a>(&'a mut self, new_value: u32) -> WWDT_wdwindow_Update<'a> {
        let mut setter: WWDT_wdwindow_Update = WWDT_wdwindow_Update::new(self);
        setter.set_window(new_value);
        setter
    }
    

    }


// Getter for WWDT_wdwindow
/// `WDWINDOW`: Watchdog Window compare value.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct WWDT_wdwindow_Get {
    value: u32,
}

impl WWDT_wdwindow_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &WWDT_wdwindow) -> WWDT_wdwindow_Get {
        WWDT_wdwindow_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `WINDOW` field: Watchdog window value.
    #[inline(always)]
    pub fn window(&self) -> u32 {
        (self.value >> 0) & 16777215
        }
    }

impl ::core::marker::Copy for WWDT_wdwindow_Get { }


// Updater for WWDT_wdwindow
/// Updater for `WDWINDOW` register.
#[allow(non_camel_case_types)]
pub struct WWDT_wdwindow_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a WWDT_wdwindow,
}

/// This performs the register update.
impl <'a> Drop for WWDT_wdwindow_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> WWDT_wdwindow_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a WWDT_wdwindow) -> WWDT_wdwindow_Update<'a> {
        WWDT_wdwindow_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a WWDT_wdwindow) -> WWDT_wdwindow_Update<'a> {
        WWDT_wdwindow_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `WINDOW` field.
    #[inline(always)]
    pub fn set_window<'b>(&'b mut self, new_value: u32) -> &'b mut WWDT_wdwindow_Update<'a> {
        self.value = (self.value & !(16777215 << 0))
                   | ((new_value as u32) & 16777215) << 0;
        self.mask |= 16777215 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral WWDT implementation

/// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx Windowed WatchDog Timer (WDT) Modification date=9/19/2011 Major revision=6 Minor revision=not available 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct WWDT;

impl WWDT {
    /// Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer.
    #[inline(always)]
    pub fn wdmod() -> &'static mut WWDT_wdmod {
        unsafe { ::core::intrinsics::transmute(0x40004000 as usize) }
    }
    /// Watchdog timer constant register. This register determines the time-out value.
    #[inline(always)]
    pub fn wdtc() -> &'static mut WWDT_wdtc {
        unsafe { ::core::intrinsics::transmute(0x40004004 as usize) }
    }
    /// Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC.
    #[inline(always)]
    pub fn wdfeed() -> &'static mut WWDT_wdfeed {
        unsafe { ::core::intrinsics::transmute(0x40004008 as usize) }
    }
    /// Watchdog timer value register. This register reads out the current value of the Watchdog timer.
    #[inline(always)]
    pub fn wdtv() -> &'static mut WWDT_wdtv {
        unsafe { ::core::intrinsics::transmute(0x4000400c as usize) }
    }
    /// Watchdog Warning Interrupt compare value.
    #[inline(always)]
    pub fn wdwarnint() -> &'static mut WWDT_wdwarnint {
        unsafe { ::core::intrinsics::transmute(0x40004014 as usize) }
    }
    /// Watchdog Window compare value.
    #[inline(always)]
    pub fn wdwindow() -> &'static mut WWDT_wdwindow {
        unsafe { ::core::intrinsics::transmute(0x40004018 as usize) }
    }
    }



// Registers for UART





// Register RBR implementation


/// Register `RBR`: Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_rbr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_rbr { }

impl UART_rbr {
    
    // Getters
    /// Fetch the value of the `RBR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_rbr_Get {
        UART_rbr_Get::new(self)
    }

    
    /// Get value of `RBR` field.
    #[inline(always)]
    pub fn rbr(&self) -> u32 {
        UART_rbr_Get::new(self).rbr()
    }
    

    }


// Getter for UART_rbr
/// `RBR`: Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_rbr_Get {
    value: u32,
}

impl UART_rbr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_rbr) -> UART_rbr_Get {
        UART_rbr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RBR` field: The UART Receiver Buffer Register contains the oldest received byte in the UART RX FIFO.
    #[inline(always)]
    pub fn rbr(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for UART_rbr_Get { }







// Register THR implementation


/// Register `THR`: Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_thr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_thr { }

impl UART_thr {
    
    // Setters
    /// Create new updater that ignores current value of the `THR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_thr_Update {
        UART_thr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `THR` field.
    #[inline(always)]
    pub fn set_thr<'a>(&'a mut self, new_value: u32) -> UART_thr_Update<'a> {
        let mut setter: UART_thr_Update = UART_thr_Update::new(self);
        setter.set_thr(new_value);
        setter
    }
    

    }


// Updater for UART_thr
/// Updater for `THR` register.
#[allow(non_camel_case_types)]
pub struct UART_thr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_thr,
}

/// This performs the register update.
impl <'a> Drop for UART_thr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_thr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_thr) -> UART_thr_Update<'a> {
        UART_thr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_thr) -> UART_thr_Update<'a> {
        UART_thr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `THR` field.
    #[inline(always)]
    pub fn set_thr<'b>(&'b mut self, new_value: u32) -> &'b mut UART_thr_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DLL implementation


/// Register `DLL`: Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_dll {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_dll { }

impl UART_dll {
    
    // Getters
    /// Fetch the value of the `DLL` register.
    #[inline(always)]
    pub fn get(&self) -> UART_dll_Get {
        UART_dll_Get::new(self)
    }

    
    /// Get value of `DLLSB` field.
    #[inline(always)]
    pub fn dllsb(&self) -> u32 {
        UART_dll_Get::new(self).dllsb()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DLL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_dll_Update {
        UART_dll_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DLLSB` field.
    #[inline(always)]
    pub fn set_dllsb<'a>(&'a mut self, new_value: u32) -> UART_dll_Update<'a> {
        let mut setter: UART_dll_Update = UART_dll_Update::new(self);
        setter.set_dllsb(new_value);
        setter
    }
    

    }


// Getter for UART_dll
/// `DLL`: Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_dll_Get {
    value: u32,
}

impl UART_dll_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_dll) -> UART_dll_Get {
        UART_dll_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DLLSB` field: The UART Divisor Latch LSB Register, along with the DLM register, determines the baud rate of the UART.
    #[inline(always)]
    pub fn dllsb(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for UART_dll_Get { }


// Updater for UART_dll
/// Updater for `DLL` register.
#[allow(non_camel_case_types)]
pub struct UART_dll_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_dll,
}

/// This performs the register update.
impl <'a> Drop for UART_dll_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_dll_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_dll) -> UART_dll_Update<'a> {
        UART_dll_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_dll) -> UART_dll_Update<'a> {
        UART_dll_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DLLSB` field.
    #[inline(always)]
    pub fn set_dllsb<'b>(&'b mut self, new_value: u32) -> &'b mut UART_dll_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DLM implementation


/// Register `DLM`: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_dlm {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_dlm { }

impl UART_dlm {
    
    // Getters
    /// Fetch the value of the `DLM` register.
    #[inline(always)]
    pub fn get(&self) -> UART_dlm_Get {
        UART_dlm_Get::new(self)
    }

    
    /// Get value of `DLMSB` field.
    #[inline(always)]
    pub fn dlmsb(&self) -> u32 {
        UART_dlm_Get::new(self).dlmsb()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DLM` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_dlm_Update {
        UART_dlm_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DLMSB` field.
    #[inline(always)]
    pub fn set_dlmsb<'a>(&'a mut self, new_value: u32) -> UART_dlm_Update<'a> {
        let mut setter: UART_dlm_Update = UART_dlm_Update::new(self);
        setter.set_dlmsb(new_value);
        setter
    }
    

    }


// Getter for UART_dlm
/// `DLM`: Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_dlm_Get {
    value: u32,
}

impl UART_dlm_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_dlm) -> UART_dlm_Get {
        UART_dlm_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DLMSB` field: The UART Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the UART.
    #[inline(always)]
    pub fn dlmsb(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for UART_dlm_Get { }


// Updater for UART_dlm
/// Updater for `DLM` register.
#[allow(non_camel_case_types)]
pub struct UART_dlm_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_dlm,
}

/// This performs the register update.
impl <'a> Drop for UART_dlm_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_dlm_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_dlm) -> UART_dlm_Update<'a> {
        UART_dlm_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_dlm) -> UART_dlm_Update<'a> {
        UART_dlm_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DLMSB` field.
    #[inline(always)]
    pub fn set_dlmsb<'b>(&'b mut self, new_value: u32) -> &'b mut UART_dlm_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register IER implementation


/// Register `IER`: Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts. (DLAB=0)
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_ier {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_ier { }

impl UART_ier {
    
    // Getters
    /// Fetch the value of the `IER` register.
    #[inline(always)]
    pub fn get(&self) -> UART_ier_Get {
        UART_ier_Get::new(self)
    }

    
    /// Get value of `RBRIE` field.
    #[inline(always)]
    pub fn rbrie(&self) -> UART_ier_rbrie {
        UART_ier_Get::new(self).rbrie()
    }
    
    /// Get value of `THREIE` field.
    #[inline(always)]
    pub fn threie(&self) -> UART_ier_threie {
        UART_ier_Get::new(self).threie()
    }
    
    /// Get value of `RXLIE` field.
    #[inline(always)]
    pub fn rxlie(&self) -> UART_ier_rxlie {
        UART_ier_Get::new(self).rxlie()
    }
    
    /// Get value of `ABEOINTEN` field.
    #[inline(always)]
    pub fn abeointen(&self) -> UART_ier_abeointen {
        UART_ier_Get::new(self).abeointen()
    }
    
    /// Get value of `ABTOINTEN` field.
    #[inline(always)]
    pub fn abtointen(&self) -> UART_ier_abtointen {
        UART_ier_Get::new(self).abtointen()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IER` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_ier_Update {
        UART_ier_Update::new_ignoring_state(self)
    }

    
    /// Set value of `RBRIE` field.
    #[inline(always)]
    pub fn set_rbrie<'a>(&'a mut self, new_value: UART_ier_rbrie) -> UART_ier_Update<'a> {
        let mut setter: UART_ier_Update = UART_ier_Update::new(self);
        setter.set_rbrie(new_value);
        setter
    }
    
    /// Set value of `THREIE` field.
    #[inline(always)]
    pub fn set_threie<'a>(&'a mut self, new_value: UART_ier_threie) -> UART_ier_Update<'a> {
        let mut setter: UART_ier_Update = UART_ier_Update::new(self);
        setter.set_threie(new_value);
        setter
    }
    
    /// Set value of `RXLIE` field.
    #[inline(always)]
    pub fn set_rxlie<'a>(&'a mut self, new_value: UART_ier_rxlie) -> UART_ier_Update<'a> {
        let mut setter: UART_ier_Update = UART_ier_Update::new(self);
        setter.set_rxlie(new_value);
        setter
    }
    
    /// Set value of `ABEOINTEN` field.
    #[inline(always)]
    pub fn set_abeointen<'a>(&'a mut self, new_value: UART_ier_abeointen) -> UART_ier_Update<'a> {
        let mut setter: UART_ier_Update = UART_ier_Update::new(self);
        setter.set_abeointen(new_value);
        setter
    }
    
    /// Set value of `ABTOINTEN` field.
    #[inline(always)]
    pub fn set_abtointen<'a>(&'a mut self, new_value: UART_ier_abtointen) -> UART_ier_Update<'a> {
        let mut setter: UART_ier_Update = UART_ier_Update::new(self);
        setter.set_abtointen(new_value);
        setter
    }
    

    }


// Getter for UART_ier
/// `IER`: Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts. (DLAB=0)
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_ier_Get {
    value: u32,
}

impl UART_ier_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_ier) -> UART_ier_Get {
        UART_ier_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RBRIE` field: RBR Interrupt Enable. Enables the Receive Data Available interrupt for UART. It also controls the Character Receive Time-out interrupt.
    #[inline(always)]
    pub fn rbrie(&self) -> UART_ier_rbrie {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(UART_ier_rbrie::Disabled),
            1 => ::core::option::Option::Some(UART_ier_rbrie::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `THREIE` field: THRE Interrupt Enable. Enables the THRE interrupt for UART. The status of this interrupt can be read from LSR[5].
    #[inline(always)]
    pub fn threie(&self) -> UART_ier_threie {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(UART_ier_threie::Disabled),
            1 => ::core::option::Option::Some(UART_ier_threie::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RXLIE` field: RX Line Interrupt Enable. Enables the UART RX line status interrupts. The status of this interrupt can be read from LSR[4:1].
    #[inline(always)]
    pub fn rxlie(&self) -> UART_ier_rxlie {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(UART_ier_rxlie::Disabled),
            1 => ::core::option::Option::Some(UART_ier_rxlie::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ABEOINTEN` field: Enables the end of auto-baud interrupt.
    #[inline(always)]
    pub fn abeointen(&self) -> UART_ier_abeointen {
        match (self.value >> 8) & 1 {
            0 => ::core::option::Option::Some(UART_ier_abeointen::Disabled),
            1 => ::core::option::Option::Some(UART_ier_abeointen::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ABTOINTEN` field: Enables the auto-baud time-out interrupt.
    #[inline(always)]
    pub fn abtointen(&self) -> UART_ier_abtointen {
        match (self.value >> 9) & 1 {
            0 => ::core::option::Option::Some(UART_ier_abtointen::Disabled),
            1 => ::core::option::Option::Some(UART_ier_abtointen::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for UART_ier_Get { }


// Updater for UART_ier
/// Updater for `IER` register.
#[allow(non_camel_case_types)]
pub struct UART_ier_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_ier,
}

/// This performs the register update.
impl <'a> Drop for UART_ier_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_ier_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_ier) -> UART_ier_Update<'a> {
        UART_ier_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_ier) -> UART_ier_Update<'a> {
        UART_ier_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `RBRIE` field.
    #[inline(always)]
    pub fn set_rbrie<'b>(&'b mut self, new_value: UART_ier_rbrie) -> &'b mut UART_ier_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `THREIE` field.
    #[inline(always)]
    pub fn set_threie<'b>(&'b mut self, new_value: UART_ier_threie) -> &'b mut UART_ier_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `RXLIE` field.
    #[inline(always)]
    pub fn set_rxlie<'b>(&'b mut self, new_value: UART_ier_rxlie) -> &'b mut UART_ier_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `ABEOINTEN` field.
    #[inline(always)]
    pub fn set_abeointen<'b>(&'b mut self, new_value: UART_ier_abeointen) -> &'b mut UART_ier_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `ABTOINTEN` field.
    #[inline(always)]
    pub fn set_abtointen<'b>(&'b mut self, new_value: UART_ier_abtointen) -> &'b mut UART_ier_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_ier_rbrie {
    /// Disable the RDA interrupt.
    Disabled = 0,
    /// Enable the RDA interrupt.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_ier_threie {
    /// Disable the THRE interrupt.
    Disabled = 0,
    /// Enable the THRE interrupt.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_ier_rxlie {
    /// Disable the RX line status interrupts.
    Disabled = 0,
    /// Enable the RX line status interrupts.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_ier_abeointen {
    /// Disable end of auto-baud Interrupt.
    Disabled = 0,
    /// Enable end of auto-baud Interrupt.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_ier_abtointen {
    /// Disable auto-baud time-out Interrupt.
    Disabled = 0,
    /// Enable auto-baud time-out Interrupt.
    Enabled = 1,
    }







// Register IIR implementation


/// Register `IIR`: Interrupt ID Register. Identifies which interrupt(s) are pending.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_iir {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_iir { }

impl UART_iir {
    
    // Getters
    /// Fetch the value of the `IIR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_iir_Get {
        UART_iir_Get::new(self)
    }

    
    /// Get value of `INTSTATUS` field.
    #[inline(always)]
    pub fn intstatus(&self) -> UART_iir_intstatus {
        UART_iir_Get::new(self).intstatus()
    }
    
    /// Get value of `INTID` field.
    #[inline(always)]
    pub fn intid(&self) -> UART_iir_intid {
        UART_iir_Get::new(self).intid()
    }
    
    /// Get value of `FIFOENABLE` field.
    #[inline(always)]
    pub fn fifoenable(&self) -> u32 {
        UART_iir_Get::new(self).fifoenable()
    }
    
    /// Get value of `ABEOINT` field.
    #[inline(always)]
    pub fn abeoint(&self) -> bool {
        UART_iir_Get::new(self).abeoint()
    }
    
    /// Get value of `ABTOINT` field.
    #[inline(always)]
    pub fn abtoint(&self) -> bool {
        UART_iir_Get::new(self).abtoint()
    }
    

    }


// Getter for UART_iir
/// `IIR`: Interrupt ID Register. Identifies which interrupt(s) are pending.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_iir_Get {
    value: u32,
}

impl UART_iir_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_iir) -> UART_iir_Get {
        UART_iir_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `INTSTATUS` field: Interrupt status. Note that IIR[0] is active low. The pending interrupt can be determined by evaluating IIR[3:1].
    #[inline(always)]
    pub fn intstatus(&self) -> UART_iir_intstatus {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(UART_iir_intstatus::InterruptPending),
            1 => ::core::option::Option::Some(UART_iir_intstatus::NoInterruptPending),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `INTID` field: Interrupt identification. IER[3:1] identifies an interrupt corresponding to the UART Rx FIFO. All other combinations of IER[3:1] not listed below are reserved (100,101,111).
    #[inline(always)]
    pub fn intid(&self) -> UART_iir_intid {
        match (self.value >> 1) & 7 {
            3 => ::core::option::Option::Some(UART_iir_intid::RLS),
            2 => ::core::option::Option::Some(UART_iir_intid::RDA),
            6 => ::core::option::Option::Some(UART_iir_intid::CTI),
            1 => ::core::option::Option::Some(UART_iir_intid::THRE),
            0 => ::core::option::Option::Some(UART_iir_intid::Modem),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FIFOENABLE` field: These bits are equivalent to FCR[0].
    #[inline(always)]
    pub fn fifoenable(&self) -> u32 {
        (self.value >> 6) & 3
        }
    /// Get value of `ABEOINT` field: End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled.
    #[inline(always)]
    pub fn abeoint(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `ABTOINT` field: Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled.
    #[inline(always)]
    pub fn abtoint(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    }

impl ::core::marker::Copy for UART_iir_Get { }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_iir_intstatus {
    /// At least one interrupt is pending.
    InterruptPending = 0,
    /// No interrupt is pending.
    NoInterruptPending = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_iir_intid {
    /// 1   - Receive Line Status (RLS).
    RLS = 3,
    /// 2a - Receive Data Available (RDA).
    RDA = 2,
    /// 2b - Character Time-out Indicator (CTI).
    CTI = 6,
    /// 3   - THRE Interrupt.
    THRE = 1,
    /// 4   - Modem interrupt.
    Modem = 0,
    }







// Register FCR implementation


/// Register `FCR`: FIFO Control Register. Controls UART FIFO usage and modes.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_fcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_fcr { }

impl UART_fcr {
    
    // Setters
    /// Create new updater that ignores current value of the `FCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_fcr_Update {
        UART_fcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FIFOEN` field.
    #[inline(always)]
    pub fn set_fifoen<'a>(&'a mut self, new_value: UART_fcr_fifoen) -> UART_fcr_Update<'a> {
        let mut setter: UART_fcr_Update = UART_fcr_Update::new(self);
        setter.set_fifoen(new_value);
        setter
    }
    
    /// Set value of `RXFIFORES` field.
    #[inline(always)]
    pub fn set_rxfifores<'a>(&'a mut self, new_value: UART_fcr_rxfifores) -> UART_fcr_Update<'a> {
        let mut setter: UART_fcr_Update = UART_fcr_Update::new(self);
        setter.set_rxfifores(new_value);
        setter
    }
    
    /// Set value of `TXFIFORES` field.
    #[inline(always)]
    pub fn set_txfifores<'a>(&'a mut self, new_value: UART_fcr_txfifores) -> UART_fcr_Update<'a> {
        let mut setter: UART_fcr_Update = UART_fcr_Update::new(self);
        setter.set_txfifores(new_value);
        setter
    }
    
    /// Set value of `RXTL` field.
    #[inline(always)]
    pub fn set_rxtl<'a>(&'a mut self, new_value: UART_fcr_rxtl) -> UART_fcr_Update<'a> {
        let mut setter: UART_fcr_Update = UART_fcr_Update::new(self);
        setter.set_rxtl(new_value);
        setter
    }
    

    }


// Updater for UART_fcr
/// Updater for `FCR` register.
#[allow(non_camel_case_types)]
pub struct UART_fcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_fcr,
}

/// This performs the register update.
impl <'a> Drop for UART_fcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_fcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_fcr) -> UART_fcr_Update<'a> {
        UART_fcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_fcr) -> UART_fcr_Update<'a> {
        UART_fcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FIFOEN` field.
    #[inline(always)]
    pub fn set_fifoen<'b>(&'b mut self, new_value: UART_fcr_fifoen) -> &'b mut UART_fcr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `RXFIFORES` field.
    #[inline(always)]
    pub fn set_rxfifores<'b>(&'b mut self, new_value: UART_fcr_rxfifores) -> &'b mut UART_fcr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `TXFIFORES` field.
    #[inline(always)]
    pub fn set_txfifores<'b>(&'b mut self, new_value: UART_fcr_txfifores) -> &'b mut UART_fcr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `RXTL` field.
    #[inline(always)]
    pub fn set_rxtl<'b>(&'b mut self, new_value: UART_fcr_rxtl) -> &'b mut UART_fcr_Update<'a> {
        self.value = (self.value & !(3 << 6))
                   | ((new_value as u32) & 3) << 6;
        self.mask |= 3 << 6;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_fcr_fifoen {
    /// UART FIFOs are disabled. Must not be used in the application.
    Disabled = 0,
    /// Active high enable for both UART Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper UART operation. Any transition on this bit will automatically clear the UART FIFOs.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_fcr_rxfifores {
    /// No impact on either of UART FIFOs.
    NoImpact = 0,
    /// Writing a logic 1 to FCR[1] will clear all bytes in UART Rx FIFO, reset the pointer logic. This bit is self-clearing.
    ClearInterrupt = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_fcr_txfifores {
    /// No impact on either of UART FIFOs.
    NoImpact = 0,
    /// Writing a logic 1 to FCR[2] will clear all bytes in UART TX FIFO, reset the pointer logic. This bit is self-clearing.
    ClearInterrupt = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_fcr_rxtl {
    /// Trigger level 0 (1 character or 0x01).
    TriggerOn1Char = 0,
    /// Trigger level 1 (4 characters or 0x04).
    TriggerOn4Chars = 1,
    /// Trigger level 2 (8 characters or 0x08).
    TriggerOn8Chars = 2,
    /// Trigger level 3 (14 characters or 0x0E).
    TriggerOn14Chars = 3,
    }







// Register LCR implementation


/// Register `LCR`: Line Control Register. Contains controls for frame formatting and break generation.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_lcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_lcr { }

impl UART_lcr {
    
    // Getters
    /// Fetch the value of the `LCR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_lcr_Get {
        UART_lcr_Get::new(self)
    }

    
    /// Get value of `WLS` field.
    #[inline(always)]
    pub fn wls(&self) -> UART_lcr_wls {
        UART_lcr_Get::new(self).wls()
    }
    
    /// Get value of `SBS` field.
    #[inline(always)]
    pub fn sbs(&self) -> UART_lcr_sbs {
        UART_lcr_Get::new(self).sbs()
    }
    
    /// Get value of `PE` field.
    #[inline(always)]
    pub fn pe(&self) -> UART_lcr_pe {
        UART_lcr_Get::new(self).pe()
    }
    
    /// Get value of `PS` field.
    #[inline(always)]
    pub fn ps(&self) -> UART_lcr_ps {
        UART_lcr_Get::new(self).ps()
    }
    
    /// Get value of `BC` field.
    #[inline(always)]
    pub fn bc(&self) -> UART_lcr_bc {
        UART_lcr_Get::new(self).bc()
    }
    
    /// Get value of `DLAB` field.
    #[inline(always)]
    pub fn dlab(&self) -> UART_lcr_dlab {
        UART_lcr_Get::new(self).dlab()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `LCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_lcr_Update {
        UART_lcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `WLS` field.
    #[inline(always)]
    pub fn set_wls<'a>(&'a mut self, new_value: UART_lcr_wls) -> UART_lcr_Update<'a> {
        let mut setter: UART_lcr_Update = UART_lcr_Update::new(self);
        setter.set_wls(new_value);
        setter
    }
    
    /// Set value of `SBS` field.
    #[inline(always)]
    pub fn set_sbs<'a>(&'a mut self, new_value: UART_lcr_sbs) -> UART_lcr_Update<'a> {
        let mut setter: UART_lcr_Update = UART_lcr_Update::new(self);
        setter.set_sbs(new_value);
        setter
    }
    
    /// Set value of `PE` field.
    #[inline(always)]
    pub fn set_pe<'a>(&'a mut self, new_value: UART_lcr_pe) -> UART_lcr_Update<'a> {
        let mut setter: UART_lcr_Update = UART_lcr_Update::new(self);
        setter.set_pe(new_value);
        setter
    }
    
    /// Set value of `PS` field.
    #[inline(always)]
    pub fn set_ps<'a>(&'a mut self, new_value: UART_lcr_ps) -> UART_lcr_Update<'a> {
        let mut setter: UART_lcr_Update = UART_lcr_Update::new(self);
        setter.set_ps(new_value);
        setter
    }
    
    /// Set value of `BC` field.
    #[inline(always)]
    pub fn set_bc<'a>(&'a mut self, new_value: UART_lcr_bc) -> UART_lcr_Update<'a> {
        let mut setter: UART_lcr_Update = UART_lcr_Update::new(self);
        setter.set_bc(new_value);
        setter
    }
    
    /// Set value of `DLAB` field.
    #[inline(always)]
    pub fn set_dlab<'a>(&'a mut self, new_value: UART_lcr_dlab) -> UART_lcr_Update<'a> {
        let mut setter: UART_lcr_Update = UART_lcr_Update::new(self);
        setter.set_dlab(new_value);
        setter
    }
    

    }


// Getter for UART_lcr
/// `LCR`: Line Control Register. Contains controls for frame formatting and break generation.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_lcr_Get {
    value: u32,
}

impl UART_lcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_lcr) -> UART_lcr_Get {
        UART_lcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `WLS` field: Word Length Select
    #[inline(always)]
    pub fn wls(&self) -> UART_lcr_wls {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(UART_lcr_wls::WordIs5Bits),
            1 => ::core::option::Option::Some(UART_lcr_wls::WordIs6Bits),
            2 => ::core::option::Option::Some(UART_lcr_wls::WordIs7Bits),
            3 => ::core::option::Option::Some(UART_lcr_wls::WordIs8Bits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SBS` field: Stop Bit Select
    #[inline(always)]
    pub fn sbs(&self) -> UART_lcr_sbs {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(UART_lcr_sbs::StopBitIs1),
            1 => ::core::option::Option::Some(UART_lcr_sbs::StopBitIs2),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PE` field: Parity Enable
    #[inline(always)]
    pub fn pe(&self) -> UART_lcr_pe {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(UART_lcr_pe::Disabled),
            1 => ::core::option::Option::Some(UART_lcr_pe::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PS` field: Parity Select
    #[inline(always)]
    pub fn ps(&self) -> UART_lcr_ps {
        match (self.value >> 4) & 3 {
            0 => ::core::option::Option::Some(UART_lcr_ps::Odd),
            1 => ::core::option::Option::Some(UART_lcr_ps::Even),
            2 => ::core::option::Option::Some(UART_lcr_ps::Forced1),
            3 => ::core::option::Option::Some(UART_lcr_ps::Forced0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BC` field: Break Control
    #[inline(always)]
    pub fn bc(&self) -> UART_lcr_bc {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(UART_lcr_bc::Disabled),
            1 => ::core::option::Option::Some(UART_lcr_bc::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DLAB` field: Divisor Latch Access Bit
    #[inline(always)]
    pub fn dlab(&self) -> UART_lcr_dlab {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(UART_lcr_dlab::Disabled),
            1 => ::core::option::Option::Some(UART_lcr_dlab::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for UART_lcr_Get { }


// Updater for UART_lcr
/// Updater for `LCR` register.
#[allow(non_camel_case_types)]
pub struct UART_lcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_lcr,
}

/// This performs the register update.
impl <'a> Drop for UART_lcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_lcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_lcr) -> UART_lcr_Update<'a> {
        UART_lcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_lcr) -> UART_lcr_Update<'a> {
        UART_lcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `WLS` field.
    #[inline(always)]
    pub fn set_wls<'b>(&'b mut self, new_value: UART_lcr_wls) -> &'b mut UART_lcr_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Set value of `SBS` field.
    #[inline(always)]
    pub fn set_sbs<'b>(&'b mut self, new_value: UART_lcr_sbs) -> &'b mut UART_lcr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `PE` field.
    #[inline(always)]
    pub fn set_pe<'b>(&'b mut self, new_value: UART_lcr_pe) -> &'b mut UART_lcr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `PS` field.
    #[inline(always)]
    pub fn set_ps<'b>(&'b mut self, new_value: UART_lcr_ps) -> &'b mut UART_lcr_Update<'a> {
        self.value = (self.value & !(3 << 4))
                   | ((new_value as u32) & 3) << 4;
        self.mask |= 3 << 4;
        self
    }
    /// Set value of `BC` field.
    #[inline(always)]
    pub fn set_bc<'b>(&'b mut self, new_value: UART_lcr_bc) -> &'b mut UART_lcr_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `DLAB` field.
    #[inline(always)]
    pub fn set_dlab<'b>(&'b mut self, new_value: UART_lcr_dlab) -> &'b mut UART_lcr_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lcr_wls {
    /// 5-bit character length.
    WordIs5Bits = 0,
    /// 6-bit character length.
    WordIs6Bits = 1,
    /// 7-bit character length.
    WordIs7Bits = 2,
    /// 8-bit character length.
    WordIs8Bits = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lcr_sbs {
    /// 1 stop bit.
    StopBitIs1 = 0,
    /// 2 stop bits (1.5 if LCR[1:0]=00).
    StopBitIs2 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lcr_pe {
    /// Disable parity generation and checking.
    Disabled = 0,
    /// Enable parity generation and checking.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lcr_ps {
    /// Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd.
    Odd = 0,
    /// Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even.
    Even = 1,
    /// Forced 1 stick parity.
    Forced1 = 2,
    /// Forced 0 stick parity.
    Forced0 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lcr_bc {
    /// Disable break transmission.
    Disabled = 0,
    /// Enable break transmission. Output pin UART TXD is forced to logic 0 when LCR[6] is active high.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lcr_dlab {
    /// Disable access to Divisor Latches.
    Disabled = 0,
    /// Enable access to Divisor Latches.
    Enabled = 1,
    }







// Register MCR implementation


/// Register `MCR`: Modem control register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_mcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_mcr { }

impl UART_mcr {
    
    // Getters
    /// Fetch the value of the `MCR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_mcr_Get {
        UART_mcr_Get::new(self)
    }

    
    /// Get value of `DTRC` field.
    #[inline(always)]
    pub fn dtrc(&self) -> bool {
        UART_mcr_Get::new(self).dtrc()
    }
    
    /// Get value of `RTSC` field.
    #[inline(always)]
    pub fn rtsc(&self) -> bool {
        UART_mcr_Get::new(self).rtsc()
    }
    
    /// Get value of `LMS` field.
    #[inline(always)]
    pub fn lms(&self) -> bool {
        UART_mcr_Get::new(self).lms()
    }
    
    /// Get value of `RTSEN` field.
    #[inline(always)]
    pub fn rtsen(&self) -> UART_mcr_rtsen {
        UART_mcr_Get::new(self).rtsen()
    }
    
    /// Get value of `CTSEN` field.
    #[inline(always)]
    pub fn ctsen(&self) -> UART_mcr_ctsen {
        UART_mcr_Get::new(self).ctsen()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_mcr_Update {
        UART_mcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DTRC` field.
    #[inline(always)]
    pub fn set_dtrc<'a>(&'a mut self, new_value: bool) -> UART_mcr_Update<'a> {
        let mut setter: UART_mcr_Update = UART_mcr_Update::new(self);
        setter.set_dtrc(new_value);
        setter
    }
    
    /// Set value of `RTSC` field.
    #[inline(always)]
    pub fn set_rtsc<'a>(&'a mut self, new_value: bool) -> UART_mcr_Update<'a> {
        let mut setter: UART_mcr_Update = UART_mcr_Update::new(self);
        setter.set_rtsc(new_value);
        setter
    }
    
    /// Set value of `LMS` field.
    #[inline(always)]
    pub fn set_lms<'a>(&'a mut self, new_value: bool) -> UART_mcr_Update<'a> {
        let mut setter: UART_mcr_Update = UART_mcr_Update::new(self);
        setter.set_lms(new_value);
        setter
    }
    
    /// Set value of `RTSEN` field.
    #[inline(always)]
    pub fn set_rtsen<'a>(&'a mut self, new_value: UART_mcr_rtsen) -> UART_mcr_Update<'a> {
        let mut setter: UART_mcr_Update = UART_mcr_Update::new(self);
        setter.set_rtsen(new_value);
        setter
    }
    
    /// Set value of `CTSEN` field.
    #[inline(always)]
    pub fn set_ctsen<'a>(&'a mut self, new_value: UART_mcr_ctsen) -> UART_mcr_Update<'a> {
        let mut setter: UART_mcr_Update = UART_mcr_Update::new(self);
        setter.set_ctsen(new_value);
        setter
    }
    

    }


// Getter for UART_mcr
/// `MCR`: Modem control register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_mcr_Get {
    value: u32,
}

impl UART_mcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_mcr) -> UART_mcr_Get {
        UART_mcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DTRC` field: DTR Control. Source for modem output pin, DTR. This bit reads as 0 when modem loopback mode is active.
    #[inline(always)]
    pub fn dtrc(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `RTSC` field: RTS Control. Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active.
    #[inline(always)]
    pub fn rtsc(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `LMS` field: Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD, has no effect on loopback and output pin, TXD is held in marking state. The four modem inputs (CTS, DSR, RI and  DCD) are disconnected externally. Externally, the modem outputs (RTS, DTR) are set inactive. Internally, the four modem outputs are connected to the four modem inputs. As a result of these connections, the upper four bits of the MSR will be driven by the lower four bits of the MCR rather than the four modem inputs in normal mode. This permits modem status interrupts to be generated in loopback mode by writing the lower four bits of MCR.
    #[inline(always)]
    pub fn lms(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `RTSEN` field: RTS flow control
    #[inline(always)]
    pub fn rtsen(&self) -> UART_mcr_rtsen {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(UART_mcr_rtsen::Disabled),
            1 => ::core::option::Option::Some(UART_mcr_rtsen::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CTSEN` field: CTS flow control
    #[inline(always)]
    pub fn ctsen(&self) -> UART_mcr_ctsen {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(UART_mcr_ctsen::Disabled),
            1 => ::core::option::Option::Some(UART_mcr_ctsen::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for UART_mcr_Get { }


// Updater for UART_mcr
/// Updater for `MCR` register.
#[allow(non_camel_case_types)]
pub struct UART_mcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_mcr,
}

/// This performs the register update.
impl <'a> Drop for UART_mcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_mcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_mcr) -> UART_mcr_Update<'a> {
        UART_mcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_mcr) -> UART_mcr_Update<'a> {
        UART_mcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DTRC` field.
    #[inline(always)]
    pub fn set_dtrc<'b>(&'b mut self, new_value: bool) -> &'b mut UART_mcr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `RTSC` field.
    #[inline(always)]
    pub fn set_rtsc<'b>(&'b mut self, new_value: bool) -> &'b mut UART_mcr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `LMS` field.
    #[inline(always)]
    pub fn set_lms<'b>(&'b mut self, new_value: bool) -> &'b mut UART_mcr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `RTSEN` field.
    #[inline(always)]
    pub fn set_rtsen<'b>(&'b mut self, new_value: UART_mcr_rtsen) -> &'b mut UART_mcr_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `CTSEN` field.
    #[inline(always)]
    pub fn set_ctsen<'b>(&'b mut self, new_value: UART_mcr_ctsen) -> &'b mut UART_mcr_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_mcr_rtsen {
    /// Disable auto-rts flow control.
    Disabled = 0,
    /// Enable auto-rts flow control.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_mcr_ctsen {
    /// Disable auto-cts flow control.
    Disabled = 0,
    /// Enable auto-cts flow control.
    Enabled = 1,
    }







// Register LSR implementation


/// Register `LSR`: Line Status Register. Contains flags for transmit and receive status, including line errors.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_lsr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_lsr { }

impl UART_lsr {
    
    // Getters
    /// Fetch the value of the `LSR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_lsr_Get {
        UART_lsr_Get::new(self)
    }

    
    /// Get value of `RDR` field.
    #[inline(always)]
    pub fn rdr(&self) -> UART_lsr_rdr {
        UART_lsr_Get::new(self).rdr()
    }
    
    /// Get value of `OE` field.
    #[inline(always)]
    pub fn oe(&self) -> UART_lsr_oe {
        UART_lsr_Get::new(self).oe()
    }
    
    /// Get value of `PE` field.
    #[inline(always)]
    pub fn pe(&self) -> UART_lsr_pe {
        UART_lsr_Get::new(self).pe()
    }
    
    /// Get value of `FE` field.
    #[inline(always)]
    pub fn fe(&self) -> UART_lsr_fe {
        UART_lsr_Get::new(self).fe()
    }
    
    /// Get value of `BI` field.
    #[inline(always)]
    pub fn bi(&self) -> UART_lsr_bi {
        UART_lsr_Get::new(self).bi()
    }
    
    /// Get value of `THRE` field.
    #[inline(always)]
    pub fn thre(&self) -> UART_lsr_thre {
        UART_lsr_Get::new(self).thre()
    }
    
    /// Get value of `TEMT` field.
    #[inline(always)]
    pub fn temt(&self) -> UART_lsr_temt {
        UART_lsr_Get::new(self).temt()
    }
    
    /// Get value of `RXFE` field.
    #[inline(always)]
    pub fn rxfe(&self) -> UART_lsr_rxfe {
        UART_lsr_Get::new(self).rxfe()
    }
    

    }


// Getter for UART_lsr
/// `LSR`: Line Status Register. Contains flags for transmit and receive status, including line errors.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_lsr_Get {
    value: u32,
}

impl UART_lsr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_lsr) -> UART_lsr_Get {
        UART_lsr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RDR` field: Receiver Data Ready. LSR[0] is set when the RBR holds an unread character and is cleared when the UART RBR FIFO is empty.
    #[inline(always)]
    pub fn rdr(&self) -> UART_lsr_rdr {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_rdr::Empty),
            1 => ::core::option::Option::Some(UART_lsr_rdr::Valid),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OE` field: Overrun Error. The overrun error condition is set as soon as it occurs. A LSR read clears LSR[1]. LSR[1] is set when UART RSR has a new character assembled and the UART RBR FIFO is full. In this case, the UART RBR FIFO will not be overwritten and the character in the UART RSR will be lost.
    #[inline(always)]
    pub fn oe(&self) -> UART_lsr_oe {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_oe::Inactive),
            1 => ::core::option::Option::Some(UART_lsr_oe::Active),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PE` field: Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. A LSR read clears LSR[2]. Time of parity error detection is dependent on FCR[0]. Note: A parity error is associated with the character at the top of the UART RBR FIFO.
    #[inline(always)]
    pub fn pe(&self) -> UART_lsr_pe {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_pe::Inactive),
            1 => ::core::option::Option::Some(UART_lsr_pe::Active),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FE` field: Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. A LSR read clears LSR[3]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to re-synchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UART RBR FIFO.
    #[inline(always)]
    pub fn fe(&self) -> UART_lsr_fe {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_fe::Inactive),
            1 => ::core::option::Option::Some(UART_lsr_fe::Active),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BI` field: Break Interrupt. When RXD1 is held in the spacing state (all zeros) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). A LSR read clears this status bit. The time of break detection is dependent on FCR[0]. Note: The break interrupt is associated with the character at the top of the UART RBR FIFO.
    #[inline(always)]
    pub fn bi(&self) -> UART_lsr_bi {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_bi::Inactive),
            1 => ::core::option::Option::Some(UART_lsr_bi::Active),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `THRE` field: Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UART THR and is cleared on a THR write.
    #[inline(always)]
    pub fn thre(&self) -> UART_lsr_thre {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_thre::Valid),
            1 => ::core::option::Option::Some(UART_lsr_thre::Empty),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TEMT` field: Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data.
    #[inline(always)]
    pub fn temt(&self) -> UART_lsr_temt {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_temt::Valid),
            1 => ::core::option::Option::Some(UART_lsr_temt::Empty),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RXFE` field: Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the UART FIFO.
    #[inline(always)]
    pub fn rxfe(&self) -> UART_lsr_rxfe {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(UART_lsr_rxfe::NoError),
            1 => ::core::option::Option::Some(UART_lsr_rxfe::Error),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for UART_lsr_Get { }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_rdr {
    /// RBR is empty.
    Empty = 0,
    /// RBR contains valid data.
    Valid = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_oe {
    /// Overrun error status is inactive.
    Inactive = 0,
    /// Overrun error status is active.
    Active = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_pe {
    /// Parity error status is inactive.
    Inactive = 0,
    /// Parity error status is active.
    Active = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_fe {
    /// Framing error status is inactive.
    Inactive = 0,
    /// Framing error status is active.
    Active = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_bi {
    /// Break interrupt status is inactive.
    Inactive = 0,
    /// Break interrupt status is active.
    Active = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_thre {
    /// THR contains valid data.
    Valid = 0,
    /// THR is empty.
    Empty = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_temt {
    /// THR and/or the TSR contains valid data.
    Valid = 0,
    /// THR and the TSR are empty.
    Empty = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_lsr_rxfe {
    /// RBR contains no UART RX errors or FCR[0]=0.
    NoError = 0,
    /// UART RBR contains at least one UART RX error.
    Error = 1,
    }







// Register MSR implementation


/// Register `MSR`: Modem status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_msr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_msr { }

impl UART_msr {
    
    // Getters
    /// Fetch the value of the `MSR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_msr_Get {
        UART_msr_Get::new(self)
    }

    
    /// Get value of `DCTS` field.
    #[inline(always)]
    pub fn dcts(&self) -> UART_msr_dcts {
        UART_msr_Get::new(self).dcts()
    }
    
    /// Get value of `DDSR` field.
    #[inline(always)]
    pub fn ddsr(&self) -> UART_msr_ddsr {
        UART_msr_Get::new(self).ddsr()
    }
    
    /// Get value of `TERI` field.
    #[inline(always)]
    pub fn teri(&self) -> UART_msr_teri {
        UART_msr_Get::new(self).teri()
    }
    
    /// Get value of `DDCD` field.
    #[inline(always)]
    pub fn ddcd(&self) -> UART_msr_ddcd {
        UART_msr_Get::new(self).ddcd()
    }
    
    /// Get value of `CTS` field.
    #[inline(always)]
    pub fn cts(&self) -> bool {
        UART_msr_Get::new(self).cts()
    }
    
    /// Get value of `DSR` field.
    #[inline(always)]
    pub fn dsr(&self) -> bool {
        UART_msr_Get::new(self).dsr()
    }
    
    /// Get value of `RI` field.
    #[inline(always)]
    pub fn ri(&self) -> bool {
        UART_msr_Get::new(self).ri()
    }
    
    /// Get value of `DCD` field.
    #[inline(always)]
    pub fn dcd(&self) -> bool {
        UART_msr_Get::new(self).dcd()
    }
    

    }


// Getter for UART_msr
/// `MSR`: Modem status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_msr_Get {
    value: u32,
}

impl UART_msr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_msr) -> UART_msr_Get {
        UART_msr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DCTS` field: Delta CTS. Set upon state change of input CTS. Cleared on a MSR read.
    #[inline(always)]
    pub fn dcts(&self) -> UART_msr_dcts {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(UART_msr_dcts::NoChangeDetected),
            1 => ::core::option::Option::Some(UART_msr_dcts::ChangeDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DDSR` field: Delta DSR. Set upon state change of input DSR. Cleared on a MSR read.
    #[inline(always)]
    pub fn ddsr(&self) -> UART_msr_ddsr {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(UART_msr_ddsr::NoChangeDetected),
            1 => ::core::option::Option::Some(UART_msr_ddsr::ChangeDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TERI` field: Trailing Edge RI. Set upon low to high transition of input RI. Cleared on a MSR read.
    #[inline(always)]
    pub fn teri(&self) -> UART_msr_teri {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(UART_msr_teri::NoChangeDetected),
            1 => ::core::option::Option::Some(UART_msr_teri::LowToHightTransitionDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DDCD` field: Delta DCD. Set upon state change of input DCD. Cleared on a MSR read.
    #[inline(always)]
    pub fn ddcd(&self) -> UART_msr_ddcd {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(UART_msr_ddcd::NoChangeDetected),
            1 => ::core::option::Option::Some(UART_msr_ddcd::ChangeDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CTS` field: Clear To Send State. Complement of input signal CTS. This bit is connected to MCR[1] in modem loopback mode.
    #[inline(always)]
    pub fn cts(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `DSR` field: Data Set Ready State. Complement of input signal DSR. This bit is connected to MCR[0] in modem loopback mode.
    #[inline(always)]
    pub fn dsr(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `RI` field: Ring Indicator State. Complement of input RI. This bit is connected to MCR[2] in modem loopback mode.
    #[inline(always)]
    pub fn ri(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `DCD` field: Data Carrier Detect State. Complement of input DCD. This bit is connected to MCR[3] in modem loopback mode.
    #[inline(always)]
    pub fn dcd(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    }

impl ::core::marker::Copy for UART_msr_Get { }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_msr_dcts {
    /// No change detected on modem input CTS.
    NoChangeDetected = 0,
    /// State change detected on modem input CTS.
    ChangeDetected = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_msr_ddsr {
    /// No change detected on modem input DSR.
    NoChangeDetected = 0,
    /// State change detected on modem input DSR.
    ChangeDetected = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_msr_teri {
    /// No change detected on modem input, RI.
    NoChangeDetected = 0,
    /// Low-to-high transition detected on RI.
    LowToHightTransitionDetected = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_msr_ddcd {
    /// No change detected on modem input DCD.
    NoChangeDetected = 0,
    /// State change detected on modem input DCD.
    ChangeDetected = 1,
    }







// Register SCR implementation


/// Register `SCR`: Scratch Pad Register. Eight-bit temporary storage for software.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_scr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_scr { }

impl UART_scr {
    
    // Getters
    /// Fetch the value of the `SCR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_scr_Get {
        UART_scr_Get::new(self)
    }

    
    /// Get value of `pad` field.
    #[inline(always)]
    pub fn pad(&self) -> u32 {
        UART_scr_Get::new(self).pad()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_scr_Update {
        UART_scr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `pad` field.
    #[inline(always)]
    pub fn set_pad<'a>(&'a mut self, new_value: u32) -> UART_scr_Update<'a> {
        let mut setter: UART_scr_Update = UART_scr_Update::new(self);
        setter.set_pad(new_value);
        setter
    }
    

    }


// Getter for UART_scr
/// `SCR`: Scratch Pad Register. Eight-bit temporary storage for software.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_scr_Get {
    value: u32,
}

impl UART_scr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_scr) -> UART_scr_Get {
        UART_scr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `pad` field: A readable, writable byte.
    #[inline(always)]
    pub fn pad(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for UART_scr_Get { }


// Updater for UART_scr
/// Updater for `SCR` register.
#[allow(non_camel_case_types)]
pub struct UART_scr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_scr,
}

/// This performs the register update.
impl <'a> Drop for UART_scr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_scr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_scr) -> UART_scr_Update<'a> {
        UART_scr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_scr) -> UART_scr_Update<'a> {
        UART_scr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `pad` field.
    #[inline(always)]
    pub fn set_pad<'b>(&'b mut self, new_value: u32) -> &'b mut UART_scr_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register ACR implementation


/// Register `ACR`: Auto-baud Control Register. Contains controls for the auto-baud feature.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_acr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_acr { }

impl UART_acr {
    
    // Getters
    /// Fetch the value of the `ACR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_acr_Get {
        UART_acr_Get::new(self)
    }

    
    /// Get value of `START` field.
    #[inline(always)]
    pub fn start(&self) -> UART_acr_start {
        UART_acr_Get::new(self).start()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> UART_acr_mode {
        UART_acr_Get::new(self).mode()
    }
    
    /// Get value of `AUTORESTART` field.
    #[inline(always)]
    pub fn autorestart(&self) -> UART_acr_autorestart {
        UART_acr_Get::new(self).autorestart()
    }
    
    /// Get value of `ABEOINTCLR` field.
    #[inline(always)]
    pub fn abeointclr(&self) -> UART_acr_abeointclr {
        UART_acr_Get::new(self).abeointclr()
    }
    
    /// Get value of `ABTOINTCLR` field.
    #[inline(always)]
    pub fn abtointclr(&self) -> UART_acr_abtointclr {
        UART_acr_Get::new(self).abtointclr()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `ACR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_acr_Update {
        UART_acr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `START` field.
    #[inline(always)]
    pub fn set_start<'a>(&'a mut self, new_value: UART_acr_start) -> UART_acr_Update<'a> {
        let mut setter: UART_acr_Update = UART_acr_Update::new(self);
        setter.set_start(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: UART_acr_mode) -> UART_acr_Update<'a> {
        let mut setter: UART_acr_Update = UART_acr_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `AUTORESTART` field.
    #[inline(always)]
    pub fn set_autorestart<'a>(&'a mut self, new_value: UART_acr_autorestart) -> UART_acr_Update<'a> {
        let mut setter: UART_acr_Update = UART_acr_Update::new(self);
        setter.set_autorestart(new_value);
        setter
    }
    
    /// Set value of `ABEOINTCLR` field.
    #[inline(always)]
    pub fn set_abeointclr<'a>(&'a mut self, new_value: UART_acr_abeointclr) -> UART_acr_Update<'a> {
        let mut setter: UART_acr_Update = UART_acr_Update::new(self);
        setter.set_abeointclr(new_value);
        setter
    }
    
    /// Set value of `ABTOINTCLR` field.
    #[inline(always)]
    pub fn set_abtointclr<'a>(&'a mut self, new_value: UART_acr_abtointclr) -> UART_acr_Update<'a> {
        let mut setter: UART_acr_Update = UART_acr_Update::new(self);
        setter.set_abtointclr(new_value);
        setter
    }
    

    }


// Getter for UART_acr
/// `ACR`: Auto-baud Control Register. Contains controls for the auto-baud feature.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_acr_Get {
    value: u32,
}

impl UART_acr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_acr) -> UART_acr_Get {
        UART_acr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `START` field: Start bit. This bit is automatically cleared after auto-baud completion.
    #[inline(always)]
    pub fn start(&self) -> UART_acr_start {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(UART_acr_start::Stopped),
            1 => ::core::option::Option::Some(UART_acr_start::Started),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Auto-baud mode select
    #[inline(always)]
    pub fn mode(&self) -> UART_acr_mode {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(UART_acr_mode::Mode0),
            1 => ::core::option::Option::Some(UART_acr_mode::Mode1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `AUTORESTART` field: Restart enable
    #[inline(always)]
    pub fn autorestart(&self) -> UART_acr_autorestart {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(UART_acr_autorestart::NoRestart),
            1 => ::core::option::Option::Some(UART_acr_autorestart::RestartOnTimeout),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ABEOINTCLR` field: End of auto-baud interrupt clear (write only accessible)
    #[inline(always)]
    pub fn abeointclr(&self) -> UART_acr_abeointclr {
        match (self.value >> 8) & 1 {
            0 => ::core::option::Option::Some(UART_acr_abeointclr::NoImpact),
            1 => ::core::option::Option::Some(UART_acr_abeointclr::ClearInterrupt),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ABTOINTCLR` field: Auto-baud time-out interrupt clear (write only accessible)
    #[inline(always)]
    pub fn abtointclr(&self) -> UART_acr_abtointclr {
        match (self.value >> 9) & 1 {
            0 => ::core::option::Option::Some(UART_acr_abtointclr::NoImpact),
            1 => ::core::option::Option::Some(UART_acr_abtointclr::ClearInterrupt),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for UART_acr_Get { }


// Updater for UART_acr
/// Updater for `ACR` register.
#[allow(non_camel_case_types)]
pub struct UART_acr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_acr,
}

/// This performs the register update.
impl <'a> Drop for UART_acr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_acr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_acr) -> UART_acr_Update<'a> {
        UART_acr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_acr) -> UART_acr_Update<'a> {
        UART_acr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `START` field.
    #[inline(always)]
    pub fn set_start<'b>(&'b mut self, new_value: UART_acr_start) -> &'b mut UART_acr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: UART_acr_mode) -> &'b mut UART_acr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `AUTORESTART` field.
    #[inline(always)]
    pub fn set_autorestart<'b>(&'b mut self, new_value: UART_acr_autorestart) -> &'b mut UART_acr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `ABEOINTCLR` field.
    #[inline(always)]
    pub fn set_abeointclr<'b>(&'b mut self, new_value: UART_acr_abeointclr) -> &'b mut UART_acr_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `ABTOINTCLR` field.
    #[inline(always)]
    pub fn set_abtointclr<'b>(&'b mut self, new_value: UART_acr_abtointclr) -> &'b mut UART_acr_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_acr_start {
    /// Auto-baud stop (auto-baud is not running).
    Stopped = 0,
    /// Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion.
    Started = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_acr_mode {
    /// Mode 0.
    Mode0 = 0,
    /// Mode 1.
    Mode1 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_acr_autorestart {
    /// No restart
    NoRestart = 0,
    /// Restart in case of time-out (counter restarts at next UART Rx falling edge)
    RestartOnTimeout = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_acr_abeointclr {
    /// Writing a 0 has no impact.
    NoImpact = 0,
    /// Writing a 1 will clear the corresponding interrupt in the IIR.
    ClearInterrupt = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_acr_abtointclr {
    /// Writing a 0 has no impact.
    NoImpact = 0,
    /// Writing a 1 will clear the corresponding interrupt in the IIR.
    ClearInterrupt = 1,
    }







// Register FDR implementation


/// Register `FDR`: Fractional Divider Register. Generates a clock input for the baud rate divider.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_fdr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_fdr { }

impl UART_fdr {
    
    // Getters
    /// Fetch the value of the `FDR` register.
    #[inline(always)]
    pub fn get(&self) -> UART_fdr_Get {
        UART_fdr_Get::new(self)
    }

    
    /// Get value of `DIVADDVAL` field.
    #[inline(always)]
    pub fn divaddval(&self) -> u32 {
        UART_fdr_Get::new(self).divaddval()
    }
    
    /// Get value of `MULVAL` field.
    #[inline(always)]
    pub fn mulval(&self) -> u32 {
        UART_fdr_Get::new(self).mulval()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `FDR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_fdr_Update {
        UART_fdr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIVADDVAL` field.
    #[inline(always)]
    pub fn set_divaddval<'a>(&'a mut self, new_value: u32) -> UART_fdr_Update<'a> {
        let mut setter: UART_fdr_Update = UART_fdr_Update::new(self);
        setter.set_divaddval(new_value);
        setter
    }
    
    /// Set value of `MULVAL` field.
    #[inline(always)]
    pub fn set_mulval<'a>(&'a mut self, new_value: u32) -> UART_fdr_Update<'a> {
        let mut setter: UART_fdr_Update = UART_fdr_Update::new(self);
        setter.set_mulval(new_value);
        setter
    }
    

    }


// Getter for UART_fdr
/// `FDR`: Fractional Divider Register. Generates a clock input for the baud rate divider.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_fdr_Get {
    value: u32,
}

impl UART_fdr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_fdr) -> UART_fdr_Get {
        UART_fdr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIVADDVAL` field: Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the UART baud rate.
    #[inline(always)]
    pub fn divaddval(&self) -> u32 {
        (self.value >> 0) & 15
        }
    /// Get value of `MULVAL` field: Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for UART to operate properly, regardless of whether the fractional baud rate generator is used or not.
    #[inline(always)]
    pub fn mulval(&self) -> u32 {
        (self.value >> 4) & 15
        }
    }

impl ::core::marker::Copy for UART_fdr_Get { }


// Updater for UART_fdr
/// Updater for `FDR` register.
#[allow(non_camel_case_types)]
pub struct UART_fdr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_fdr,
}

/// This performs the register update.
impl <'a> Drop for UART_fdr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_fdr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_fdr) -> UART_fdr_Update<'a> {
        UART_fdr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_fdr) -> UART_fdr_Update<'a> {
        UART_fdr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIVADDVAL` field.
    #[inline(always)]
    pub fn set_divaddval<'b>(&'b mut self, new_value: u32) -> &'b mut UART_fdr_Update<'a> {
        self.value = (self.value & !(15 << 0))
                   | ((new_value as u32) & 15) << 0;
        self.mask |= 15 << 0;
        self
    }
    /// Set value of `MULVAL` field.
    #[inline(always)]
    pub fn set_mulval<'b>(&'b mut self, new_value: u32) -> &'b mut UART_fdr_Update<'a> {
        self.value = (self.value & !(15 << 4))
                   | ((new_value as u32) & 15) << 4;
        self.mask |= 15 << 4;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register TER implementation


/// Register `TER`: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_ter {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_ter { }

impl UART_ter {
    
    // Getters
    /// Fetch the value of the `TER` register.
    #[inline(always)]
    pub fn get(&self) -> UART_ter_Get {
        UART_ter_Get::new(self)
    }

    
    /// Get value of `TXEN` field.
    #[inline(always)]
    pub fn txen(&self) -> bool {
        UART_ter_Get::new(self).txen()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `TER` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_ter_Update {
        UART_ter_Update::new_ignoring_state(self)
    }

    
    /// Set value of `TXEN` field.
    #[inline(always)]
    pub fn set_txen<'a>(&'a mut self, new_value: bool) -> UART_ter_Update<'a> {
        let mut setter: UART_ter_Update = UART_ter_Update::new(self);
        setter.set_txen(new_value);
        setter
    }
    

    }


// Getter for UART_ter
/// `TER`: Transmit Enable Register. Turns off UART transmitter for use with software flow control.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_ter_Get {
    value: u32,
}

impl UART_ter_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_ter) -> UART_ter_Get {
        UART_ter_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TXEN` field: When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character.
    #[inline(always)]
    pub fn txen(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    }

impl ::core::marker::Copy for UART_ter_Get { }


// Updater for UART_ter
/// Updater for `TER` register.
#[allow(non_camel_case_types)]
pub struct UART_ter_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_ter,
}

/// This performs the register update.
impl <'a> Drop for UART_ter_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_ter_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_ter) -> UART_ter_Update<'a> {
        UART_ter_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_ter) -> UART_ter_Update<'a> {
        UART_ter_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `TXEN` field.
    #[inline(always)]
    pub fn set_txen<'b>(&'b mut self, new_value: bool) -> &'b mut UART_ter_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register RS485CTRL implementation


/// Register `RS485CTRL`: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_rs485ctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_rs485ctrl { }

impl UART_rs485ctrl {
    
    // Getters
    /// Fetch the value of the `RS485CTRL` register.
    #[inline(always)]
    pub fn get(&self) -> UART_rs485ctrl_Get {
        UART_rs485ctrl_Get::new(self)
    }

    
    /// Get value of `NMMEN` field.
    #[inline(always)]
    pub fn nmmen(&self) -> UART_rs485ctrl_nmmen {
        UART_rs485ctrl_Get::new(self).nmmen()
    }
    
    /// Get value of `RXDIS` field.
    #[inline(always)]
    pub fn rxdis(&self) -> UART_rs485ctrl_rxdis {
        UART_rs485ctrl_Get::new(self).rxdis()
    }
    
    /// Get value of `AADEN` field.
    #[inline(always)]
    pub fn aaden(&self) -> UART_rs485ctrl_aaden {
        UART_rs485ctrl_Get::new(self).aaden()
    }
    
    /// Get value of `SEL` field.
    #[inline(always)]
    pub fn sel(&self) -> UART_rs485ctrl_sel {
        UART_rs485ctrl_Get::new(self).sel()
    }
    
    /// Get value of `DCTRL` field.
    #[inline(always)]
    pub fn dctrl(&self) -> UART_rs485ctrl_dctrl {
        UART_rs485ctrl_Get::new(self).dctrl()
    }
    
    /// Get value of `OINV` field.
    #[inline(always)]
    pub fn oinv(&self) -> UART_rs485ctrl_oinv {
        UART_rs485ctrl_Get::new(self).oinv()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `RS485CTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_rs485ctrl_Update {
        UART_rs485ctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `NMMEN` field.
    #[inline(always)]
    pub fn set_nmmen<'a>(&'a mut self, new_value: UART_rs485ctrl_nmmen) -> UART_rs485ctrl_Update<'a> {
        let mut setter: UART_rs485ctrl_Update = UART_rs485ctrl_Update::new(self);
        setter.set_nmmen(new_value);
        setter
    }
    
    /// Set value of `RXDIS` field.
    #[inline(always)]
    pub fn set_rxdis<'a>(&'a mut self, new_value: UART_rs485ctrl_rxdis) -> UART_rs485ctrl_Update<'a> {
        let mut setter: UART_rs485ctrl_Update = UART_rs485ctrl_Update::new(self);
        setter.set_rxdis(new_value);
        setter
    }
    
    /// Set value of `AADEN` field.
    #[inline(always)]
    pub fn set_aaden<'a>(&'a mut self, new_value: UART_rs485ctrl_aaden) -> UART_rs485ctrl_Update<'a> {
        let mut setter: UART_rs485ctrl_Update = UART_rs485ctrl_Update::new(self);
        setter.set_aaden(new_value);
        setter
    }
    
    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'a>(&'a mut self, new_value: UART_rs485ctrl_sel) -> UART_rs485ctrl_Update<'a> {
        let mut setter: UART_rs485ctrl_Update = UART_rs485ctrl_Update::new(self);
        setter.set_sel(new_value);
        setter
    }
    
    /// Set value of `DCTRL` field.
    #[inline(always)]
    pub fn set_dctrl<'a>(&'a mut self, new_value: UART_rs485ctrl_dctrl) -> UART_rs485ctrl_Update<'a> {
        let mut setter: UART_rs485ctrl_Update = UART_rs485ctrl_Update::new(self);
        setter.set_dctrl(new_value);
        setter
    }
    
    /// Set value of `OINV` field.
    #[inline(always)]
    pub fn set_oinv<'a>(&'a mut self, new_value: UART_rs485ctrl_oinv) -> UART_rs485ctrl_Update<'a> {
        let mut setter: UART_rs485ctrl_Update = UART_rs485ctrl_Update::new(self);
        setter.set_oinv(new_value);
        setter
    }
    

    }


// Getter for UART_rs485ctrl
/// `RS485CTRL`: RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_rs485ctrl_Get {
    value: u32,
}

impl UART_rs485ctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_rs485ctrl) -> UART_rs485ctrl_Get {
        UART_rs485ctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `NMMEN` field: NMM enable.
    #[inline(always)]
    pub fn nmmen(&self) -> UART_rs485ctrl_nmmen {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(UART_rs485ctrl_nmmen::Disabled),
            1 => ::core::option::Option::Some(UART_rs485ctrl_nmmen::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RXDIS` field: Receiver enable.
    #[inline(always)]
    pub fn rxdis(&self) -> UART_rs485ctrl_rxdis {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(UART_rs485ctrl_rxdis::Enabled),
            1 => ::core::option::Option::Some(UART_rs485ctrl_rxdis::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `AADEN` field: AAD enable.
    #[inline(always)]
    pub fn aaden(&self) -> UART_rs485ctrl_aaden {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(UART_rs485ctrl_aaden::Disabled),
            1 => ::core::option::Option::Some(UART_rs485ctrl_aaden::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SEL` field: Select direction control pin
    #[inline(always)]
    pub fn sel(&self) -> UART_rs485ctrl_sel {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(UART_rs485ctrl_sel::RTS),
            1 => ::core::option::Option::Some(UART_rs485ctrl_sel::DTR),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DCTRL` field: Auto direction control enable.
    #[inline(always)]
    pub fn dctrl(&self) -> UART_rs485ctrl_dctrl {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(UART_rs485ctrl_dctrl::Disabled),
            1 => ::core::option::Option::Some(UART_rs485ctrl_dctrl::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OINV` field: Polarity control. This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin.
    #[inline(always)]
    pub fn oinv(&self) -> UART_rs485ctrl_oinv {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(UART_rs485ctrl_oinv::Low),
            1 => ::core::option::Option::Some(UART_rs485ctrl_oinv::High),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for UART_rs485ctrl_Get { }


// Updater for UART_rs485ctrl
/// Updater for `RS485CTRL` register.
#[allow(non_camel_case_types)]
pub struct UART_rs485ctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_rs485ctrl,
}

/// This performs the register update.
impl <'a> Drop for UART_rs485ctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_rs485ctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_rs485ctrl) -> UART_rs485ctrl_Update<'a> {
        UART_rs485ctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_rs485ctrl) -> UART_rs485ctrl_Update<'a> {
        UART_rs485ctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `NMMEN` field.
    #[inline(always)]
    pub fn set_nmmen<'b>(&'b mut self, new_value: UART_rs485ctrl_nmmen) -> &'b mut UART_rs485ctrl_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `RXDIS` field.
    #[inline(always)]
    pub fn set_rxdis<'b>(&'b mut self, new_value: UART_rs485ctrl_rxdis) -> &'b mut UART_rs485ctrl_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `AADEN` field.
    #[inline(always)]
    pub fn set_aaden<'b>(&'b mut self, new_value: UART_rs485ctrl_aaden) -> &'b mut UART_rs485ctrl_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'b>(&'b mut self, new_value: UART_rs485ctrl_sel) -> &'b mut UART_rs485ctrl_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `DCTRL` field.
    #[inline(always)]
    pub fn set_dctrl<'b>(&'b mut self, new_value: UART_rs485ctrl_dctrl) -> &'b mut UART_rs485ctrl_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `OINV` field.
    #[inline(always)]
    pub fn set_oinv<'b>(&'b mut self, new_value: UART_rs485ctrl_oinv) -> &'b mut UART_rs485ctrl_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_rs485ctrl_nmmen {
    /// RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled.
    Disabled = 0,
    /// RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the UART to set the parity error and generate an interrupt.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_rs485ctrl_rxdis {
    /// The receiver is enabled.
    Enabled = 0,
    /// The receiver is disabled.
    Disabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_rs485ctrl_aaden {
    /// Auto Address Detect (AAD) is disabled.
    Disabled = 0,
    /// Auto Address Detect (AAD) is enabled.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_rs485ctrl_sel {
    /// If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control.
    RTS = 0,
    /// If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control.
    DTR = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_rs485ctrl_dctrl {
    /// Disable Auto Direction Control.
    Disabled = 0,
    /// Enable Auto Direction Control.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum UART_rs485ctrl_oinv {
    /// The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted.
    Low = 0,
    /// The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted.
    High = 1,
    }







// Register RS485ADRMATCH implementation


/// Register `RS485ADRMATCH`: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_rs485adrmatch {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_rs485adrmatch { }

impl UART_rs485adrmatch {
    
    // Getters
    /// Fetch the value of the `RS485ADRMATCH` register.
    #[inline(always)]
    pub fn get(&self) -> UART_rs485adrmatch_Get {
        UART_rs485adrmatch_Get::new(self)
    }

    
    /// Get value of `ADRMATCH` field.
    #[inline(always)]
    pub fn adrmatch(&self) -> u32 {
        UART_rs485adrmatch_Get::new(self).adrmatch()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `RS485ADRMATCH` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_rs485adrmatch_Update {
        UART_rs485adrmatch_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ADRMATCH` field.
    #[inline(always)]
    pub fn set_adrmatch<'a>(&'a mut self, new_value: u32) -> UART_rs485adrmatch_Update<'a> {
        let mut setter: UART_rs485adrmatch_Update = UART_rs485adrmatch_Update::new(self);
        setter.set_adrmatch(new_value);
        setter
    }
    

    }


// Getter for UART_rs485adrmatch
/// `RS485ADRMATCH`: RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_rs485adrmatch_Get {
    value: u32,
}

impl UART_rs485adrmatch_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_rs485adrmatch) -> UART_rs485adrmatch_Get {
        UART_rs485adrmatch_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ADRMATCH` field: Contains the address match value.
    #[inline(always)]
    pub fn adrmatch(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for UART_rs485adrmatch_Get { }


// Updater for UART_rs485adrmatch
/// Updater for `RS485ADRMATCH` register.
#[allow(non_camel_case_types)]
pub struct UART_rs485adrmatch_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_rs485adrmatch,
}

/// This performs the register update.
impl <'a> Drop for UART_rs485adrmatch_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_rs485adrmatch_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_rs485adrmatch) -> UART_rs485adrmatch_Update<'a> {
        UART_rs485adrmatch_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_rs485adrmatch) -> UART_rs485adrmatch_Update<'a> {
        UART_rs485adrmatch_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ADRMATCH` field.
    #[inline(always)]
    pub fn set_adrmatch<'b>(&'b mut self, new_value: u32) -> &'b mut UART_rs485adrmatch_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register RS485DLY implementation


/// Register `RS485DLY`: RS-485/EIA-485 direction control delay.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct UART_rs485dly {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for UART_rs485dly { }

impl UART_rs485dly {
    
    // Getters
    /// Fetch the value of the `RS485DLY` register.
    #[inline(always)]
    pub fn get(&self) -> UART_rs485dly_Get {
        UART_rs485dly_Get::new(self)
    }

    
    /// Get value of `DLY` field.
    #[inline(always)]
    pub fn dly(&self) -> u32 {
        UART_rs485dly_Get::new(self).dly()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `RS485DLY` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> UART_rs485dly_Update {
        UART_rs485dly_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DLY` field.
    #[inline(always)]
    pub fn set_dly<'a>(&'a mut self, new_value: u32) -> UART_rs485dly_Update<'a> {
        let mut setter: UART_rs485dly_Update = UART_rs485dly_Update::new(self);
        setter.set_dly(new_value);
        setter
    }
    

    }


// Getter for UART_rs485dly
/// `RS485DLY`: RS-485/EIA-485 direction control delay.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct UART_rs485dly_Get {
    value: u32,
}

impl UART_rs485dly_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &UART_rs485dly) -> UART_rs485dly_Get {
        UART_rs485dly_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DLY` field: Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter.
    #[inline(always)]
    pub fn dly(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for UART_rs485dly_Get { }


// Updater for UART_rs485dly
/// Updater for `RS485DLY` register.
#[allow(non_camel_case_types)]
pub struct UART_rs485dly_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a UART_rs485dly,
}

/// This performs the register update.
impl <'a> Drop for UART_rs485dly_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> UART_rs485dly_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a UART_rs485dly) -> UART_rs485dly_Update<'a> {
        UART_rs485dly_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a UART_rs485dly) -> UART_rs485dly_Update<'a> {
        UART_rs485dly_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DLY` field.
    #[inline(always)]
    pub fn set_dly<'b>(&'b mut self, new_value: u32) -> &'b mut UART_rs485dly_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral UART implementation

/// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx UART Modification date=9/19/2011 Major revision=7 Minor revision=not available 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct UART;

impl UART {
    /// Receiver Buffer Register. Contains the next received character to be read. (DLAB=0)
    #[inline(always)]
    pub fn rbr() -> &'static mut UART_rbr {
        unsafe { ::core::intrinsics::transmute(0x40008000 as usize) }
    }
    /// Transmit Holding Register. The next character to be transmitted is written here. (DLAB=0)
    #[inline(always)]
    pub fn thr() -> &'static mut UART_thr {
        unsafe { ::core::intrinsics::transmute(0x40008000 as usize) }
    }
    /// Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
    #[inline(always)]
    pub fn dll() -> &'static mut UART_dll {
        unsafe { ::core::intrinsics::transmute(0x40008000 as usize) }
    }
    /// Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. (DLAB=1)
    #[inline(always)]
    pub fn dlm() -> &'static mut UART_dlm {
        unsafe { ::core::intrinsics::transmute(0x40008004 as usize) }
    }
    /// Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts. (DLAB=0)
    #[inline(always)]
    pub fn ier() -> &'static mut UART_ier {
        unsafe { ::core::intrinsics::transmute(0x40008004 as usize) }
    }
    /// Interrupt ID Register. Identifies which interrupt(s) are pending.
    #[inline(always)]
    pub fn iir() -> &'static mut UART_iir {
        unsafe { ::core::intrinsics::transmute(0x40008008 as usize) }
    }
    /// FIFO Control Register. Controls UART FIFO usage and modes.
    #[inline(always)]
    pub fn fcr() -> &'static mut UART_fcr {
        unsafe { ::core::intrinsics::transmute(0x40008008 as usize) }
    }
    /// Line Control Register. Contains controls for frame formatting and break generation.
    #[inline(always)]
    pub fn lcr() -> &'static mut UART_lcr {
        unsafe { ::core::intrinsics::transmute(0x4000800c as usize) }
    }
    /// Modem control register
    #[inline(always)]
    pub fn mcr() -> &'static mut UART_mcr {
        unsafe { ::core::intrinsics::transmute(0x40008010 as usize) }
    }
    /// Line Status Register. Contains flags for transmit and receive status, including line errors.
    #[inline(always)]
    pub fn lsr() -> &'static mut UART_lsr {
        unsafe { ::core::intrinsics::transmute(0x40008014 as usize) }
    }
    /// Modem status register
    #[inline(always)]
    pub fn msr() -> &'static mut UART_msr {
        unsafe { ::core::intrinsics::transmute(0x40008018 as usize) }
    }
    /// Scratch Pad Register. Eight-bit temporary storage for software.
    #[inline(always)]
    pub fn scr() -> &'static mut UART_scr {
        unsafe { ::core::intrinsics::transmute(0x4000801c as usize) }
    }
    /// Auto-baud Control Register. Contains controls for the auto-baud feature.
    #[inline(always)]
    pub fn acr() -> &'static mut UART_acr {
        unsafe { ::core::intrinsics::transmute(0x40008020 as usize) }
    }
    /// Fractional Divider Register. Generates a clock input for the baud rate divider.
    #[inline(always)]
    pub fn fdr() -> &'static mut UART_fdr {
        unsafe { ::core::intrinsics::transmute(0x40008028 as usize) }
    }
    /// Transmit Enable Register. Turns off UART transmitter for use with software flow control.
    #[inline(always)]
    pub fn ter() -> &'static mut UART_ter {
        unsafe { ::core::intrinsics::transmute(0x40008030 as usize) }
    }
    /// RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes.
    #[inline(always)]
    pub fn rs485ctrl() -> &'static mut UART_rs485ctrl {
        unsafe { ::core::intrinsics::transmute(0x4000804c as usize) }
    }
    /// RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode.
    #[inline(always)]
    pub fn rs485adrmatch() -> &'static mut UART_rs485adrmatch {
        unsafe { ::core::intrinsics::transmute(0x40008050 as usize) }
    }
    /// RS-485/EIA-485 direction control delay.
    #[inline(always)]
    pub fn rs485dly() -> &'static mut UART_rs485dly {
        unsafe { ::core::intrinsics::transmute(0x40008054 as usize) }
    }
    }



// Registers for CT16B0





// Register IR implementation


/// Register `IR`: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_ir {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_ir { }

impl CT16B0_ir {
    
    // Getters
    /// Fetch the value of the `IR` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_ir_Get {
        CT16B0_ir_Get::new(self)
    }

    
    /// Get value of `MR0INT` field.
    #[inline(always)]
    pub fn mr0int(&self) -> bool {
        CT16B0_ir_Get::new(self).mr0int()
    }
    
    /// Get value of `MR1INT` field.
    #[inline(always)]
    pub fn mr1int(&self) -> bool {
        CT16B0_ir_Get::new(self).mr1int()
    }
    
    /// Get value of `MR2INT` field.
    #[inline(always)]
    pub fn mr2int(&self) -> bool {
        CT16B0_ir_Get::new(self).mr2int()
    }
    
    /// Get value of `MR3INT` field.
    #[inline(always)]
    pub fn mr3int(&self) -> bool {
        CT16B0_ir_Get::new(self).mr3int()
    }
    
    /// Get value of `CR0INT` field.
    #[inline(always)]
    pub fn cr0int(&self) -> bool {
        CT16B0_ir_Get::new(self).cr0int()
    }
    
    /// Get value of `CR1INT` field.
    #[inline(always)]
    pub fn cr1int(&self) -> bool {
        CT16B0_ir_Get::new(self).cr1int()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_ir_Update {
        CT16B0_ir_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MR0INT` field.
    #[inline(always)]
    pub fn set_mr0int<'a>(&'a mut self, new_value: bool) -> CT16B0_ir_Update<'a> {
        let mut setter: CT16B0_ir_Update = CT16B0_ir_Update::new(self);
        setter.set_mr0int(new_value);
        setter
    }
    
    /// Set value of `MR1INT` field.
    #[inline(always)]
    pub fn set_mr1int<'a>(&'a mut self, new_value: bool) -> CT16B0_ir_Update<'a> {
        let mut setter: CT16B0_ir_Update = CT16B0_ir_Update::new(self);
        setter.set_mr1int(new_value);
        setter
    }
    
    /// Set value of `MR2INT` field.
    #[inline(always)]
    pub fn set_mr2int<'a>(&'a mut self, new_value: bool) -> CT16B0_ir_Update<'a> {
        let mut setter: CT16B0_ir_Update = CT16B0_ir_Update::new(self);
        setter.set_mr2int(new_value);
        setter
    }
    
    /// Set value of `MR3INT` field.
    #[inline(always)]
    pub fn set_mr3int<'a>(&'a mut self, new_value: bool) -> CT16B0_ir_Update<'a> {
        let mut setter: CT16B0_ir_Update = CT16B0_ir_Update::new(self);
        setter.set_mr3int(new_value);
        setter
    }
    
    /// Set value of `CR0INT` field.
    #[inline(always)]
    pub fn set_cr0int<'a>(&'a mut self, new_value: bool) -> CT16B0_ir_Update<'a> {
        let mut setter: CT16B0_ir_Update = CT16B0_ir_Update::new(self);
        setter.set_cr0int(new_value);
        setter
    }
    
    /// Set value of `CR1INT` field.
    #[inline(always)]
    pub fn set_cr1int<'a>(&'a mut self, new_value: bool) -> CT16B0_ir_Update<'a> {
        let mut setter: CT16B0_ir_Update = CT16B0_ir_Update::new(self);
        setter.set_cr1int(new_value);
        setter
    }
    

    }


// Getter for CT16B0_ir
/// `IR`: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_ir_Get {
    value: u32,
}

impl CT16B0_ir_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_ir) -> CT16B0_ir_Get {
        CT16B0_ir_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MR0INT` field: Interrupt flag for match channel 0.
    #[inline(always)]
    pub fn mr0int(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `MR1INT` field: Interrupt flag for match channel 1.
    #[inline(always)]
    pub fn mr1int(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `MR2INT` field: Interrupt flag for match channel 2.
    #[inline(always)]
    pub fn mr2int(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `MR3INT` field: Interrupt flag for match channel 3.
    #[inline(always)]
    pub fn mr3int(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `CR0INT` field: Interrupt flag for capture channel 0 event.
    #[inline(always)]
    pub fn cr0int(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `CR1INT` field: Interrupt flag for capture channel 1 event.
    #[inline(always)]
    pub fn cr1int(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    }

impl ::core::marker::Copy for CT16B0_ir_Get { }


// Updater for CT16B0_ir
/// Updater for `IR` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_ir_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_ir,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_ir_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_ir_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_ir) -> CT16B0_ir_Update<'a> {
        CT16B0_ir_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_ir) -> CT16B0_ir_Update<'a> {
        CT16B0_ir_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MR0INT` field.
    #[inline(always)]
    pub fn set_mr0int<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `MR1INT` field.
    #[inline(always)]
    pub fn set_mr1int<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `MR2INT` field.
    #[inline(always)]
    pub fn set_mr2int<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `MR3INT` field.
    #[inline(always)]
    pub fn set_mr3int<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CR0INT` field.
    #[inline(always)]
    pub fn set_cr0int<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `CR1INT` field.
    #[inline(always)]
    pub fn set_cr1int<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register TCR implementation


/// Register `TCR`: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_tcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_tcr { }

impl CT16B0_tcr {
    
    // Getters
    /// Fetch the value of the `TCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_tcr_Get {
        CT16B0_tcr_Get::new(self)
    }

    
    /// Get value of `CEN` field.
    #[inline(always)]
    pub fn cen(&self) -> bool {
        CT16B0_tcr_Get::new(self).cen()
    }
    
    /// Get value of `CRST` field.
    #[inline(always)]
    pub fn crst(&self) -> bool {
        CT16B0_tcr_Get::new(self).crst()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `TCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_tcr_Update {
        CT16B0_tcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CEN` field.
    #[inline(always)]
    pub fn set_cen<'a>(&'a mut self, new_value: bool) -> CT16B0_tcr_Update<'a> {
        let mut setter: CT16B0_tcr_Update = CT16B0_tcr_Update::new(self);
        setter.set_cen(new_value);
        setter
    }
    
    /// Set value of `CRST` field.
    #[inline(always)]
    pub fn set_crst<'a>(&'a mut self, new_value: bool) -> CT16B0_tcr_Update<'a> {
        let mut setter: CT16B0_tcr_Update = CT16B0_tcr_Update::new(self);
        setter.set_crst(new_value);
        setter
    }
    

    }


// Getter for CT16B0_tcr
/// `TCR`: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_tcr_Get {
    value: u32,
}

impl CT16B0_tcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_tcr) -> CT16B0_tcr_Get {
        CT16B0_tcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CEN` field: Counter Enable. When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled.
    #[inline(always)]
    pub fn cen(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `CRST` field: Counter Reset. When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.
    #[inline(always)]
    pub fn crst(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    }

impl ::core::marker::Copy for CT16B0_tcr_Get { }


// Updater for CT16B0_tcr
/// Updater for `TCR` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_tcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_tcr,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_tcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_tcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_tcr) -> CT16B0_tcr_Update<'a> {
        CT16B0_tcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_tcr) -> CT16B0_tcr_Update<'a> {
        CT16B0_tcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CEN` field.
    #[inline(always)]
    pub fn set_cen<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_tcr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `CRST` field.
    #[inline(always)]
    pub fn set_crst<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_tcr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register TC implementation


/// Register `TC`: Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_tc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_tc { }

impl CT16B0_tc {
    
    // Getters
    /// Fetch the value of the `TC` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_tc_Get {
        CT16B0_tc_Get::new(self)
    }

    
    /// Get value of `TC` field.
    #[inline(always)]
    pub fn tc(&self) -> u32 {
        CT16B0_tc_Get::new(self).tc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `TC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_tc_Update {
        CT16B0_tc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `TC` field.
    #[inline(always)]
    pub fn set_tc<'a>(&'a mut self, new_value: u32) -> CT16B0_tc_Update<'a> {
        let mut setter: CT16B0_tc_Update = CT16B0_tc_Update::new(self);
        setter.set_tc(new_value);
        setter
    }
    

    }


// Getter for CT16B0_tc
/// `TC`: Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_tc_Get {
    value: u32,
}

impl CT16B0_tc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_tc) -> CT16B0_tc_Get {
        CT16B0_tc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TC` field: Timer counter value.
    #[inline(always)]
    pub fn tc(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_tc_Get { }


// Updater for CT16B0_tc
/// Updater for `TC` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_tc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_tc,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_tc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_tc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_tc) -> CT16B0_tc_Update<'a> {
        CT16B0_tc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_tc) -> CT16B0_tc_Update<'a> {
        CT16B0_tc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `TC` field.
    #[inline(always)]
    pub fn set_tc<'b>(&'b mut self, new_value: u32) -> &'b mut CT16B0_tc_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register PR implementation


/// Register `PR`: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_pr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_pr { }

impl CT16B0_pr {
    
    // Getters
    /// Fetch the value of the `PR` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_pr_Get {
        CT16B0_pr_Get::new(self)
    }

    
    /// Get value of `PR` field.
    #[inline(always)]
    pub fn pr(&self) -> u32 {
        CT16B0_pr_Get::new(self).pr()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_pr_Update {
        CT16B0_pr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `PR` field.
    #[inline(always)]
    pub fn set_pr<'a>(&'a mut self, new_value: u32) -> CT16B0_pr_Update<'a> {
        let mut setter: CT16B0_pr_Update = CT16B0_pr_Update::new(self);
        setter.set_pr(new_value);
        setter
    }
    

    }


// Getter for CT16B0_pr
/// `PR`: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_pr_Get {
    value: u32,
}

impl CT16B0_pr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_pr) -> CT16B0_pr_Get {
        CT16B0_pr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `PR` field: Prescale max value.
    #[inline(always)]
    pub fn pr(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_pr_Get { }


// Updater for CT16B0_pr
/// Updater for `PR` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_pr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_pr,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_pr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_pr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_pr) -> CT16B0_pr_Update<'a> {
        CT16B0_pr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_pr) -> CT16B0_pr_Update<'a> {
        CT16B0_pr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `PR` field.
    #[inline(always)]
    pub fn set_pr<'b>(&'b mut self, new_value: u32) -> &'b mut CT16B0_pr_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register PC implementation


/// Register `PC`: Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_pc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_pc { }

impl CT16B0_pc {
    
    // Getters
    /// Fetch the value of the `PC` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_pc_Get {
        CT16B0_pc_Get::new(self)
    }

    
    /// Get value of `PC` field.
    #[inline(always)]
    pub fn pc(&self) -> u32 {
        CT16B0_pc_Get::new(self).pc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_pc_Update {
        CT16B0_pc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `PC` field.
    #[inline(always)]
    pub fn set_pc<'a>(&'a mut self, new_value: u32) -> CT16B0_pc_Update<'a> {
        let mut setter: CT16B0_pc_Update = CT16B0_pc_Update::new(self);
        setter.set_pc(new_value);
        setter
    }
    

    }


// Getter for CT16B0_pc
/// `PC`: Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_pc_Get {
    value: u32,
}

impl CT16B0_pc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_pc) -> CT16B0_pc_Get {
        CT16B0_pc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `PC` field: Prescale counter value.
    #[inline(always)]
    pub fn pc(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_pc_Get { }


// Updater for CT16B0_pc
/// Updater for `PC` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_pc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_pc,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_pc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_pc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_pc) -> CT16B0_pc_Update<'a> {
        CT16B0_pc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_pc) -> CT16B0_pc_Update<'a> {
        CT16B0_pc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `PC` field.
    #[inline(always)]
    pub fn set_pc<'b>(&'b mut self, new_value: u32) -> &'b mut CT16B0_pc_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MCR implementation


/// Register `MCR`: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_mcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_mcr { }

impl CT16B0_mcr {
    
    // Getters
    /// Fetch the value of the `MCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_mcr_Get {
        CT16B0_mcr_Get::new(self)
    }

    
    /// Get value of `MR0I` field.
    #[inline(always)]
    pub fn mr0i(&self) -> CT16B0_mcr_mr0i {
        CT16B0_mcr_Get::new(self).mr0i()
    }
    
    /// Get value of `MR0R` field.
    #[inline(always)]
    pub fn mr0r(&self) -> CT16B0_mcr_mr0r {
        CT16B0_mcr_Get::new(self).mr0r()
    }
    
    /// Get value of `MR0S` field.
    #[inline(always)]
    pub fn mr0s(&self) -> CT16B0_mcr_mr0s {
        CT16B0_mcr_Get::new(self).mr0s()
    }
    
    /// Get value of `MR1I` field.
    #[inline(always)]
    pub fn mr1i(&self) -> CT16B0_mcr_mr1i {
        CT16B0_mcr_Get::new(self).mr1i()
    }
    
    /// Get value of `MR1R` field.
    #[inline(always)]
    pub fn mr1r(&self) -> CT16B0_mcr_mr1r {
        CT16B0_mcr_Get::new(self).mr1r()
    }
    
    /// Get value of `MR1S` field.
    #[inline(always)]
    pub fn mr1s(&self) -> CT16B0_mcr_mr1s {
        CT16B0_mcr_Get::new(self).mr1s()
    }
    
    /// Get value of `MR2I` field.
    #[inline(always)]
    pub fn mr2i(&self) -> CT16B0_mcr_mr2i {
        CT16B0_mcr_Get::new(self).mr2i()
    }
    
    /// Get value of `MR2R` field.
    #[inline(always)]
    pub fn mr2r(&self) -> CT16B0_mcr_mr2r {
        CT16B0_mcr_Get::new(self).mr2r()
    }
    
    /// Get value of `MR2S` field.
    #[inline(always)]
    pub fn mr2s(&self) -> CT16B0_mcr_mr2s {
        CT16B0_mcr_Get::new(self).mr2s()
    }
    
    /// Get value of `MR3I` field.
    #[inline(always)]
    pub fn mr3i(&self) -> CT16B0_mcr_mr3i {
        CT16B0_mcr_Get::new(self).mr3i()
    }
    
    /// Get value of `MR3R` field.
    #[inline(always)]
    pub fn mr3r(&self) -> CT16B0_mcr_mr3r {
        CT16B0_mcr_Get::new(self).mr3r()
    }
    
    /// Get value of `MR3S` field.
    #[inline(always)]
    pub fn mr3s(&self) -> CT16B0_mcr_mr3s {
        CT16B0_mcr_Get::new(self).mr3s()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_mcr_Update {
        CT16B0_mcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MR0I` field.
    #[inline(always)]
    pub fn set_mr0i<'a>(&'a mut self, new_value: CT16B0_mcr_mr0i) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr0i(new_value);
        setter
    }
    
    /// Set value of `MR0R` field.
    #[inline(always)]
    pub fn set_mr0r<'a>(&'a mut self, new_value: CT16B0_mcr_mr0r) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr0r(new_value);
        setter
    }
    
    /// Set value of `MR0S` field.
    #[inline(always)]
    pub fn set_mr0s<'a>(&'a mut self, new_value: CT16B0_mcr_mr0s) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr0s(new_value);
        setter
    }
    
    /// Set value of `MR1I` field.
    #[inline(always)]
    pub fn set_mr1i<'a>(&'a mut self, new_value: CT16B0_mcr_mr1i) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr1i(new_value);
        setter
    }
    
    /// Set value of `MR1R` field.
    #[inline(always)]
    pub fn set_mr1r<'a>(&'a mut self, new_value: CT16B0_mcr_mr1r) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr1r(new_value);
        setter
    }
    
    /// Set value of `MR1S` field.
    #[inline(always)]
    pub fn set_mr1s<'a>(&'a mut self, new_value: CT16B0_mcr_mr1s) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr1s(new_value);
        setter
    }
    
    /// Set value of `MR2I` field.
    #[inline(always)]
    pub fn set_mr2i<'a>(&'a mut self, new_value: CT16B0_mcr_mr2i) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr2i(new_value);
        setter
    }
    
    /// Set value of `MR2R` field.
    #[inline(always)]
    pub fn set_mr2r<'a>(&'a mut self, new_value: CT16B0_mcr_mr2r) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr2r(new_value);
        setter
    }
    
    /// Set value of `MR2S` field.
    #[inline(always)]
    pub fn set_mr2s<'a>(&'a mut self, new_value: CT16B0_mcr_mr2s) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr2s(new_value);
        setter
    }
    
    /// Set value of `MR3I` field.
    #[inline(always)]
    pub fn set_mr3i<'a>(&'a mut self, new_value: CT16B0_mcr_mr3i) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr3i(new_value);
        setter
    }
    
    /// Set value of `MR3R` field.
    #[inline(always)]
    pub fn set_mr3r<'a>(&'a mut self, new_value: CT16B0_mcr_mr3r) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr3r(new_value);
        setter
    }
    
    /// Set value of `MR3S` field.
    #[inline(always)]
    pub fn set_mr3s<'a>(&'a mut self, new_value: CT16B0_mcr_mr3s) -> CT16B0_mcr_Update<'a> {
        let mut setter: CT16B0_mcr_Update = CT16B0_mcr_Update::new(self);
        setter.set_mr3s(new_value);
        setter
    }
    

    }


// Getter for CT16B0_mcr
/// `MCR`: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_mcr_Get {
    value: u32,
}

impl CT16B0_mcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_mcr) -> CT16B0_mcr_Get {
        CT16B0_mcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MR0I` field: Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.
    #[inline(always)]
    pub fn mr0i(&self) -> CT16B0_mcr_mr0i {
        match (self.value >> 0) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr0i::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr0i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR0R` field: Reset on MR0: the TC will be reset if MR0 matches it.
    #[inline(always)]
    pub fn mr0r(&self) -> CT16B0_mcr_mr0r {
        match (self.value >> 1) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr0r::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr0r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR0S` field: Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.
    #[inline(always)]
    pub fn mr0s(&self) -> CT16B0_mcr_mr0s {
        match (self.value >> 2) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr0s::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr0s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR1I` field: Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC.
    #[inline(always)]
    pub fn mr1i(&self) -> CT16B0_mcr_mr1i {
        match (self.value >> 3) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr1i::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr1i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR1R` field: Reset on MR1: the TC will be reset if MR1 matches it.
    #[inline(always)]
    pub fn mr1r(&self) -> CT16B0_mcr_mr1r {
        match (self.value >> 4) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr1r::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr1r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR1S` field: Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.
    #[inline(always)]
    pub fn mr1s(&self) -> CT16B0_mcr_mr1s {
        match (self.value >> 5) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr1s::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr1s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR2I` field: Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC.
    #[inline(always)]
    pub fn mr2i(&self) -> CT16B0_mcr_mr2i {
        match (self.value >> 6) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr2i::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr2i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR2R` field: Reset on MR2: the TC will be reset if MR2 matches it.
    #[inline(always)]
    pub fn mr2r(&self) -> CT16B0_mcr_mr2r {
        match (self.value >> 7) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr2r::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr2r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR2S` field: Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.
    #[inline(always)]
    pub fn mr2s(&self) -> CT16B0_mcr_mr2s {
        match (self.value >> 8) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr2s::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr2s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR3I` field: Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC.
    #[inline(always)]
    pub fn mr3i(&self) -> CT16B0_mcr_mr3i {
        match (self.value >> 9) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr3i::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr3i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR3R` field: Reset on MR3: the TC will be reset if MR3 matches it.
    #[inline(always)]
    pub fn mr3r(&self) -> CT16B0_mcr_mr3r {
        match (self.value >> 10) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr3r::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr3r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR3S` field: Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.
    #[inline(always)]
    pub fn mr3s(&self) -> CT16B0_mcr_mr3s {
        match (self.value >> 11) & 1 {
            1 => ::core::option::Option::Some(CT16B0_mcr_mr3s::Enabled),
            0 => ::core::option::Option::Some(CT16B0_mcr_mr3s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT16B0_mcr_Get { }


// Updater for CT16B0_mcr
/// Updater for `MCR` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_mcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_mcr,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_mcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_mcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_mcr) -> CT16B0_mcr_Update<'a> {
        CT16B0_mcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_mcr) -> CT16B0_mcr_Update<'a> {
        CT16B0_mcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MR0I` field.
    #[inline(always)]
    pub fn set_mr0i<'b>(&'b mut self, new_value: CT16B0_mcr_mr0i) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `MR0R` field.
    #[inline(always)]
    pub fn set_mr0r<'b>(&'b mut self, new_value: CT16B0_mcr_mr0r) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `MR0S` field.
    #[inline(always)]
    pub fn set_mr0s<'b>(&'b mut self, new_value: CT16B0_mcr_mr0s) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `MR1I` field.
    #[inline(always)]
    pub fn set_mr1i<'b>(&'b mut self, new_value: CT16B0_mcr_mr1i) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `MR1R` field.
    #[inline(always)]
    pub fn set_mr1r<'b>(&'b mut self, new_value: CT16B0_mcr_mr1r) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `MR1S` field.
    #[inline(always)]
    pub fn set_mr1s<'b>(&'b mut self, new_value: CT16B0_mcr_mr1s) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `MR2I` field.
    #[inline(always)]
    pub fn set_mr2i<'b>(&'b mut self, new_value: CT16B0_mcr_mr2i) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `MR2R` field.
    #[inline(always)]
    pub fn set_mr2r<'b>(&'b mut self, new_value: CT16B0_mcr_mr2r) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `MR2S` field.
    #[inline(always)]
    pub fn set_mr2s<'b>(&'b mut self, new_value: CT16B0_mcr_mr2s) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `MR3I` field.
    #[inline(always)]
    pub fn set_mr3i<'b>(&'b mut self, new_value: CT16B0_mcr_mr3i) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `MR3R` field.
    #[inline(always)]
    pub fn set_mr3r<'b>(&'b mut self, new_value: CT16B0_mcr_mr3r) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `MR3S` field.
    #[inline(always)]
    pub fn set_mr3s<'b>(&'b mut self, new_value: CT16B0_mcr_mr3s) -> &'b mut CT16B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr0i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr0r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr0s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr1i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr1r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr1s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr2i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr2r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr2s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr3i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr3r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_mcr_mr3s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }







// Register MR0 implementation


/// Register `MR0`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_mr0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_mr0 { }

impl CT16B0_mr0 {
    
    // Getters
    /// Fetch the value of the `MR0` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_mr0_Get {
        CT16B0_mr0_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT16B0_mr0_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_mr0_Update {
        CT16B0_mr0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT16B0_mr0_Update<'a> {
        let mut setter: CT16B0_mr0_Update = CT16B0_mr0_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT16B0_mr0
/// `MR0`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_mr0_Get {
    value: u32,
}

impl CT16B0_mr0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_mr0) -> CT16B0_mr0_Get {
        CT16B0_mr0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_mr0_Get { }


// Updater for CT16B0_mr0
/// Updater for `MR0` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_mr0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_mr0,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_mr0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_mr0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_mr0) -> CT16B0_mr0_Update<'a> {
        CT16B0_mr0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_mr0) -> CT16B0_mr0_Update<'a> {
        CT16B0_mr0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT16B0_mr0_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MR1 implementation


/// Register `MR1`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_mr1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_mr1 { }

impl CT16B0_mr1 {
    
    // Getters
    /// Fetch the value of the `MR1` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_mr1_Get {
        CT16B0_mr1_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT16B0_mr1_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_mr1_Update {
        CT16B0_mr1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT16B0_mr1_Update<'a> {
        let mut setter: CT16B0_mr1_Update = CT16B0_mr1_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT16B0_mr1
/// `MR1`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_mr1_Get {
    value: u32,
}

impl CT16B0_mr1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_mr1) -> CT16B0_mr1_Get {
        CT16B0_mr1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_mr1_Get { }


// Updater for CT16B0_mr1
/// Updater for `MR1` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_mr1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_mr1,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_mr1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_mr1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_mr1) -> CT16B0_mr1_Update<'a> {
        CT16B0_mr1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_mr1) -> CT16B0_mr1_Update<'a> {
        CT16B0_mr1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT16B0_mr1_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MR2 implementation


/// Register `MR2`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_mr2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_mr2 { }

impl CT16B0_mr2 {
    
    // Getters
    /// Fetch the value of the `MR2` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_mr2_Get {
        CT16B0_mr2_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT16B0_mr2_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_mr2_Update {
        CT16B0_mr2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT16B0_mr2_Update<'a> {
        let mut setter: CT16B0_mr2_Update = CT16B0_mr2_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT16B0_mr2
/// `MR2`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_mr2_Get {
    value: u32,
}

impl CT16B0_mr2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_mr2) -> CT16B0_mr2_Get {
        CT16B0_mr2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_mr2_Get { }


// Updater for CT16B0_mr2
/// Updater for `MR2` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_mr2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_mr2,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_mr2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_mr2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_mr2) -> CT16B0_mr2_Update<'a> {
        CT16B0_mr2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_mr2) -> CT16B0_mr2_Update<'a> {
        CT16B0_mr2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT16B0_mr2_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MR3 implementation


/// Register `MR3`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_mr3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_mr3 { }

impl CT16B0_mr3 {
    
    // Getters
    /// Fetch the value of the `MR3` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_mr3_Get {
        CT16B0_mr3_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT16B0_mr3_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_mr3_Update {
        CT16B0_mr3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT16B0_mr3_Update<'a> {
        let mut setter: CT16B0_mr3_Update = CT16B0_mr3_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT16B0_mr3
/// `MR3`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_mr3_Get {
    value: u32,
}

impl CT16B0_mr3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_mr3) -> CT16B0_mr3_Get {
        CT16B0_mr3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_mr3_Get { }


// Updater for CT16B0_mr3
/// Updater for `MR3` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_mr3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_mr3,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_mr3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_mr3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_mr3) -> CT16B0_mr3_Update<'a> {
        CT16B0_mr3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_mr3) -> CT16B0_mr3_Update<'a> {
        CT16B0_mr3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT16B0_mr3_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CCR implementation


/// Register `CCR`: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_ccr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_ccr { }

impl CT16B0_ccr {
    
    // Getters
    /// Fetch the value of the `CCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_ccr_Get {
        CT16B0_ccr_Get::new(self)
    }

    
    /// Get value of `CAP0RE` field.
    #[inline(always)]
    pub fn cap0re(&self) -> CT16B0_ccr_cap0re {
        CT16B0_ccr_Get::new(self).cap0re()
    }
    
    /// Get value of `CAP0FE` field.
    #[inline(always)]
    pub fn cap0fe(&self) -> CT16B0_ccr_cap0fe {
        CT16B0_ccr_Get::new(self).cap0fe()
    }
    
    /// Get value of `CAP0I` field.
    #[inline(always)]
    pub fn cap0i(&self) -> CT16B0_ccr_cap0i {
        CT16B0_ccr_Get::new(self).cap0i()
    }
    
    /// Get value of `CAP1RE` field.
    #[inline(always)]
    pub fn cap1re(&self) -> CT16B0_ccr_cap1re {
        CT16B0_ccr_Get::new(self).cap1re()
    }
    
    /// Get value of `CAP1FE` field.
    #[inline(always)]
    pub fn cap1fe(&self) -> CT16B0_ccr_cap1fe {
        CT16B0_ccr_Get::new(self).cap1fe()
    }
    
    /// Get value of `CAP1I` field.
    #[inline(always)]
    pub fn cap1i(&self) -> CT16B0_ccr_cap1i {
        CT16B0_ccr_Get::new(self).cap1i()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_ccr_Update {
        CT16B0_ccr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CAP0RE` field.
    #[inline(always)]
    pub fn set_cap0re<'a>(&'a mut self, new_value: CT16B0_ccr_cap0re) -> CT16B0_ccr_Update<'a> {
        let mut setter: CT16B0_ccr_Update = CT16B0_ccr_Update::new(self);
        setter.set_cap0re(new_value);
        setter
    }
    
    /// Set value of `CAP0FE` field.
    #[inline(always)]
    pub fn set_cap0fe<'a>(&'a mut self, new_value: CT16B0_ccr_cap0fe) -> CT16B0_ccr_Update<'a> {
        let mut setter: CT16B0_ccr_Update = CT16B0_ccr_Update::new(self);
        setter.set_cap0fe(new_value);
        setter
    }
    
    /// Set value of `CAP0I` field.
    #[inline(always)]
    pub fn set_cap0i<'a>(&'a mut self, new_value: CT16B0_ccr_cap0i) -> CT16B0_ccr_Update<'a> {
        let mut setter: CT16B0_ccr_Update = CT16B0_ccr_Update::new(self);
        setter.set_cap0i(new_value);
        setter
    }
    
    /// Set value of `CAP1RE` field.
    #[inline(always)]
    pub fn set_cap1re<'a>(&'a mut self, new_value: CT16B0_ccr_cap1re) -> CT16B0_ccr_Update<'a> {
        let mut setter: CT16B0_ccr_Update = CT16B0_ccr_Update::new(self);
        setter.set_cap1re(new_value);
        setter
    }
    
    /// Set value of `CAP1FE` field.
    #[inline(always)]
    pub fn set_cap1fe<'a>(&'a mut self, new_value: CT16B0_ccr_cap1fe) -> CT16B0_ccr_Update<'a> {
        let mut setter: CT16B0_ccr_Update = CT16B0_ccr_Update::new(self);
        setter.set_cap1fe(new_value);
        setter
    }
    
    /// Set value of `CAP1I` field.
    #[inline(always)]
    pub fn set_cap1i<'a>(&'a mut self, new_value: CT16B0_ccr_cap1i) -> CT16B0_ccr_Update<'a> {
        let mut setter: CT16B0_ccr_Update = CT16B0_ccr_Update::new(self);
        setter.set_cap1i(new_value);
        setter
    }
    

    }


// Getter for CT16B0_ccr
/// `CCR`: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_ccr_Get {
    value: u32,
}

impl CT16B0_ccr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_ccr) -> CT16B0_ccr_Get {
        CT16B0_ccr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAP0RE` field: Capture on CT16Bn_CAP0 rising edge: a sequence of 0 then 1 on CT16Bn_CAP0 will cause CR0 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap0re(&self) -> CT16B0_ccr_cap0re {
        match (self.value >> 0) & 1 {
            1 => ::core::option::Option::Some(CT16B0_ccr_cap0re::Enabled),
            0 => ::core::option::Option::Some(CT16B0_ccr_cap0re::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP0FE` field: Capture on CT16Bn_CAP0 falling edge: a sequence of 1 then 0 on CT16Bn_CAP0 will cause CR0 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap0fe(&self) -> CT16B0_ccr_cap0fe {
        match (self.value >> 1) & 1 {
            1 => ::core::option::Option::Some(CT16B0_ccr_cap0fe::Enabled),
            0 => ::core::option::Option::Some(CT16B0_ccr_cap0fe::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP0I` field: Interrupt on CT16Bn_CAP0 event: a CR0 load due to a CT16Bn_CAP0 event will generate an interrupt.
    #[inline(always)]
    pub fn cap0i(&self) -> CT16B0_ccr_cap0i {
        match (self.value >> 2) & 1 {
            1 => ::core::option::Option::Some(CT16B0_ccr_cap0i::Enabled),
            0 => ::core::option::Option::Some(CT16B0_ccr_cap0i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP1RE` field: Capture on CT16Bn_CAP1 rising edge: a sequence of 0 then 1 on CT16Bn_CAP1 will cause CR1 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap1re(&self) -> CT16B0_ccr_cap1re {
        match (self.value >> 3) & 1 {
            1 => ::core::option::Option::Some(CT16B0_ccr_cap1re::Enabled),
            0 => ::core::option::Option::Some(CT16B0_ccr_cap1re::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP1FE` field: Capture on CT16Bn_CAP1 falling edge: a sequence of 1 then 0 on CT16Bn_CAP1 will cause CR1 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap1fe(&self) -> CT16B0_ccr_cap1fe {
        match (self.value >> 4) & 1 {
            1 => ::core::option::Option::Some(CT16B0_ccr_cap1fe::Enabled),
            0 => ::core::option::Option::Some(CT16B0_ccr_cap1fe::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP1I` field: Interrupt on CT16Bn_CAP1 event: a CR1 load due to a CT16Bn_CAP1 event will generate an interrupt.
    #[inline(always)]
    pub fn cap1i(&self) -> CT16B0_ccr_cap1i {
        match (self.value >> 5) & 1 {
            1 => ::core::option::Option::Some(CT16B0_ccr_cap1i::Enabled),
            0 => ::core::option::Option::Some(CT16B0_ccr_cap1i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT16B0_ccr_Get { }


// Updater for CT16B0_ccr
/// Updater for `CCR` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_ccr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_ccr,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_ccr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_ccr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_ccr) -> CT16B0_ccr_Update<'a> {
        CT16B0_ccr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_ccr) -> CT16B0_ccr_Update<'a> {
        CT16B0_ccr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CAP0RE` field.
    #[inline(always)]
    pub fn set_cap0re<'b>(&'b mut self, new_value: CT16B0_ccr_cap0re) -> &'b mut CT16B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `CAP0FE` field.
    #[inline(always)]
    pub fn set_cap0fe<'b>(&'b mut self, new_value: CT16B0_ccr_cap0fe) -> &'b mut CT16B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `CAP0I` field.
    #[inline(always)]
    pub fn set_cap0i<'b>(&'b mut self, new_value: CT16B0_ccr_cap0i) -> &'b mut CT16B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CAP1RE` field.
    #[inline(always)]
    pub fn set_cap1re<'b>(&'b mut self, new_value: CT16B0_ccr_cap1re) -> &'b mut CT16B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CAP1FE` field.
    #[inline(always)]
    pub fn set_cap1fe<'b>(&'b mut self, new_value: CT16B0_ccr_cap1fe) -> &'b mut CT16B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `CAP1I` field.
    #[inline(always)]
    pub fn set_cap1i<'b>(&'b mut self, new_value: CT16B0_ccr_cap1i) -> &'b mut CT16B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ccr_cap0re {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ccr_cap0fe {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ccr_cap0i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ccr_cap1re {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ccr_cap1fe {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ccr_cap1i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }







// Register CR0 implementation


/// Register `CR0`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_cr0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_cr0 { }

impl CT16B0_cr0 {
    
    // Getters
    /// Fetch the value of the `CR0` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_cr0_Get {
        CT16B0_cr0_Get::new(self)
    }

    
    /// Get value of `CAP` field.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        CT16B0_cr0_Get::new(self).cap()
    }
    

    }


// Getter for CT16B0_cr0
/// `CR0`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_cr0_Get {
    value: u32,
}

impl CT16B0_cr0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_cr0) -> CT16B0_cr0_Get {
        CT16B0_cr0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAP` field: Timer counter capture value.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_cr0_Get { }







// Register CR1 implementation


/// Register `CR1`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_cr1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_cr1 { }

impl CT16B0_cr1 {
    
    // Getters
    /// Fetch the value of the `CR1` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_cr1_Get {
        CT16B0_cr1_Get::new(self)
    }

    
    /// Get value of `CAP` field.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        CT16B0_cr1_Get::new(self).cap()
    }
    

    }


// Getter for CT16B0_cr1
/// `CR1`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_cr1_Get {
    value: u32,
}

impl CT16B0_cr1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_cr1) -> CT16B0_cr1_Get {
        CT16B0_cr1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAP` field: Timer counter capture value.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for CT16B0_cr1_Get { }







// Register EMR implementation


/// Register `EMR`: External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_emr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_emr { }

impl CT16B0_emr {
    
    // Getters
    /// Fetch the value of the `EMR` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_emr_Get {
        CT16B0_emr_Get::new(self)
    }

    
    /// Get value of `EM0` field.
    #[inline(always)]
    pub fn em0(&self) -> bool {
        CT16B0_emr_Get::new(self).em0()
    }
    
    /// Get value of `EM1` field.
    #[inline(always)]
    pub fn em1(&self) -> bool {
        CT16B0_emr_Get::new(self).em1()
    }
    
    /// Get value of `EM2` field.
    #[inline(always)]
    pub fn em2(&self) -> bool {
        CT16B0_emr_Get::new(self).em2()
    }
    
    /// Get value of `EM3` field.
    #[inline(always)]
    pub fn em3(&self) -> bool {
        CT16B0_emr_Get::new(self).em3()
    }
    
    /// Get value of `EMC0` field.
    #[inline(always)]
    pub fn emc0(&self) -> CT16B0_emr_emc0 {
        CT16B0_emr_Get::new(self).emc0()
    }
    
    /// Get value of `EMC1` field.
    #[inline(always)]
    pub fn emc1(&self) -> CT16B0_emr_emc1 {
        CT16B0_emr_Get::new(self).emc1()
    }
    
    /// Get value of `EMC2` field.
    #[inline(always)]
    pub fn emc2(&self) -> CT16B0_emr_emc2 {
        CT16B0_emr_Get::new(self).emc2()
    }
    
    /// Get value of `EMC3` field.
    #[inline(always)]
    pub fn emc3(&self) -> CT16B0_emr_emc3 {
        CT16B0_emr_Get::new(self).emc3()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `EMR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_emr_Update {
        CT16B0_emr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `EM0` field.
    #[inline(always)]
    pub fn set_em0<'a>(&'a mut self, new_value: bool) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_em0(new_value);
        setter
    }
    
    /// Set value of `EM1` field.
    #[inline(always)]
    pub fn set_em1<'a>(&'a mut self, new_value: bool) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_em1(new_value);
        setter
    }
    
    /// Set value of `EM2` field.
    #[inline(always)]
    pub fn set_em2<'a>(&'a mut self, new_value: bool) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_em2(new_value);
        setter
    }
    
    /// Set value of `EM3` field.
    #[inline(always)]
    pub fn set_em3<'a>(&'a mut self, new_value: bool) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_em3(new_value);
        setter
    }
    
    /// Set value of `EMC0` field.
    #[inline(always)]
    pub fn set_emc0<'a>(&'a mut self, new_value: CT16B0_emr_emc0) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_emc0(new_value);
        setter
    }
    
    /// Set value of `EMC1` field.
    #[inline(always)]
    pub fn set_emc1<'a>(&'a mut self, new_value: CT16B0_emr_emc1) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_emc1(new_value);
        setter
    }
    
    /// Set value of `EMC2` field.
    #[inline(always)]
    pub fn set_emc2<'a>(&'a mut self, new_value: CT16B0_emr_emc2) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_emc2(new_value);
        setter
    }
    
    /// Set value of `EMC3` field.
    #[inline(always)]
    pub fn set_emc3<'a>(&'a mut self, new_value: CT16B0_emr_emc3) -> CT16B0_emr_Update<'a> {
        let mut setter: CT16B0_emr_Update = CT16B0_emr_Update::new(self);
        setter.set_emc3(new_value);
        setter
    }
    

    }


// Getter for CT16B0_emr
/// `EMR`: External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_emr_Get {
    value: u32,
}

impl CT16B0_emr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_emr) -> CT16B0_emr_Get {
        CT16B0_emr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `EM0` field: External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).
    #[inline(always)]
    pub fn em0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `EM1` field: External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT16B0_MAT1/CT16B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).
    #[inline(always)]
    pub fn em1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `EM2` field: External Match 2. This bit reflects the state of output match channel 2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. Note that on counter/timer 0 this match channel is not pinned out. This bit is driven to the CT16B1_MAT2 pin if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).
    #[inline(always)]
    pub fn em2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `EM3` field: External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. There is no output pin available for this channel on either of the 16-bit timers.
    #[inline(always)]
    pub fn em3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `EMC0` field: External Match Control 0. Determines the functionality of External Match 0.
    #[inline(always)]
    pub fn emc0(&self) -> CT16B0_emr_emc0 {
        match (self.value >> 4) & 3 {
            0 => ::core::option::Option::Some(CT16B0_emr_emc0::DoNothing),
            1 => ::core::option::Option::Some(CT16B0_emr_emc0::ClearBit),
            2 => ::core::option::Option::Some(CT16B0_emr_emc0::SetBit),
            3 => ::core::option::Option::Some(CT16B0_emr_emc0::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EMC1` field: External Match Control 1. Determines the functionality of External Match 1.
    #[inline(always)]
    pub fn emc1(&self) -> CT16B0_emr_emc1 {
        match (self.value >> 6) & 3 {
            0 => ::core::option::Option::Some(CT16B0_emr_emc1::DoNothing),
            1 => ::core::option::Option::Some(CT16B0_emr_emc1::ClearBit),
            2 => ::core::option::Option::Some(CT16B0_emr_emc1::SetBit),
            3 => ::core::option::Option::Some(CT16B0_emr_emc1::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EMC2` field: External Match Control 2. Determines the functionality of External Match 2.
    #[inline(always)]
    pub fn emc2(&self) -> CT16B0_emr_emc2 {
        match (self.value >> 8) & 3 {
            0 => ::core::option::Option::Some(CT16B0_emr_emc2::DoNothing),
            1 => ::core::option::Option::Some(CT16B0_emr_emc2::ClearBit),
            2 => ::core::option::Option::Some(CT16B0_emr_emc2::SetBit),
            3 => ::core::option::Option::Some(CT16B0_emr_emc2::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EMC3` field: External Match Control 3. Determines the functionality of External Match 3.
    #[inline(always)]
    pub fn emc3(&self) -> CT16B0_emr_emc3 {
        match (self.value >> 10) & 3 {
            0 => ::core::option::Option::Some(CT16B0_emr_emc3::DoNothing),
            1 => ::core::option::Option::Some(CT16B0_emr_emc3::ClearBit),
            2 => ::core::option::Option::Some(CT16B0_emr_emc3::SetBit),
            3 => ::core::option::Option::Some(CT16B0_emr_emc3::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT16B0_emr_Get { }


// Updater for CT16B0_emr
/// Updater for `EMR` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_emr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_emr,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_emr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_emr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_emr) -> CT16B0_emr_Update<'a> {
        CT16B0_emr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_emr) -> CT16B0_emr_Update<'a> {
        CT16B0_emr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `EM0` field.
    #[inline(always)]
    pub fn set_em0<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `EM1` field.
    #[inline(always)]
    pub fn set_em1<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `EM2` field.
    #[inline(always)]
    pub fn set_em2<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `EM3` field.
    #[inline(always)]
    pub fn set_em3<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `EMC0` field.
    #[inline(always)]
    pub fn set_emc0<'b>(&'b mut self, new_value: CT16B0_emr_emc0) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 4))
                   | ((new_value as u32) & 3) << 4;
        self.mask |= 3 << 4;
        self
    }
    /// Set value of `EMC1` field.
    #[inline(always)]
    pub fn set_emc1<'b>(&'b mut self, new_value: CT16B0_emr_emc1) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 6))
                   | ((new_value as u32) & 3) << 6;
        self.mask |= 3 << 6;
        self
    }
    /// Set value of `EMC2` field.
    #[inline(always)]
    pub fn set_emc2<'b>(&'b mut self, new_value: CT16B0_emr_emc2) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 8))
                   | ((new_value as u32) & 3) << 8;
        self.mask |= 3 << 8;
        self
    }
    /// Set value of `EMC3` field.
    #[inline(always)]
    pub fn set_emc3<'b>(&'b mut self, new_value: CT16B0_emr_emc3) -> &'b mut CT16B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 10))
                   | ((new_value as u32) & 3) << 10;
        self.mask |= 3 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_emr_emc0 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_emr_emc1 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_emr_emc2 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_emr_emc3 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }







// Register CTCR implementation


/// Register `CTCR`: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_ctcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_ctcr { }

impl CT16B0_ctcr {
    
    // Getters
    /// Fetch the value of the `CTCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_ctcr_Get {
        CT16B0_ctcr_Get::new(self)
    }

    
    /// Get value of `CTM` field.
    #[inline(always)]
    pub fn ctm(&self) -> CT16B0_ctcr_ctm {
        CT16B0_ctcr_Get::new(self).ctm()
    }
    
    /// Get value of `CIS` field.
    #[inline(always)]
    pub fn cis(&self) -> CT16B0_ctcr_cis {
        CT16B0_ctcr_Get::new(self).cis()
    }
    
    /// Get value of `ENCC` field.
    #[inline(always)]
    pub fn encc(&self) -> bool {
        CT16B0_ctcr_Get::new(self).encc()
    }
    
    /// Get value of `SELCC` field.
    #[inline(always)]
    pub fn selcc(&self) -> CT16B0_ctcr_selcc {
        CT16B0_ctcr_Get::new(self).selcc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CTCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_ctcr_Update {
        CT16B0_ctcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CTM` field.
    #[inline(always)]
    pub fn set_ctm<'a>(&'a mut self, new_value: CT16B0_ctcr_ctm) -> CT16B0_ctcr_Update<'a> {
        let mut setter: CT16B0_ctcr_Update = CT16B0_ctcr_Update::new(self);
        setter.set_ctm(new_value);
        setter
    }
    
    /// Set value of `CIS` field.
    #[inline(always)]
    pub fn set_cis<'a>(&'a mut self, new_value: CT16B0_ctcr_cis) -> CT16B0_ctcr_Update<'a> {
        let mut setter: CT16B0_ctcr_Update = CT16B0_ctcr_Update::new(self);
        setter.set_cis(new_value);
        setter
    }
    
    /// Set value of `ENCC` field.
    #[inline(always)]
    pub fn set_encc<'a>(&'a mut self, new_value: bool) -> CT16B0_ctcr_Update<'a> {
        let mut setter: CT16B0_ctcr_Update = CT16B0_ctcr_Update::new(self);
        setter.set_encc(new_value);
        setter
    }
    
    /// Set value of `SELCC` field.
    #[inline(always)]
    pub fn set_selcc<'a>(&'a mut self, new_value: CT16B0_ctcr_selcc) -> CT16B0_ctcr_Update<'a> {
        let mut setter: CT16B0_ctcr_Update = CT16B0_ctcr_Update::new(self);
        setter.set_selcc(new_value);
        setter
    }
    

    }


// Getter for CT16B0_ctcr
/// `CTCR`: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_ctcr_Get {
    value: u32,
}

impl CT16B0_ctcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_ctcr) -> CT16B0_ctcr_Get {
        CT16B0_ctcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CTM` field: Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC).
    #[inline(always)]
    pub fn ctm(&self) -> CT16B0_ctcr_ctm {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(CT16B0_ctcr_ctm::EveryRisingPCLK),
            1 => ::core::option::Option::Some(CT16B0_ctcr_ctm::Rising),
            2 => ::core::option::Option::Some(CT16B0_ctcr_ctm::Falling),
            3 => ::core::option::Option::Some(CT16B0_ctcr_ctm::Both),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CIS` field: Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin is sampled for clocking.  Note: If Counter mode is selected in the CTCR register, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000.
    #[inline(always)]
    pub fn cis(&self) -> CT16B0_ctcr_cis {
        match (self.value >> 2) & 3 {
            0 => ::core::option::Option::Some(CT16B0_ctcr_cis::CT16BN_CAP0),
            1 => ::core::option::Option::Some(CT16B0_ctcr_cis::CT16BN_CAP1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ENCC` field: Setting this bit to one enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.
    #[inline(always)]
    pub fn encc(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `SELCC` field: When bit 4 is one, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is zero.
    #[inline(always)]
    pub fn selcc(&self) -> CT16B0_ctcr_selcc {
        match (self.value >> 5) & 7 {
            0 => ::core::option::Option::Some(CT16B0_ctcr_selcc::RisingCap0),
            1 => ::core::option::Option::Some(CT16B0_ctcr_selcc::FallingCap0),
            2 => ::core::option::Option::Some(CT16B0_ctcr_selcc::RisingCap1),
            3 => ::core::option::Option::Some(CT16B0_ctcr_selcc::FallingCap1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT16B0_ctcr_Get { }


// Updater for CT16B0_ctcr
/// Updater for `CTCR` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_ctcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_ctcr,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_ctcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_ctcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_ctcr) -> CT16B0_ctcr_Update<'a> {
        CT16B0_ctcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_ctcr) -> CT16B0_ctcr_Update<'a> {
        CT16B0_ctcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CTM` field.
    #[inline(always)]
    pub fn set_ctm<'b>(&'b mut self, new_value: CT16B0_ctcr_ctm) -> &'b mut CT16B0_ctcr_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Set value of `CIS` field.
    #[inline(always)]
    pub fn set_cis<'b>(&'b mut self, new_value: CT16B0_ctcr_cis) -> &'b mut CT16B0_ctcr_Update<'a> {
        self.value = (self.value & !(3 << 2))
                   | ((new_value as u32) & 3) << 2;
        self.mask |= 3 << 2;
        self
    }
    /// Set value of `ENCC` field.
    #[inline(always)]
    pub fn set_encc<'b>(&'b mut self, new_value: bool) -> &'b mut CT16B0_ctcr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `SELCC` field.
    #[inline(always)]
    pub fn set_selcc<'b>(&'b mut self, new_value: CT16B0_ctcr_selcc) -> &'b mut CT16B0_ctcr_Update<'a> {
        self.value = (self.value & !(7 << 5))
                   | ((new_value as u32) & 7) << 5;
        self.mask |= 7 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ctcr_ctm {
    /// Timer Mode: every rising PCLK edge
    EveryRisingPCLK = 0,
    /// Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2.
    Rising = 1,
    /// Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2.
    Falling = 2,
    /// Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2.
    Both = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ctcr_cis {
    /// CT16Bn_CAP0
    CT16BN_CAP0 = 0,
    /// CT16Bn_CAP1
    CT16BN_CAP1 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_ctcr_selcc {
    /// Rising Edge of CAP0 clears the timer (if bit 4 is set).
    RisingCap0 = 0,
    /// Falling Edge of CAP0 clears the timer (if bit 4 is set).
    FallingCap0 = 1,
    /// Rising Edge of CAP1 clears the timer (if bit 4 is set).
    RisingCap1 = 2,
    /// Falling Edge of CAP1 clears the timer (if bit 4 is set).
    FallingCap1 = 3,
    }







// Register PWMC implementation


/// Register `PWMC`: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT16B0_pwmc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT16B0_pwmc { }

impl CT16B0_pwmc {
    
    // Getters
    /// Fetch the value of the `PWMC` register.
    #[inline(always)]
    pub fn get(&self) -> CT16B0_pwmc_Get {
        CT16B0_pwmc_Get::new(self)
    }

    
    /// Get value of `PWMEN0` field.
    #[inline(always)]
    pub fn pwmen0(&self) -> CT16B0_pwmc_pwmen0 {
        CT16B0_pwmc_Get::new(self).pwmen0()
    }
    
    /// Get value of `PWMEN1` field.
    #[inline(always)]
    pub fn pwmen1(&self) -> CT16B0_pwmc_pwmen1 {
        CT16B0_pwmc_Get::new(self).pwmen1()
    }
    
    /// Get value of `PWMEN2` field.
    #[inline(always)]
    pub fn pwmen2(&self) -> CT16B0_pwmc_pwmen2 {
        CT16B0_pwmc_Get::new(self).pwmen2()
    }
    
    /// Get value of `PWMEN3` field.
    #[inline(always)]
    pub fn pwmen3(&self) -> CT16B0_pwmc_pwmen3 {
        CT16B0_pwmc_Get::new(self).pwmen3()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PWMC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT16B0_pwmc_Update {
        CT16B0_pwmc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `PWMEN0` field.
    #[inline(always)]
    pub fn set_pwmen0<'a>(&'a mut self, new_value: CT16B0_pwmc_pwmen0) -> CT16B0_pwmc_Update<'a> {
        let mut setter: CT16B0_pwmc_Update = CT16B0_pwmc_Update::new(self);
        setter.set_pwmen0(new_value);
        setter
    }
    
    /// Set value of `PWMEN1` field.
    #[inline(always)]
    pub fn set_pwmen1<'a>(&'a mut self, new_value: CT16B0_pwmc_pwmen1) -> CT16B0_pwmc_Update<'a> {
        let mut setter: CT16B0_pwmc_Update = CT16B0_pwmc_Update::new(self);
        setter.set_pwmen1(new_value);
        setter
    }
    
    /// Set value of `PWMEN2` field.
    #[inline(always)]
    pub fn set_pwmen2<'a>(&'a mut self, new_value: CT16B0_pwmc_pwmen2) -> CT16B0_pwmc_Update<'a> {
        let mut setter: CT16B0_pwmc_Update = CT16B0_pwmc_Update::new(self);
        setter.set_pwmen2(new_value);
        setter
    }
    
    /// Set value of `PWMEN3` field.
    #[inline(always)]
    pub fn set_pwmen3<'a>(&'a mut self, new_value: CT16B0_pwmc_pwmen3) -> CT16B0_pwmc_Update<'a> {
        let mut setter: CT16B0_pwmc_Update = CT16B0_pwmc_Update::new(self);
        setter.set_pwmen3(new_value);
        setter
    }
    

    }


// Getter for CT16B0_pwmc
/// `PWMC`: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT16B0_pwmc_Get {
    value: u32,
}

impl CT16B0_pwmc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT16B0_pwmc) -> CT16B0_pwmc_Get {
        CT16B0_pwmc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `PWMEN0` field: PWM channel0 enable
    #[inline(always)]
    pub fn pwmen0(&self) -> CT16B0_pwmc_pwmen0 {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(CT16B0_pwmc_pwmen0::ControlledByEM0),
            1 => ::core::option::Option::Some(CT16B0_pwmc_pwmen0::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PWMEN1` field: PWM channel1 enable
    #[inline(always)]
    pub fn pwmen1(&self) -> CT16B0_pwmc_pwmen1 {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(CT16B0_pwmc_pwmen1::ControlledByEM1),
            1 => ::core::option::Option::Some(CT16B0_pwmc_pwmen1::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PWMEN2` field: PWM channel2 enable
    #[inline(always)]
    pub fn pwmen2(&self) -> CT16B0_pwmc_pwmen2 {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(CT16B0_pwmc_pwmen2::ControlledByEM2),
            1 => ::core::option::Option::Some(CT16B0_pwmc_pwmen2::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PWMEN3` field: PWM channel3 enable Note: It is recommended to use match channel 3 to set the PWM cycle because it is not pinned out.
    #[inline(always)]
    pub fn pwmen3(&self) -> CT16B0_pwmc_pwmen3 {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(CT16B0_pwmc_pwmen3::ControlledByEM3),
            1 => ::core::option::Option::Some(CT16B0_pwmc_pwmen3::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT16B0_pwmc_Get { }


// Updater for CT16B0_pwmc
/// Updater for `PWMC` register.
#[allow(non_camel_case_types)]
pub struct CT16B0_pwmc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT16B0_pwmc,
}

/// This performs the register update.
impl <'a> Drop for CT16B0_pwmc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT16B0_pwmc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT16B0_pwmc) -> CT16B0_pwmc_Update<'a> {
        CT16B0_pwmc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT16B0_pwmc) -> CT16B0_pwmc_Update<'a> {
        CT16B0_pwmc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `PWMEN0` field.
    #[inline(always)]
    pub fn set_pwmen0<'b>(&'b mut self, new_value: CT16B0_pwmc_pwmen0) -> &'b mut CT16B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `PWMEN1` field.
    #[inline(always)]
    pub fn set_pwmen1<'b>(&'b mut self, new_value: CT16B0_pwmc_pwmen1) -> &'b mut CT16B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `PWMEN2` field.
    #[inline(always)]
    pub fn set_pwmen2<'b>(&'b mut self, new_value: CT16B0_pwmc_pwmen2) -> &'b mut CT16B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `PWMEN3` field.
    #[inline(always)]
    pub fn set_pwmen3<'b>(&'b mut self, new_value: CT16B0_pwmc_pwmen3) -> &'b mut CT16B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_pwmc_pwmen0 {
    /// CT16Bn_MAT0 is controlled by EM0.
    ControlledByEM0 = 0,
    /// PWM mode is enabled for CT16Bn_MAT0.
    PWMIsEnabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_pwmc_pwmen1 {
    /// CT16Bn_MAT1 is controlled by EM1.
    ControlledByEM1 = 0,
    /// PWM mode is enabled for CT16Bn_MAT1.
    PWMIsEnabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_pwmc_pwmen2 {
    /// Match channel 2 or pin CT16B0_MAT2 is controlled by EM2. Match channel 2 is not pinned out on timer 1.
    ControlledByEM2 = 0,
    /// PWM mode is enabled for match channel 2 or pin CT16B0_MAT2.
    PWMIsEnabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT16B0_pwmc_pwmen3 {
    /// Match channel 3 match channel 3 is controlled by EM3.
    ControlledByEM3 = 0,
    /// PWM mode is enabled for match channel 3match channel 3.
    PWMIsEnabled = 1,
    }





// Peripheral CT16B0 implementation

/// Product name title=UM10398 Chapter title=LPC1100XL series: 16-bit counter/timer CT16B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct CT16B0;

impl CT16B0 {
    /// Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
    #[inline(always)]
    pub fn ir() -> &'static mut CT16B0_ir {
        unsafe { ::core::intrinsics::transmute(0x4000c000 as usize) }
    }
    /// Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    #[inline(always)]
    pub fn tcr() -> &'static mut CT16B0_tcr {
        unsafe { ::core::intrinsics::transmute(0x4000c004 as usize) }
    }
    /// Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    #[inline(always)]
    pub fn tc() -> &'static mut CT16B0_tc {
        unsafe { ::core::intrinsics::transmute(0x4000c008 as usize) }
    }
    /// Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
    #[inline(always)]
    pub fn pr() -> &'static mut CT16B0_pr {
        unsafe { ::core::intrinsics::transmute(0x4000c00c as usize) }
    }
    /// Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    #[inline(always)]
    pub fn pc() -> &'static mut CT16B0_pc {
        unsafe { ::core::intrinsics::transmute(0x4000c010 as usize) }
    }
    /// Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    #[inline(always)]
    pub fn mcr() -> &'static mut CT16B0_mcr {
        unsafe { ::core::intrinsics::transmute(0x4000c014 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr0() -> &'static mut CT16B0_mr0 {
        unsafe { ::core::intrinsics::transmute(0x4000c018 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr1() -> &'static mut CT16B0_mr1 {
        unsafe { ::core::intrinsics::transmute(0x4000c01c as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr2() -> &'static mut CT16B0_mr2 {
        unsafe { ::core::intrinsics::transmute(0x4000c020 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr3() -> &'static mut CT16B0_mr3 {
        unsafe { ::core::intrinsics::transmute(0x4000c024 as usize) }
    }
    /// Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    #[inline(always)]
    pub fn ccr() -> &'static mut CT16B0_ccr {
        unsafe { ::core::intrinsics::transmute(0x4000c028 as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr0() -> &'static mut CT16B0_cr0 {
        unsafe { ::core::intrinsics::transmute(0x4000c02c as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr1() -> &'static mut CT16B0_cr1 {
        unsafe { ::core::intrinsics::transmute(0x4000c030 as usize) }
    }
    /// External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0].
    #[inline(always)]
    pub fn emr() -> &'static mut CT16B0_emr {
        unsafe { ::core::intrinsics::transmute(0x4000c03c as usize) }
    }
    /// Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    #[inline(always)]
    pub fn ctcr() -> &'static mut CT16B0_ctcr {
        unsafe { ::core::intrinsics::transmute(0x4000c070 as usize) }
    }
    /// PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0].
    #[inline(always)]
    pub fn pwmc() -> &'static mut CT16B0_pwmc {
        unsafe { ::core::intrinsics::transmute(0x4000c074 as usize) }
    }
    }



// Registers for CT16B1



































// Peripheral CT16B1 implementation

/// LPC11xx, LPC11Cxx, LPC11xxL, LPC11xxXL
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct CT16B1;

impl CT16B1 {
    /// Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
    #[inline(always)]
    pub fn ir() -> &'static mut CT16B0_ir {
        unsafe { ::core::intrinsics::transmute(0x40010000 as usize) }
    }
    /// Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    #[inline(always)]
    pub fn tcr() -> &'static mut CT16B0_tcr {
        unsafe { ::core::intrinsics::transmute(0x40010004 as usize) }
    }
    /// Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    #[inline(always)]
    pub fn tc() -> &'static mut CT16B0_tc {
        unsafe { ::core::intrinsics::transmute(0x40010008 as usize) }
    }
    /// Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
    #[inline(always)]
    pub fn pr() -> &'static mut CT16B0_pr {
        unsafe { ::core::intrinsics::transmute(0x4001000c as usize) }
    }
    /// Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    #[inline(always)]
    pub fn pc() -> &'static mut CT16B0_pc {
        unsafe { ::core::intrinsics::transmute(0x40010010 as usize) }
    }
    /// Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    #[inline(always)]
    pub fn mcr() -> &'static mut CT16B0_mcr {
        unsafe { ::core::intrinsics::transmute(0x40010014 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr0() -> &'static mut CT16B0_mr0 {
        unsafe { ::core::intrinsics::transmute(0x40010018 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr1() -> &'static mut CT16B0_mr1 {
        unsafe { ::core::intrinsics::transmute(0x4001001c as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr2() -> &'static mut CT16B0_mr2 {
        unsafe { ::core::intrinsics::transmute(0x40010020 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr3() -> &'static mut CT16B0_mr3 {
        unsafe { ::core::intrinsics::transmute(0x40010024 as usize) }
    }
    /// Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    #[inline(always)]
    pub fn ccr() -> &'static mut CT16B0_ccr {
        unsafe { ::core::intrinsics::transmute(0x40010028 as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr0() -> &'static mut CT16B0_cr0 {
        unsafe { ::core::intrinsics::transmute(0x4001002c as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr1() -> &'static mut CT16B0_cr1 {
        unsafe { ::core::intrinsics::transmute(0x40010030 as usize) }
    }
    /// External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0].
    #[inline(always)]
    pub fn emr() -> &'static mut CT16B0_emr {
        unsafe { ::core::intrinsics::transmute(0x4001003c as usize) }
    }
    /// Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    #[inline(always)]
    pub fn ctcr() -> &'static mut CT16B0_ctcr {
        unsafe { ::core::intrinsics::transmute(0x40010070 as usize) }
    }
    /// PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0].
    #[inline(always)]
    pub fn pwmc() -> &'static mut CT16B0_pwmc {
        unsafe { ::core::intrinsics::transmute(0x40010074 as usize) }
    }
    }



// Registers for CT32B0





// Register IR implementation


/// Register `IR`: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_ir {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_ir { }

impl CT32B0_ir {
    
    // Getters
    /// Fetch the value of the `IR` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_ir_Get {
        CT32B0_ir_Get::new(self)
    }

    
    /// Get value of `MR0INT` field.
    #[inline(always)]
    pub fn mr0int(&self) -> bool {
        CT32B0_ir_Get::new(self).mr0int()
    }
    
    /// Get value of `MR1INT` field.
    #[inline(always)]
    pub fn mr1int(&self) -> bool {
        CT32B0_ir_Get::new(self).mr1int()
    }
    
    /// Get value of `MR2INT` field.
    #[inline(always)]
    pub fn mr2int(&self) -> bool {
        CT32B0_ir_Get::new(self).mr2int()
    }
    
    /// Get value of `MR3INT` field.
    #[inline(always)]
    pub fn mr3int(&self) -> bool {
        CT32B0_ir_Get::new(self).mr3int()
    }
    
    /// Get value of `CR0INT` field.
    #[inline(always)]
    pub fn cr0int(&self) -> bool {
        CT32B0_ir_Get::new(self).cr0int()
    }
    
    /// Get value of `CR1INT` field.
    #[inline(always)]
    pub fn cr1int(&self) -> bool {
        CT32B0_ir_Get::new(self).cr1int()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_ir_Update {
        CT32B0_ir_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MR0INT` field.
    #[inline(always)]
    pub fn set_mr0int<'a>(&'a mut self, new_value: bool) -> CT32B0_ir_Update<'a> {
        let mut setter: CT32B0_ir_Update = CT32B0_ir_Update::new(self);
        setter.set_mr0int(new_value);
        setter
    }
    
    /// Set value of `MR1INT` field.
    #[inline(always)]
    pub fn set_mr1int<'a>(&'a mut self, new_value: bool) -> CT32B0_ir_Update<'a> {
        let mut setter: CT32B0_ir_Update = CT32B0_ir_Update::new(self);
        setter.set_mr1int(new_value);
        setter
    }
    
    /// Set value of `MR2INT` field.
    #[inline(always)]
    pub fn set_mr2int<'a>(&'a mut self, new_value: bool) -> CT32B0_ir_Update<'a> {
        let mut setter: CT32B0_ir_Update = CT32B0_ir_Update::new(self);
        setter.set_mr2int(new_value);
        setter
    }
    
    /// Set value of `MR3INT` field.
    #[inline(always)]
    pub fn set_mr3int<'a>(&'a mut self, new_value: bool) -> CT32B0_ir_Update<'a> {
        let mut setter: CT32B0_ir_Update = CT32B0_ir_Update::new(self);
        setter.set_mr3int(new_value);
        setter
    }
    
    /// Set value of `CR0INT` field.
    #[inline(always)]
    pub fn set_cr0int<'a>(&'a mut self, new_value: bool) -> CT32B0_ir_Update<'a> {
        let mut setter: CT32B0_ir_Update = CT32B0_ir_Update::new(self);
        setter.set_cr0int(new_value);
        setter
    }
    
    /// Set value of `CR1INT` field.
    #[inline(always)]
    pub fn set_cr1int<'a>(&'a mut self, new_value: bool) -> CT32B0_ir_Update<'a> {
        let mut setter: CT32B0_ir_Update = CT32B0_ir_Update::new(self);
        setter.set_cr1int(new_value);
        setter
    }
    

    }


// Getter for CT32B0_ir
/// `IR`: Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_ir_Get {
    value: u32,
}

impl CT32B0_ir_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_ir) -> CT32B0_ir_Get {
        CT32B0_ir_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MR0INT` field: Interrupt flag for match channel 0.
    #[inline(always)]
    pub fn mr0int(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `MR1INT` field: Interrupt flag for match channel 1.
    #[inline(always)]
    pub fn mr1int(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `MR2INT` field: Interrupt flag for match channel 2.
    #[inline(always)]
    pub fn mr2int(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `MR3INT` field: Interrupt flag for match channel 3.
    #[inline(always)]
    pub fn mr3int(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `CR0INT` field: Interrupt flag for capture channel 0 event.
    #[inline(always)]
    pub fn cr0int(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `CR1INT` field: Interrupt flag for capture channel 1 event.
    #[inline(always)]
    pub fn cr1int(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    }

impl ::core::marker::Copy for CT32B0_ir_Get { }


// Updater for CT32B0_ir
/// Updater for `IR` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_ir_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_ir,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_ir_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_ir_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_ir) -> CT32B0_ir_Update<'a> {
        CT32B0_ir_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_ir) -> CT32B0_ir_Update<'a> {
        CT32B0_ir_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MR0INT` field.
    #[inline(always)]
    pub fn set_mr0int<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `MR1INT` field.
    #[inline(always)]
    pub fn set_mr1int<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `MR2INT` field.
    #[inline(always)]
    pub fn set_mr2int<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `MR3INT` field.
    #[inline(always)]
    pub fn set_mr3int<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CR0INT` field.
    #[inline(always)]
    pub fn set_cr0int<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `CR1INT` field.
    #[inline(always)]
    pub fn set_cr1int<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_ir_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register TCR implementation


/// Register `TCR`: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_tcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_tcr { }

impl CT32B0_tcr {
    
    // Getters
    /// Fetch the value of the `TCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_tcr_Get {
        CT32B0_tcr_Get::new(self)
    }

    
    /// Get value of `CEN` field.
    #[inline(always)]
    pub fn cen(&self) -> bool {
        CT32B0_tcr_Get::new(self).cen()
    }
    
    /// Get value of `CRST` field.
    #[inline(always)]
    pub fn crst(&self) -> bool {
        CT32B0_tcr_Get::new(self).crst()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `TCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_tcr_Update {
        CT32B0_tcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CEN` field.
    #[inline(always)]
    pub fn set_cen<'a>(&'a mut self, new_value: bool) -> CT32B0_tcr_Update<'a> {
        let mut setter: CT32B0_tcr_Update = CT32B0_tcr_Update::new(self);
        setter.set_cen(new_value);
        setter
    }
    
    /// Set value of `CRST` field.
    #[inline(always)]
    pub fn set_crst<'a>(&'a mut self, new_value: bool) -> CT32B0_tcr_Update<'a> {
        let mut setter: CT32B0_tcr_Update = CT32B0_tcr_Update::new(self);
        setter.set_crst(new_value);
        setter
    }
    

    }


// Getter for CT32B0_tcr
/// `TCR`: Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_tcr_Get {
    value: u32,
}

impl CT32B0_tcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_tcr) -> CT32B0_tcr_Get {
        CT32B0_tcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CEN` field: When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled.
    #[inline(always)]
    pub fn cen(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `CRST` field: When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero.
    #[inline(always)]
    pub fn crst(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    }

impl ::core::marker::Copy for CT32B0_tcr_Get { }


// Updater for CT32B0_tcr
/// Updater for `TCR` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_tcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_tcr,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_tcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_tcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_tcr) -> CT32B0_tcr_Update<'a> {
        CT32B0_tcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_tcr) -> CT32B0_tcr_Update<'a> {
        CT32B0_tcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CEN` field.
    #[inline(always)]
    pub fn set_cen<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_tcr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `CRST` field.
    #[inline(always)]
    pub fn set_crst<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_tcr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register TC implementation


/// Register `TC`: Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_tc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_tc { }

impl CT32B0_tc {
    
    // Getters
    /// Fetch the value of the `TC` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_tc_Get {
        CT32B0_tc_Get::new(self)
    }

    
    /// Get value of `TC` field.
    #[inline(always)]
    pub fn tc(&self) -> u32 {
        CT32B0_tc_Get::new(self).tc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `TC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_tc_Update {
        CT32B0_tc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `TC` field.
    #[inline(always)]
    pub fn set_tc<'a>(&'a mut self, new_value: u32) -> CT32B0_tc_Update<'a> {
        let mut setter: CT32B0_tc_Update = CT32B0_tc_Update::new(self);
        setter.set_tc(new_value);
        setter
    }
    

    }


// Getter for CT32B0_tc
/// `TC`: Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_tc_Get {
    value: u32,
}

impl CT32B0_tc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_tc) -> CT32B0_tc_Get {
        CT32B0_tc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TC` field: Timer counter value.
    #[inline(always)]
    pub fn tc(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_tc_Get { }


// Updater for CT32B0_tc
/// Updater for `TC` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_tc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_tc,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_tc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_tc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_tc) -> CT32B0_tc_Update<'a> {
        CT32B0_tc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_tc) -> CT32B0_tc_Update<'a> {
        CT32B0_tc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `TC` field.
    #[inline(always)]
    pub fn set_tc<'b>(&'b mut self, new_value: u32) -> &'b mut CT32B0_tc_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register PR implementation


/// Register `PR`: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_pr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_pr { }

impl CT32B0_pr {
    
    // Getters
    /// Fetch the value of the `PR` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_pr_Get {
        CT32B0_pr_Get::new(self)
    }

    
    /// Get value of `PR` field.
    #[inline(always)]
    pub fn pr(&self) -> u32 {
        CT32B0_pr_Get::new(self).pr()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_pr_Update {
        CT32B0_pr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `PR` field.
    #[inline(always)]
    pub fn set_pr<'a>(&'a mut self, new_value: u32) -> CT32B0_pr_Update<'a> {
        let mut setter: CT32B0_pr_Update = CT32B0_pr_Update::new(self);
        setter.set_pr(new_value);
        setter
    }
    

    }


// Getter for CT32B0_pr
/// `PR`: Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_pr_Get {
    value: u32,
}

impl CT32B0_pr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_pr) -> CT32B0_pr_Get {
        CT32B0_pr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `PR` field: Prescale value.
    #[inline(always)]
    pub fn pr(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_pr_Get { }


// Updater for CT32B0_pr
/// Updater for `PR` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_pr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_pr,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_pr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_pr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_pr) -> CT32B0_pr_Update<'a> {
        CT32B0_pr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_pr) -> CT32B0_pr_Update<'a> {
        CT32B0_pr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `PR` field.
    #[inline(always)]
    pub fn set_pr<'b>(&'b mut self, new_value: u32) -> &'b mut CT32B0_pr_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register PC implementation


/// Register `PC`: Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_pc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_pc { }

impl CT32B0_pc {
    
    // Getters
    /// Fetch the value of the `PC` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_pc_Get {
        CT32B0_pc_Get::new(self)
    }

    
    /// Get value of `PC` field.
    #[inline(always)]
    pub fn pc(&self) -> u32 {
        CT32B0_pc_Get::new(self).pc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_pc_Update {
        CT32B0_pc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `PC` field.
    #[inline(always)]
    pub fn set_pc<'a>(&'a mut self, new_value: u32) -> CT32B0_pc_Update<'a> {
        let mut setter: CT32B0_pc_Update = CT32B0_pc_Update::new(self);
        setter.set_pc(new_value);
        setter
    }
    

    }


// Getter for CT32B0_pc
/// `PC`: Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_pc_Get {
    value: u32,
}

impl CT32B0_pc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_pc) -> CT32B0_pc_Get {
        CT32B0_pc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `PC` field: Prescale counter value.
    #[inline(always)]
    pub fn pc(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_pc_Get { }


// Updater for CT32B0_pc
/// Updater for `PC` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_pc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_pc,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_pc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_pc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_pc) -> CT32B0_pc_Update<'a> {
        CT32B0_pc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_pc) -> CT32B0_pc_Update<'a> {
        CT32B0_pc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `PC` field.
    #[inline(always)]
    pub fn set_pc<'b>(&'b mut self, new_value: u32) -> &'b mut CT32B0_pc_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MCR implementation


/// Register `MCR`: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_mcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_mcr { }

impl CT32B0_mcr {
    
    // Getters
    /// Fetch the value of the `MCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_mcr_Get {
        CT32B0_mcr_Get::new(self)
    }

    
    /// Get value of `MR0I` field.
    #[inline(always)]
    pub fn mr0i(&self) -> CT32B0_mcr_mr0i {
        CT32B0_mcr_Get::new(self).mr0i()
    }
    
    /// Get value of `MR0R` field.
    #[inline(always)]
    pub fn mr0r(&self) -> CT32B0_mcr_mr0r {
        CT32B0_mcr_Get::new(self).mr0r()
    }
    
    /// Get value of `MR0S` field.
    #[inline(always)]
    pub fn mr0s(&self) -> CT32B0_mcr_mr0s {
        CT32B0_mcr_Get::new(self).mr0s()
    }
    
    /// Get value of `MR1I` field.
    #[inline(always)]
    pub fn mr1i(&self) -> CT32B0_mcr_mr1i {
        CT32B0_mcr_Get::new(self).mr1i()
    }
    
    /// Get value of `MR1R` field.
    #[inline(always)]
    pub fn mr1r(&self) -> CT32B0_mcr_mr1r {
        CT32B0_mcr_Get::new(self).mr1r()
    }
    
    /// Get value of `MR1S` field.
    #[inline(always)]
    pub fn mr1s(&self) -> CT32B0_mcr_mr1s {
        CT32B0_mcr_Get::new(self).mr1s()
    }
    
    /// Get value of `MR2I` field.
    #[inline(always)]
    pub fn mr2i(&self) -> CT32B0_mcr_mr2i {
        CT32B0_mcr_Get::new(self).mr2i()
    }
    
    /// Get value of `MR2R` field.
    #[inline(always)]
    pub fn mr2r(&self) -> CT32B0_mcr_mr2r {
        CT32B0_mcr_Get::new(self).mr2r()
    }
    
    /// Get value of `MR2S` field.
    #[inline(always)]
    pub fn mr2s(&self) -> CT32B0_mcr_mr2s {
        CT32B0_mcr_Get::new(self).mr2s()
    }
    
    /// Get value of `MR3I` field.
    #[inline(always)]
    pub fn mr3i(&self) -> CT32B0_mcr_mr3i {
        CT32B0_mcr_Get::new(self).mr3i()
    }
    
    /// Get value of `MR3R` field.
    #[inline(always)]
    pub fn mr3r(&self) -> CT32B0_mcr_mr3r {
        CT32B0_mcr_Get::new(self).mr3r()
    }
    
    /// Get value of `MR3S` field.
    #[inline(always)]
    pub fn mr3s(&self) -> CT32B0_mcr_mr3s {
        CT32B0_mcr_Get::new(self).mr3s()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_mcr_Update {
        CT32B0_mcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MR0I` field.
    #[inline(always)]
    pub fn set_mr0i<'a>(&'a mut self, new_value: CT32B0_mcr_mr0i) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr0i(new_value);
        setter
    }
    
    /// Set value of `MR0R` field.
    #[inline(always)]
    pub fn set_mr0r<'a>(&'a mut self, new_value: CT32B0_mcr_mr0r) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr0r(new_value);
        setter
    }
    
    /// Set value of `MR0S` field.
    #[inline(always)]
    pub fn set_mr0s<'a>(&'a mut self, new_value: CT32B0_mcr_mr0s) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr0s(new_value);
        setter
    }
    
    /// Set value of `MR1I` field.
    #[inline(always)]
    pub fn set_mr1i<'a>(&'a mut self, new_value: CT32B0_mcr_mr1i) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr1i(new_value);
        setter
    }
    
    /// Set value of `MR1R` field.
    #[inline(always)]
    pub fn set_mr1r<'a>(&'a mut self, new_value: CT32B0_mcr_mr1r) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr1r(new_value);
        setter
    }
    
    /// Set value of `MR1S` field.
    #[inline(always)]
    pub fn set_mr1s<'a>(&'a mut self, new_value: CT32B0_mcr_mr1s) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr1s(new_value);
        setter
    }
    
    /// Set value of `MR2I` field.
    #[inline(always)]
    pub fn set_mr2i<'a>(&'a mut self, new_value: CT32B0_mcr_mr2i) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr2i(new_value);
        setter
    }
    
    /// Set value of `MR2R` field.
    #[inline(always)]
    pub fn set_mr2r<'a>(&'a mut self, new_value: CT32B0_mcr_mr2r) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr2r(new_value);
        setter
    }
    
    /// Set value of `MR2S` field.
    #[inline(always)]
    pub fn set_mr2s<'a>(&'a mut self, new_value: CT32B0_mcr_mr2s) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr2s(new_value);
        setter
    }
    
    /// Set value of `MR3I` field.
    #[inline(always)]
    pub fn set_mr3i<'a>(&'a mut self, new_value: CT32B0_mcr_mr3i) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr3i(new_value);
        setter
    }
    
    /// Set value of `MR3R` field.
    #[inline(always)]
    pub fn set_mr3r<'a>(&'a mut self, new_value: CT32B0_mcr_mr3r) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr3r(new_value);
        setter
    }
    
    /// Set value of `MR3S` field.
    #[inline(always)]
    pub fn set_mr3s<'a>(&'a mut self, new_value: CT32B0_mcr_mr3s) -> CT32B0_mcr_Update<'a> {
        let mut setter: CT32B0_mcr_Update = CT32B0_mcr_Update::new(self);
        setter.set_mr3s(new_value);
        setter
    }
    

    }


// Getter for CT32B0_mcr
/// `MCR`: Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_mcr_Get {
    value: u32,
}

impl CT32B0_mcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_mcr) -> CT32B0_mcr_Get {
        CT32B0_mcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MR0I` field: Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC.
    #[inline(always)]
    pub fn mr0i(&self) -> CT32B0_mcr_mr0i {
        match (self.value >> 0) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr0i::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr0i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR0R` field: Reset on MR0: the TC will be reset if MR0 matches it.
    #[inline(always)]
    pub fn mr0r(&self) -> CT32B0_mcr_mr0r {
        match (self.value >> 1) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr0r::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr0r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR0S` field: Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC.
    #[inline(always)]
    pub fn mr0s(&self) -> CT32B0_mcr_mr0s {
        match (self.value >> 2) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr0s::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr0s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR1I` field: Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC.
    #[inline(always)]
    pub fn mr1i(&self) -> CT32B0_mcr_mr1i {
        match (self.value >> 3) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr1i::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr1i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR1R` field: Reset on MR1: the TC will be reset if MR1 matches it.
    #[inline(always)]
    pub fn mr1r(&self) -> CT32B0_mcr_mr1r {
        match (self.value >> 4) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr1r::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr1r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR1S` field: Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC.
    #[inline(always)]
    pub fn mr1s(&self) -> CT32B0_mcr_mr1s {
        match (self.value >> 5) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr1s::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr1s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR2I` field: Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC.
    #[inline(always)]
    pub fn mr2i(&self) -> CT32B0_mcr_mr2i {
        match (self.value >> 6) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr2i::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr2i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR2R` field: Reset on MR2: the TC will be reset if MR2 matches it.
    #[inline(always)]
    pub fn mr2r(&self) -> CT32B0_mcr_mr2r {
        match (self.value >> 7) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr2r::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr2r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR2S` field: Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC.
    #[inline(always)]
    pub fn mr2s(&self) -> CT32B0_mcr_mr2s {
        match (self.value >> 8) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr2s::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr2s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR3I` field: Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC.
    #[inline(always)]
    pub fn mr3i(&self) -> CT32B0_mcr_mr3i {
        match (self.value >> 9) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr3i::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr3i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR3R` field: Reset on MR3: the TC will be reset if MR3 matches it.
    #[inline(always)]
    pub fn mr3r(&self) -> CT32B0_mcr_mr3r {
        match (self.value >> 10) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr3r::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr3r::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MR3S` field: Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC.
    #[inline(always)]
    pub fn mr3s(&self) -> CT32B0_mcr_mr3s {
        match (self.value >> 11) & 1 {
            1 => ::core::option::Option::Some(CT32B0_mcr_mr3s::Enabled),
            0 => ::core::option::Option::Some(CT32B0_mcr_mr3s::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT32B0_mcr_Get { }


// Updater for CT32B0_mcr
/// Updater for `MCR` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_mcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_mcr,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_mcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_mcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_mcr) -> CT32B0_mcr_Update<'a> {
        CT32B0_mcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_mcr) -> CT32B0_mcr_Update<'a> {
        CT32B0_mcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MR0I` field.
    #[inline(always)]
    pub fn set_mr0i<'b>(&'b mut self, new_value: CT32B0_mcr_mr0i) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `MR0R` field.
    #[inline(always)]
    pub fn set_mr0r<'b>(&'b mut self, new_value: CT32B0_mcr_mr0r) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `MR0S` field.
    #[inline(always)]
    pub fn set_mr0s<'b>(&'b mut self, new_value: CT32B0_mcr_mr0s) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `MR1I` field.
    #[inline(always)]
    pub fn set_mr1i<'b>(&'b mut self, new_value: CT32B0_mcr_mr1i) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `MR1R` field.
    #[inline(always)]
    pub fn set_mr1r<'b>(&'b mut self, new_value: CT32B0_mcr_mr1r) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `MR1S` field.
    #[inline(always)]
    pub fn set_mr1s<'b>(&'b mut self, new_value: CT32B0_mcr_mr1s) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `MR2I` field.
    #[inline(always)]
    pub fn set_mr2i<'b>(&'b mut self, new_value: CT32B0_mcr_mr2i) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `MR2R` field.
    #[inline(always)]
    pub fn set_mr2r<'b>(&'b mut self, new_value: CT32B0_mcr_mr2r) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `MR2S` field.
    #[inline(always)]
    pub fn set_mr2s<'b>(&'b mut self, new_value: CT32B0_mcr_mr2s) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `MR3I` field.
    #[inline(always)]
    pub fn set_mr3i<'b>(&'b mut self, new_value: CT32B0_mcr_mr3i) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `MR3R` field.
    #[inline(always)]
    pub fn set_mr3r<'b>(&'b mut self, new_value: CT32B0_mcr_mr3r) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `MR3S` field.
    #[inline(always)]
    pub fn set_mr3s<'b>(&'b mut self, new_value: CT32B0_mcr_mr3s) -> &'b mut CT32B0_mcr_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr0i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr0r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr0s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr1i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr1r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr1s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr2i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr2r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr2s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr3i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr3r {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_mcr_mr3s {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }







// Register MR0 implementation


/// Register `MR0`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_mr0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_mr0 { }

impl CT32B0_mr0 {
    
    // Getters
    /// Fetch the value of the `MR0` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_mr0_Get {
        CT32B0_mr0_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT32B0_mr0_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_mr0_Update {
        CT32B0_mr0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT32B0_mr0_Update<'a> {
        let mut setter: CT32B0_mr0_Update = CT32B0_mr0_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT32B0_mr0
/// `MR0`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_mr0_Get {
    value: u32,
}

impl CT32B0_mr0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_mr0) -> CT32B0_mr0_Get {
        CT32B0_mr0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_mr0_Get { }


// Updater for CT32B0_mr0
/// Updater for `MR0` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_mr0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_mr0,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_mr0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_mr0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_mr0) -> CT32B0_mr0_Update<'a> {
        CT32B0_mr0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_mr0) -> CT32B0_mr0_Update<'a> {
        CT32B0_mr0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT32B0_mr0_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MR1 implementation


/// Register `MR1`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_mr1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_mr1 { }

impl CT32B0_mr1 {
    
    // Getters
    /// Fetch the value of the `MR1` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_mr1_Get {
        CT32B0_mr1_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT32B0_mr1_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_mr1_Update {
        CT32B0_mr1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT32B0_mr1_Update<'a> {
        let mut setter: CT32B0_mr1_Update = CT32B0_mr1_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT32B0_mr1
/// `MR1`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_mr1_Get {
    value: u32,
}

impl CT32B0_mr1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_mr1) -> CT32B0_mr1_Get {
        CT32B0_mr1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_mr1_Get { }


// Updater for CT32B0_mr1
/// Updater for `MR1` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_mr1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_mr1,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_mr1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_mr1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_mr1) -> CT32B0_mr1_Update<'a> {
        CT32B0_mr1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_mr1) -> CT32B0_mr1_Update<'a> {
        CT32B0_mr1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT32B0_mr1_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MR2 implementation


/// Register `MR2`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_mr2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_mr2 { }

impl CT32B0_mr2 {
    
    // Getters
    /// Fetch the value of the `MR2` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_mr2_Get {
        CT32B0_mr2_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT32B0_mr2_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_mr2_Update {
        CT32B0_mr2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT32B0_mr2_Update<'a> {
        let mut setter: CT32B0_mr2_Update = CT32B0_mr2_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT32B0_mr2
/// `MR2`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_mr2_Get {
    value: u32,
}

impl CT32B0_mr2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_mr2) -> CT32B0_mr2_Get {
        CT32B0_mr2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_mr2_Get { }


// Updater for CT32B0_mr2
/// Updater for `MR2` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_mr2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_mr2,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_mr2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_mr2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_mr2) -> CT32B0_mr2_Update<'a> {
        CT32B0_mr2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_mr2) -> CT32B0_mr2_Update<'a> {
        CT32B0_mr2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT32B0_mr2_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register MR3 implementation


/// Register `MR3`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_mr3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_mr3 { }

impl CT32B0_mr3 {
    
    // Getters
    /// Fetch the value of the `MR3` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_mr3_Get {
        CT32B0_mr3_Get::new(self)
    }

    
    /// Get value of `MATCH` field.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        CT32B0_mr3_Get::new(self).match_()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MR3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_mr3_Update {
        CT32B0_mr3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'a>(&'a mut self, new_value: u32) -> CT32B0_mr3_Update<'a> {
        let mut setter: CT32B0_mr3_Update = CT32B0_mr3_Update::new(self);
        setter.set_match_(new_value);
        setter
    }
    

    }


// Getter for CT32B0_mr3
/// `MR3`: Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_mr3_Get {
    value: u32,
}

impl CT32B0_mr3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_mr3) -> CT32B0_mr3_Get {
        CT32B0_mr3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MATCH` field: Timer counter match value.
    #[inline(always)]
    pub fn match_(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_mr3_Get { }


// Updater for CT32B0_mr3
/// Updater for `MR3` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_mr3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_mr3,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_mr3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_mr3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_mr3) -> CT32B0_mr3_Update<'a> {
        CT32B0_mr3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_mr3) -> CT32B0_mr3_Update<'a> {
        CT32B0_mr3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MATCH` field.
    #[inline(always)]
    pub fn set_match_<'b>(&'b mut self, new_value: u32) -> &'b mut CT32B0_mr3_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CCR implementation


/// Register `CCR`: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_ccr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_ccr { }

impl CT32B0_ccr {
    
    // Getters
    /// Fetch the value of the `CCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_ccr_Get {
        CT32B0_ccr_Get::new(self)
    }

    
    /// Get value of `CAP0RE` field.
    #[inline(always)]
    pub fn cap0re(&self) -> CT32B0_ccr_cap0re {
        CT32B0_ccr_Get::new(self).cap0re()
    }
    
    /// Get value of `CAP0FE` field.
    #[inline(always)]
    pub fn cap0fe(&self) -> CT32B0_ccr_cap0fe {
        CT32B0_ccr_Get::new(self).cap0fe()
    }
    
    /// Get value of `CAP0I` field.
    #[inline(always)]
    pub fn cap0i(&self) -> CT32B0_ccr_cap0i {
        CT32B0_ccr_Get::new(self).cap0i()
    }
    
    /// Get value of `CAP1RE` field.
    #[inline(always)]
    pub fn cap1re(&self) -> CT32B0_ccr_cap1re {
        CT32B0_ccr_Get::new(self).cap1re()
    }
    
    /// Get value of `CAP1FE` field.
    #[inline(always)]
    pub fn cap1fe(&self) -> CT32B0_ccr_cap1fe {
        CT32B0_ccr_Get::new(self).cap1fe()
    }
    
    /// Get value of `CAP1I` field.
    #[inline(always)]
    pub fn cap1i(&self) -> CT32B0_ccr_cap1i {
        CT32B0_ccr_Get::new(self).cap1i()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_ccr_Update {
        CT32B0_ccr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CAP0RE` field.
    #[inline(always)]
    pub fn set_cap0re<'a>(&'a mut self, new_value: CT32B0_ccr_cap0re) -> CT32B0_ccr_Update<'a> {
        let mut setter: CT32B0_ccr_Update = CT32B0_ccr_Update::new(self);
        setter.set_cap0re(new_value);
        setter
    }
    
    /// Set value of `CAP0FE` field.
    #[inline(always)]
    pub fn set_cap0fe<'a>(&'a mut self, new_value: CT32B0_ccr_cap0fe) -> CT32B0_ccr_Update<'a> {
        let mut setter: CT32B0_ccr_Update = CT32B0_ccr_Update::new(self);
        setter.set_cap0fe(new_value);
        setter
    }
    
    /// Set value of `CAP0I` field.
    #[inline(always)]
    pub fn set_cap0i<'a>(&'a mut self, new_value: CT32B0_ccr_cap0i) -> CT32B0_ccr_Update<'a> {
        let mut setter: CT32B0_ccr_Update = CT32B0_ccr_Update::new(self);
        setter.set_cap0i(new_value);
        setter
    }
    
    /// Set value of `CAP1RE` field.
    #[inline(always)]
    pub fn set_cap1re<'a>(&'a mut self, new_value: CT32B0_ccr_cap1re) -> CT32B0_ccr_Update<'a> {
        let mut setter: CT32B0_ccr_Update = CT32B0_ccr_Update::new(self);
        setter.set_cap1re(new_value);
        setter
    }
    
    /// Set value of `CAP1FE` field.
    #[inline(always)]
    pub fn set_cap1fe<'a>(&'a mut self, new_value: CT32B0_ccr_cap1fe) -> CT32B0_ccr_Update<'a> {
        let mut setter: CT32B0_ccr_Update = CT32B0_ccr_Update::new(self);
        setter.set_cap1fe(new_value);
        setter
    }
    
    /// Set value of `CAP1I` field.
    #[inline(always)]
    pub fn set_cap1i<'a>(&'a mut self, new_value: CT32B0_ccr_cap1i) -> CT32B0_ccr_Update<'a> {
        let mut setter: CT32B0_ccr_Update = CT32B0_ccr_Update::new(self);
        setter.set_cap1i(new_value);
        setter
    }
    

    }


// Getter for CT32B0_ccr
/// `CCR`: Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_ccr_Get {
    value: u32,
}

impl CT32B0_ccr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_ccr) -> CT32B0_ccr_Get {
        CT32B0_ccr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAP0RE` field: Capture on CT32Bn_CAP0 rising edge: a sequence of 0 then 1 on CT32Bn_CAP0 will cause CR0 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap0re(&self) -> CT32B0_ccr_cap0re {
        match (self.value >> 0) & 1 {
            1 => ::core::option::Option::Some(CT32B0_ccr_cap0re::Enabled),
            0 => ::core::option::Option::Some(CT32B0_ccr_cap0re::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP0FE` field: Capture on CT32Bn_CAP0 falling edge: a sequence of 1 then 0 on CT32Bn_CAP0 will cause CR0 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap0fe(&self) -> CT32B0_ccr_cap0fe {
        match (self.value >> 1) & 1 {
            1 => ::core::option::Option::Some(CT32B0_ccr_cap0fe::Enabled),
            0 => ::core::option::Option::Some(CT32B0_ccr_cap0fe::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP0I` field: Interrupt on CT32Bn_CAP0 event: a CR0 load due to a CT32Bn_CAP0 event will generate an interrupt.
    #[inline(always)]
    pub fn cap0i(&self) -> CT32B0_ccr_cap0i {
        match (self.value >> 2) & 1 {
            1 => ::core::option::Option::Some(CT32B0_ccr_cap0i::Enabled),
            0 => ::core::option::Option::Some(CT32B0_ccr_cap0i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP1RE` field: Capture on CT32Bn_CAP1 rising edge: a sequence of 0 then 1 on CT32Bn_CAP1 will cause CR1 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap1re(&self) -> CT32B0_ccr_cap1re {
        match (self.value >> 3) & 1 {
            1 => ::core::option::Option::Some(CT32B0_ccr_cap1re::Enabled),
            0 => ::core::option::Option::Some(CT32B0_ccr_cap1re::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP1FE` field: Capture on CT32Bn_CAP1 falling edge: a sequence of 1 then 0 on CT32Bn_CAP1 will cause CR1 to be loaded with the contents of TC.
    #[inline(always)]
    pub fn cap1fe(&self) -> CT32B0_ccr_cap1fe {
        match (self.value >> 4) & 1 {
            1 => ::core::option::Option::Some(CT32B0_ccr_cap1fe::Enabled),
            0 => ::core::option::Option::Some(CT32B0_ccr_cap1fe::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAP1I` field: Interrupt on CT32Bn_CAP1 event: a CR1 load due to a CT32Bn_CAP1 event will generate an interrupt.
    #[inline(always)]
    pub fn cap1i(&self) -> CT32B0_ccr_cap1i {
        match (self.value >> 5) & 1 {
            1 => ::core::option::Option::Some(CT32B0_ccr_cap1i::Enabled),
            0 => ::core::option::Option::Some(CT32B0_ccr_cap1i::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT32B0_ccr_Get { }


// Updater for CT32B0_ccr
/// Updater for `CCR` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_ccr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_ccr,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_ccr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_ccr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_ccr) -> CT32B0_ccr_Update<'a> {
        CT32B0_ccr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_ccr) -> CT32B0_ccr_Update<'a> {
        CT32B0_ccr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CAP0RE` field.
    #[inline(always)]
    pub fn set_cap0re<'b>(&'b mut self, new_value: CT32B0_ccr_cap0re) -> &'b mut CT32B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `CAP0FE` field.
    #[inline(always)]
    pub fn set_cap0fe<'b>(&'b mut self, new_value: CT32B0_ccr_cap0fe) -> &'b mut CT32B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `CAP0I` field.
    #[inline(always)]
    pub fn set_cap0i<'b>(&'b mut self, new_value: CT32B0_ccr_cap0i) -> &'b mut CT32B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CAP1RE` field.
    #[inline(always)]
    pub fn set_cap1re<'b>(&'b mut self, new_value: CT32B0_ccr_cap1re) -> &'b mut CT32B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CAP1FE` field.
    #[inline(always)]
    pub fn set_cap1fe<'b>(&'b mut self, new_value: CT32B0_ccr_cap1fe) -> &'b mut CT32B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `CAP1I` field.
    #[inline(always)]
    pub fn set_cap1i<'b>(&'b mut self, new_value: CT32B0_ccr_cap1i) -> &'b mut CT32B0_ccr_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ccr_cap0re {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ccr_cap0fe {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ccr_cap0i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ccr_cap1re {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ccr_cap1fe {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ccr_cap1i {
    /// Enabled
    Enabled = 1,
    /// Disabled
    Disabled = 0,
    }







// Register CR0 implementation


/// Register `CR0`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_cr0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_cr0 { }

impl CT32B0_cr0 {
    
    // Getters
    /// Fetch the value of the `CR0` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_cr0_Get {
        CT32B0_cr0_Get::new(self)
    }

    
    /// Get value of `CAP` field.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        CT32B0_cr0_Get::new(self).cap()
    }
    

    }


// Getter for CT32B0_cr0
/// `CR0`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_cr0_Get {
    value: u32,
}

impl CT32B0_cr0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_cr0) -> CT32B0_cr0_Get {
        CT32B0_cr0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAP` field: Timer counter capture value.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_cr0_Get { }







// Register CR1 implementation


/// Register `CR1`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_cr1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_cr1 { }

impl CT32B0_cr1 {
    
    // Getters
    /// Fetch the value of the `CR1` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_cr1_Get {
        CT32B0_cr1_Get::new(self)
    }

    
    /// Get value of `CAP` field.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        CT32B0_cr1_Get::new(self).cap()
    }
    

    }


// Getter for CT32B0_cr1
/// `CR1`: Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_cr1_Get {
    value: u32,
}

impl CT32B0_cr1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_cr1) -> CT32B0_cr1_Get {
        CT32B0_cr1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAP` field: Timer counter capture value.
    #[inline(always)]
    pub fn cap(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for CT32B0_cr1_Get { }







// Register EMR implementation


/// Register `EMR`: External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_emr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_emr { }

impl CT32B0_emr {
    
    // Getters
    /// Fetch the value of the `EMR` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_emr_Get {
        CT32B0_emr_Get::new(self)
    }

    
    /// Get value of `EM0` field.
    #[inline(always)]
    pub fn em0(&self) -> bool {
        CT32B0_emr_Get::new(self).em0()
    }
    
    /// Get value of `EM1` field.
    #[inline(always)]
    pub fn em1(&self) -> bool {
        CT32B0_emr_Get::new(self).em1()
    }
    
    /// Get value of `EM2` field.
    #[inline(always)]
    pub fn em2(&self) -> bool {
        CT32B0_emr_Get::new(self).em2()
    }
    
    /// Get value of `EM3` field.
    #[inline(always)]
    pub fn em3(&self) -> bool {
        CT32B0_emr_Get::new(self).em3()
    }
    
    /// Get value of `EMC0` field.
    #[inline(always)]
    pub fn emc0(&self) -> CT32B0_emr_emc0 {
        CT32B0_emr_Get::new(self).emc0()
    }
    
    /// Get value of `EMC1` field.
    #[inline(always)]
    pub fn emc1(&self) -> CT32B0_emr_emc1 {
        CT32B0_emr_Get::new(self).emc1()
    }
    
    /// Get value of `EMC2` field.
    #[inline(always)]
    pub fn emc2(&self) -> CT32B0_emr_emc2 {
        CT32B0_emr_Get::new(self).emc2()
    }
    
    /// Get value of `EMC3` field.
    #[inline(always)]
    pub fn emc3(&self) -> CT32B0_emr_emc3 {
        CT32B0_emr_Get::new(self).emc3()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `EMR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_emr_Update {
        CT32B0_emr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `EM0` field.
    #[inline(always)]
    pub fn set_em0<'a>(&'a mut self, new_value: bool) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_em0(new_value);
        setter
    }
    
    /// Set value of `EM1` field.
    #[inline(always)]
    pub fn set_em1<'a>(&'a mut self, new_value: bool) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_em1(new_value);
        setter
    }
    
    /// Set value of `EM2` field.
    #[inline(always)]
    pub fn set_em2<'a>(&'a mut self, new_value: bool) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_em2(new_value);
        setter
    }
    
    /// Set value of `EM3` field.
    #[inline(always)]
    pub fn set_em3<'a>(&'a mut self, new_value: bool) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_em3(new_value);
        setter
    }
    
    /// Set value of `EMC0` field.
    #[inline(always)]
    pub fn set_emc0<'a>(&'a mut self, new_value: CT32B0_emr_emc0) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_emc0(new_value);
        setter
    }
    
    /// Set value of `EMC1` field.
    #[inline(always)]
    pub fn set_emc1<'a>(&'a mut self, new_value: CT32B0_emr_emc1) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_emc1(new_value);
        setter
    }
    
    /// Set value of `EMC2` field.
    #[inline(always)]
    pub fn set_emc2<'a>(&'a mut self, new_value: CT32B0_emr_emc2) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_emc2(new_value);
        setter
    }
    
    /// Set value of `EMC3` field.
    #[inline(always)]
    pub fn set_emc3<'a>(&'a mut self, new_value: CT32B0_emr_emc3) -> CT32B0_emr_Update<'a> {
        let mut setter: CT32B0_emr_Update = CT32B0_emr_Update::new(self);
        setter.set_emc3(new_value);
        setter
    }
    

    }


// Getter for CT32B0_emr
/// `EMR`: External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_emr_Get {
    value: u32,
}

impl CT32B0_emr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_emr) -> CT32B0_emr_Get {
        CT32B0_emr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `EM0` field: External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).
    #[inline(always)]
    pub fn em0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `EM1` field: External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT16B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).
    #[inline(always)]
    pub fn em1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `EM2` field: External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT16B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).
    #[inline(always)]
    pub fn em2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `EM3` field: External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. This bit is driven to the CT32B0_MAT3/CT16B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH).
    #[inline(always)]
    pub fn em3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `EMC0` field: External Match Control 0. Determines the functionality of External Match 0.
    #[inline(always)]
    pub fn emc0(&self) -> CT32B0_emr_emc0 {
        match (self.value >> 4) & 3 {
            0 => ::core::option::Option::Some(CT32B0_emr_emc0::DoNothing),
            1 => ::core::option::Option::Some(CT32B0_emr_emc0::ClearBit),
            2 => ::core::option::Option::Some(CT32B0_emr_emc0::SetBit),
            3 => ::core::option::Option::Some(CT32B0_emr_emc0::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EMC1` field: External Match Control 1. Determines the functionality of External Match 1.
    #[inline(always)]
    pub fn emc1(&self) -> CT32B0_emr_emc1 {
        match (self.value >> 6) & 3 {
            0 => ::core::option::Option::Some(CT32B0_emr_emc1::DoNothing),
            1 => ::core::option::Option::Some(CT32B0_emr_emc1::ClearBit),
            2 => ::core::option::Option::Some(CT32B0_emr_emc1::SetBit),
            3 => ::core::option::Option::Some(CT32B0_emr_emc1::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EMC2` field: External Match Control 2. Determines the functionality of External Match 2.
    #[inline(always)]
    pub fn emc2(&self) -> CT32B0_emr_emc2 {
        match (self.value >> 8) & 3 {
            0 => ::core::option::Option::Some(CT32B0_emr_emc2::DoNothing),
            1 => ::core::option::Option::Some(CT32B0_emr_emc2::ClearBit),
            2 => ::core::option::Option::Some(CT32B0_emr_emc2::SetBit),
            3 => ::core::option::Option::Some(CT32B0_emr_emc2::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EMC3` field: External Match Control 3. Determines the functionality of External Match 3.
    #[inline(always)]
    pub fn emc3(&self) -> CT32B0_emr_emc3 {
        match (self.value >> 10) & 3 {
            0 => ::core::option::Option::Some(CT32B0_emr_emc3::DoNothing),
            1 => ::core::option::Option::Some(CT32B0_emr_emc3::ClearBit),
            2 => ::core::option::Option::Some(CT32B0_emr_emc3::SetBit),
            3 => ::core::option::Option::Some(CT32B0_emr_emc3::ToggleBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT32B0_emr_Get { }


// Updater for CT32B0_emr
/// Updater for `EMR` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_emr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_emr,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_emr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_emr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_emr) -> CT32B0_emr_Update<'a> {
        CT32B0_emr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_emr) -> CT32B0_emr_Update<'a> {
        CT32B0_emr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `EM0` field.
    #[inline(always)]
    pub fn set_em0<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `EM1` field.
    #[inline(always)]
    pub fn set_em1<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `EM2` field.
    #[inline(always)]
    pub fn set_em2<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `EM3` field.
    #[inline(always)]
    pub fn set_em3<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `EMC0` field.
    #[inline(always)]
    pub fn set_emc0<'b>(&'b mut self, new_value: CT32B0_emr_emc0) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 4))
                   | ((new_value as u32) & 3) << 4;
        self.mask |= 3 << 4;
        self
    }
    /// Set value of `EMC1` field.
    #[inline(always)]
    pub fn set_emc1<'b>(&'b mut self, new_value: CT32B0_emr_emc1) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 6))
                   | ((new_value as u32) & 3) << 6;
        self.mask |= 3 << 6;
        self
    }
    /// Set value of `EMC2` field.
    #[inline(always)]
    pub fn set_emc2<'b>(&'b mut self, new_value: CT32B0_emr_emc2) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 8))
                   | ((new_value as u32) & 3) << 8;
        self.mask |= 3 << 8;
        self
    }
    /// Set value of `EMC3` field.
    #[inline(always)]
    pub fn set_emc3<'b>(&'b mut self, new_value: CT32B0_emr_emc3) -> &'b mut CT32B0_emr_Update<'a> {
        self.value = (self.value & !(3 << 10))
                   | ((new_value as u32) & 3) << 10;
        self.mask |= 3 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_emr_emc0 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_emr_emc1 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_emr_emc2 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_emr_emc3 {
    /// Do Nothing.
    DoNothing = 0,
    /// Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out).
    ClearBit = 1,
    /// Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out).
    SetBit = 2,
    /// Toggle the corresponding External Match bit/output.
    ToggleBit = 3,
    }







// Register CTCR implementation


/// Register `CTCR`: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_ctcr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_ctcr { }

impl CT32B0_ctcr {
    
    // Getters
    /// Fetch the value of the `CTCR` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_ctcr_Get {
        CT32B0_ctcr_Get::new(self)
    }

    
    /// Get value of `CTM` field.
    #[inline(always)]
    pub fn ctm(&self) -> CT32B0_ctcr_ctm {
        CT32B0_ctcr_Get::new(self).ctm()
    }
    
    /// Get value of `CIS` field.
    #[inline(always)]
    pub fn cis(&self) -> CT32B0_ctcr_cis {
        CT32B0_ctcr_Get::new(self).cis()
    }
    
    /// Get value of `ENCC` field.
    #[inline(always)]
    pub fn encc(&self) -> bool {
        CT32B0_ctcr_Get::new(self).encc()
    }
    
    /// Get value of `SELCC` field.
    #[inline(always)]
    pub fn selcc(&self) -> CT32B0_ctcr_selcc {
        CT32B0_ctcr_Get::new(self).selcc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CTCR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_ctcr_Update {
        CT32B0_ctcr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CTM` field.
    #[inline(always)]
    pub fn set_ctm<'a>(&'a mut self, new_value: CT32B0_ctcr_ctm) -> CT32B0_ctcr_Update<'a> {
        let mut setter: CT32B0_ctcr_Update = CT32B0_ctcr_Update::new(self);
        setter.set_ctm(new_value);
        setter
    }
    
    /// Set value of `CIS` field.
    #[inline(always)]
    pub fn set_cis<'a>(&'a mut self, new_value: CT32B0_ctcr_cis) -> CT32B0_ctcr_Update<'a> {
        let mut setter: CT32B0_ctcr_Update = CT32B0_ctcr_Update::new(self);
        setter.set_cis(new_value);
        setter
    }
    
    /// Set value of `ENCC` field.
    #[inline(always)]
    pub fn set_encc<'a>(&'a mut self, new_value: bool) -> CT32B0_ctcr_Update<'a> {
        let mut setter: CT32B0_ctcr_Update = CT32B0_ctcr_Update::new(self);
        setter.set_encc(new_value);
        setter
    }
    
    /// Set value of `SELCC` field.
    #[inline(always)]
    pub fn set_selcc<'a>(&'a mut self, new_value: CT32B0_ctcr_selcc) -> CT32B0_ctcr_Update<'a> {
        let mut setter: CT32B0_ctcr_Update = CT32B0_ctcr_Update::new(self);
        setter.set_selcc(new_value);
        setter
    }
    

    }


// Getter for CT32B0_ctcr
/// `CTCR`: Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_ctcr_Get {
    value: u32,
}

impl CT32B0_ctcr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_ctcr) -> CT32B0_ctcr_Get {
        CT32B0_ctcr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CTM` field: Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: every rising PCLK edge
    #[inline(always)]
    pub fn ctm(&self) -> CT32B0_ctcr_ctm {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(CT32B0_ctcr_ctm::EveryRisingPCLK),
            1 => ::core::option::Option::Some(CT32B0_ctcr_ctm::Rising),
            2 => ::core::option::Option::Some(CT32B0_ctcr_ctm::Falling),
            3 => ::core::option::Option::Some(CT32B0_ctcr_ctm::Both),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CIS` field: Count Input Select. When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking:
    #[inline(always)]
    pub fn cis(&self) -> CT32B0_ctcr_cis {
        match (self.value >> 2) & 3 {
            0 => ::core::option::Option::Some(CT32B0_ctcr_cis::CT32BN_CAP0),
            1 => ::core::option::Option::Some(CT32B0_ctcr_cis::CT32BN_CAP1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ENCC` field: Setting this bit to one enables clearing of the timer and the prescaler when the capture-edge event specified in bits 7:5 occurs.
    #[inline(always)]
    pub fn encc(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `SELCC` field: When bit 4 is one, these bits select which capture input edge will cause the timer and prescaler to be cleared. These bits have no effect when bit 4 is zero.
    #[inline(always)]
    pub fn selcc(&self) -> CT32B0_ctcr_selcc {
        match (self.value >> 5) & 7 {
            0 => ::core::option::Option::Some(CT32B0_ctcr_selcc::RisingCap0),
            1 => ::core::option::Option::Some(CT32B0_ctcr_selcc::FallingCap0),
            2 => ::core::option::Option::Some(CT32B0_ctcr_selcc::RisingCap1),
            3 => ::core::option::Option::Some(CT32B0_ctcr_selcc::FallingCap1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT32B0_ctcr_Get { }


// Updater for CT32B0_ctcr
/// Updater for `CTCR` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_ctcr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_ctcr,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_ctcr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_ctcr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_ctcr) -> CT32B0_ctcr_Update<'a> {
        CT32B0_ctcr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_ctcr) -> CT32B0_ctcr_Update<'a> {
        CT32B0_ctcr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CTM` field.
    #[inline(always)]
    pub fn set_ctm<'b>(&'b mut self, new_value: CT32B0_ctcr_ctm) -> &'b mut CT32B0_ctcr_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Set value of `CIS` field.
    #[inline(always)]
    pub fn set_cis<'b>(&'b mut self, new_value: CT32B0_ctcr_cis) -> &'b mut CT32B0_ctcr_Update<'a> {
        self.value = (self.value & !(3 << 2))
                   | ((new_value as u32) & 3) << 2;
        self.mask |= 3 << 2;
        self
    }
    /// Set value of `ENCC` field.
    #[inline(always)]
    pub fn set_encc<'b>(&'b mut self, new_value: bool) -> &'b mut CT32B0_ctcr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `SELCC` field.
    #[inline(always)]
    pub fn set_selcc<'b>(&'b mut self, new_value: CT32B0_ctcr_selcc) -> &'b mut CT32B0_ctcr_Update<'a> {
        self.value = (self.value & !(7 << 5))
                   | ((new_value as u32) & 7) << 5;
        self.mask |= 7 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ctcr_ctm {
    /// Timer Mode: every rising PCLK edge
    EveryRisingPCLK = 0,
    /// Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2.
    Rising = 1,
    /// Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2.
    Falling = 2,
    /// Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2.
    Both = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ctcr_cis {
    /// CT32Bn_CAP0
    CT32BN_CAP0 = 0,
    /// CT32Bn_CAP1
    CT32BN_CAP1 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_ctcr_selcc {
    /// Rising Edge of CAP0 clears the timer (if bit 4 is set).
    RisingCap0 = 0,
    /// Falling Edge of CAP0 clears the timer (if bit 4 is set).
    FallingCap0 = 1,
    /// Rising Edge of CAP1 clears the timer (if bit 4 is set).
    RisingCap1 = 2,
    /// Falling Edge of CAP1 clears the timer (if bit 4 is set).
    FallingCap1 = 3,
    }







// Register PWMC implementation


/// Register `PWMC`: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct CT32B0_pwmc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for CT32B0_pwmc { }

impl CT32B0_pwmc {
    
    // Getters
    /// Fetch the value of the `PWMC` register.
    #[inline(always)]
    pub fn get(&self) -> CT32B0_pwmc_Get {
        CT32B0_pwmc_Get::new(self)
    }

    
    /// Get value of `PWMEN0` field.
    #[inline(always)]
    pub fn pwmen0(&self) -> CT32B0_pwmc_pwmen0 {
        CT32B0_pwmc_Get::new(self).pwmen0()
    }
    
    /// Get value of `PWMEN1` field.
    #[inline(always)]
    pub fn pwmen1(&self) -> CT32B0_pwmc_pwmen1 {
        CT32B0_pwmc_Get::new(self).pwmen1()
    }
    
    /// Get value of `PWMEN2` field.
    #[inline(always)]
    pub fn pwmen2(&self) -> CT32B0_pwmc_pwmen2 {
        CT32B0_pwmc_Get::new(self).pwmen2()
    }
    
    /// Get value of `PWMEN3` field.
    #[inline(always)]
    pub fn pwmen3(&self) -> CT32B0_pwmc_pwmen3 {
        CT32B0_pwmc_Get::new(self).pwmen3()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PWMC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> CT32B0_pwmc_Update {
        CT32B0_pwmc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `PWMEN0` field.
    #[inline(always)]
    pub fn set_pwmen0<'a>(&'a mut self, new_value: CT32B0_pwmc_pwmen0) -> CT32B0_pwmc_Update<'a> {
        let mut setter: CT32B0_pwmc_Update = CT32B0_pwmc_Update::new(self);
        setter.set_pwmen0(new_value);
        setter
    }
    
    /// Set value of `PWMEN1` field.
    #[inline(always)]
    pub fn set_pwmen1<'a>(&'a mut self, new_value: CT32B0_pwmc_pwmen1) -> CT32B0_pwmc_Update<'a> {
        let mut setter: CT32B0_pwmc_Update = CT32B0_pwmc_Update::new(self);
        setter.set_pwmen1(new_value);
        setter
    }
    
    /// Set value of `PWMEN2` field.
    #[inline(always)]
    pub fn set_pwmen2<'a>(&'a mut self, new_value: CT32B0_pwmc_pwmen2) -> CT32B0_pwmc_Update<'a> {
        let mut setter: CT32B0_pwmc_Update = CT32B0_pwmc_Update::new(self);
        setter.set_pwmen2(new_value);
        setter
    }
    
    /// Set value of `PWMEN3` field.
    #[inline(always)]
    pub fn set_pwmen3<'a>(&'a mut self, new_value: CT32B0_pwmc_pwmen3) -> CT32B0_pwmc_Update<'a> {
        let mut setter: CT32B0_pwmc_Update = CT32B0_pwmc_Update::new(self);
        setter.set_pwmen3(new_value);
        setter
    }
    

    }


// Getter for CT32B0_pwmc
/// `PWMC`: PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0].
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct CT32B0_pwmc_Get {
    value: u32,
}

impl CT32B0_pwmc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &CT32B0_pwmc) -> CT32B0_pwmc_Get {
        CT32B0_pwmc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `PWMEN0` field: PWM channel 0 enable
    #[inline(always)]
    pub fn pwmen0(&self) -> CT32B0_pwmc_pwmen0 {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(CT32B0_pwmc_pwmen0::ControlledByEM0),
            1 => ::core::option::Option::Some(CT32B0_pwmc_pwmen0::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PWMEN1` field: PWM channel 1 enable
    #[inline(always)]
    pub fn pwmen1(&self) -> CT32B0_pwmc_pwmen1 {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(CT32B0_pwmc_pwmen1::ControlledByEM1),
            1 => ::core::option::Option::Some(CT32B0_pwmc_pwmen1::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PWMEN2` field: PWM channel 2 enable
    #[inline(always)]
    pub fn pwmen2(&self) -> CT32B0_pwmc_pwmen2 {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(CT32B0_pwmc_pwmen2::ControlledByEM2),
            1 => ::core::option::Option::Some(CT32B0_pwmc_pwmen2::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `PWMEN3` field: PWM channel 3 enable Note: It is recommended to use match channel 3 to set the PWM cycle.
    #[inline(always)]
    pub fn pwmen3(&self) -> CT32B0_pwmc_pwmen3 {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(CT32B0_pwmc_pwmen3::ControlledByEM3),
            1 => ::core::option::Option::Some(CT32B0_pwmc_pwmen3::PWMIsEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for CT32B0_pwmc_Get { }


// Updater for CT32B0_pwmc
/// Updater for `PWMC` register.
#[allow(non_camel_case_types)]
pub struct CT32B0_pwmc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a CT32B0_pwmc,
}

/// This performs the register update.
impl <'a> Drop for CT32B0_pwmc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> CT32B0_pwmc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a CT32B0_pwmc) -> CT32B0_pwmc_Update<'a> {
        CT32B0_pwmc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a CT32B0_pwmc) -> CT32B0_pwmc_Update<'a> {
        CT32B0_pwmc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `PWMEN0` field.
    #[inline(always)]
    pub fn set_pwmen0<'b>(&'b mut self, new_value: CT32B0_pwmc_pwmen0) -> &'b mut CT32B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `PWMEN1` field.
    #[inline(always)]
    pub fn set_pwmen1<'b>(&'b mut self, new_value: CT32B0_pwmc_pwmen1) -> &'b mut CT32B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `PWMEN2` field.
    #[inline(always)]
    pub fn set_pwmen2<'b>(&'b mut self, new_value: CT32B0_pwmc_pwmen2) -> &'b mut CT32B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `PWMEN3` field.
    #[inline(always)]
    pub fn set_pwmen3<'b>(&'b mut self, new_value: CT32B0_pwmc_pwmen3) -> &'b mut CT32B0_pwmc_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_pwmc_pwmen0 {
    /// CT32Bn_MAT0 is controlled by EM0.
    ControlledByEM0 = 0,
    /// PWM mode is enabled for CT32Bn_MAT0.
    PWMIsEnabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_pwmc_pwmen1 {
    /// CT32Bn_MAT1 is controlled by EM1.
    ControlledByEM1 = 0,
    /// PWM mode is enabled for CT32Bn_MAT1.
    PWMIsEnabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_pwmc_pwmen2 {
    /// CT32Bn_MAT2 is controlled by EM2.
    ControlledByEM2 = 0,
    /// PWM mode is enabled for CT32Bn_MAT2.
    PWMIsEnabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum CT32B0_pwmc_pwmen3 {
    /// CT32Bn_MAT3 is controlled by EM3.
    ControlledByEM3 = 0,
    /// PWM mode is enabled for CT32Bn_MAT3.
    PWMIsEnabled = 1,
    }





// Peripheral CT32B0 implementation

/// Product name title=UM10398 Chapter title=LPC1100XL series: 32-bit counter/timer CT32B0/1 Modification date=2/22/2012 Major revision=8 Minor revision=not available 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct CT32B0;

impl CT32B0 {
    /// Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
    #[inline(always)]
    pub fn ir() -> &'static mut CT32B0_ir {
        unsafe { ::core::intrinsics::transmute(0x40014000 as usize) }
    }
    /// Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    #[inline(always)]
    pub fn tcr() -> &'static mut CT32B0_tcr {
        unsafe { ::core::intrinsics::transmute(0x40014004 as usize) }
    }
    /// Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    #[inline(always)]
    pub fn tc() -> &'static mut CT32B0_tc {
        unsafe { ::core::intrinsics::transmute(0x40014008 as usize) }
    }
    /// Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
    #[inline(always)]
    pub fn pr() -> &'static mut CT32B0_pr {
        unsafe { ::core::intrinsics::transmute(0x4001400c as usize) }
    }
    /// Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    #[inline(always)]
    pub fn pc() -> &'static mut CT32B0_pc {
        unsafe { ::core::intrinsics::transmute(0x40014010 as usize) }
    }
    /// Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    #[inline(always)]
    pub fn mcr() -> &'static mut CT32B0_mcr {
        unsafe { ::core::intrinsics::transmute(0x40014014 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr0() -> &'static mut CT32B0_mr0 {
        unsafe { ::core::intrinsics::transmute(0x40014018 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr1() -> &'static mut CT32B0_mr1 {
        unsafe { ::core::intrinsics::transmute(0x4001401c as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr2() -> &'static mut CT32B0_mr2 {
        unsafe { ::core::intrinsics::transmute(0x40014020 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr3() -> &'static mut CT32B0_mr3 {
        unsafe { ::core::intrinsics::transmute(0x40014024 as usize) }
    }
    /// Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    #[inline(always)]
    pub fn ccr() -> &'static mut CT32B0_ccr {
        unsafe { ::core::intrinsics::transmute(0x40014028 as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr0() -> &'static mut CT32B0_cr0 {
        unsafe { ::core::intrinsics::transmute(0x4001402c as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr1() -> &'static mut CT32B0_cr1 {
        unsafe { ::core::intrinsics::transmute(0x40014030 as usize) }
    }
    /// External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0].
    #[inline(always)]
    pub fn emr() -> &'static mut CT32B0_emr {
        unsafe { ::core::intrinsics::transmute(0x4001403c as usize) }
    }
    /// Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    #[inline(always)]
    pub fn ctcr() -> &'static mut CT32B0_ctcr {
        unsafe { ::core::intrinsics::transmute(0x40014070 as usize) }
    }
    /// PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0].
    #[inline(always)]
    pub fn pwmc() -> &'static mut CT32B0_pwmc {
        unsafe { ::core::intrinsics::transmute(0x40014074 as usize) }
    }
    }



// Registers for CT32B1



































// Peripheral CT32B1 implementation

/// LPC11xx, LPC11Cxx, LPC11xxL, LPC11xxXL
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct CT32B1;

impl CT32B1 {
    /// Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending.
    #[inline(always)]
    pub fn ir() -> &'static mut CT32B0_ir {
        unsafe { ::core::intrinsics::transmute(0x40018000 as usize) }
    }
    /// Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR.
    #[inline(always)]
    pub fn tcr() -> &'static mut CT32B0_tcr {
        unsafe { ::core::intrinsics::transmute(0x40018004 as usize) }
    }
    /// Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR.
    #[inline(always)]
    pub fn tc() -> &'static mut CT32B0_tc {
        unsafe { ::core::intrinsics::transmute(0x40018008 as usize) }
    }
    /// Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC.
    #[inline(always)]
    pub fn pr() -> &'static mut CT32B0_pr {
        unsafe { ::core::intrinsics::transmute(0x4001800c as usize) }
    }
    /// Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface.
    #[inline(always)]
    pub fn pc() -> &'static mut CT32B0_pc {
        unsafe { ::core::intrinsics::transmute(0x40018010 as usize) }
    }
    /// Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs.
    #[inline(always)]
    pub fn mcr() -> &'static mut CT32B0_mcr {
        unsafe { ::core::intrinsics::transmute(0x40018014 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr0() -> &'static mut CT32B0_mr0 {
        unsafe { ::core::intrinsics::transmute(0x40018018 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr1() -> &'static mut CT32B0_mr1 {
        unsafe { ::core::intrinsics::transmute(0x4001801c as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr2() -> &'static mut CT32B0_mr2 {
        unsafe { ::core::intrinsics::transmute(0x40018020 as usize) }
    }
    /// Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR matches the TC.
    #[inline(always)]
    pub fn mr3() -> &'static mut CT32B0_mr3 {
        unsafe { ::core::intrinsics::transmute(0x40018024 as usize) }
    }
    /// Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place.
    #[inline(always)]
    pub fn ccr() -> &'static mut CT32B0_ccr {
        unsafe { ::core::intrinsics::transmute(0x40018028 as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr0() -> &'static mut CT32B0_cr0 {
        unsafe { ::core::intrinsics::transmute(0x4001802c as usize) }
    }
    /// Capture Register (CR). CR is loaded with the value of TC when there is an event on the CT16Bn_CAPm input.
    #[inline(always)]
    pub fn cr1() -> &'static mut CT32B0_cr1 {
        unsafe { ::core::intrinsics::transmute(0x40018030 as usize) }
    }
    /// External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0].
    #[inline(always)]
    pub fn emr() -> &'static mut CT32B0_emr {
        unsafe { ::core::intrinsics::transmute(0x4001803c as usize) }
    }
    /// Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting.
    #[inline(always)]
    pub fn ctcr() -> &'static mut CT32B0_ctcr {
        unsafe { ::core::intrinsics::transmute(0x40018070 as usize) }
    }
    /// PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0].
    #[inline(always)]
    pub fn pwmc() -> &'static mut CT32B0_pwmc {
        unsafe { ::core::intrinsics::transmute(0x40018074 as usize) }
    }
    }



// Registers for ADC





// Register CR implementation


/// Register `CR`: A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_cr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_cr { }

impl ADC_cr {
    
    // Getters
    /// Fetch the value of the `CR` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_cr_Get {
        ADC_cr_Get::new(self)
    }

    
    /// Get value of `SEL` field.
    #[inline(always)]
    pub fn sel(&self) -> u32 {
        ADC_cr_Get::new(self).sel()
    }
    
    /// Get value of `CLKDIV` field.
    #[inline(always)]
    pub fn clkdiv(&self) -> u32 {
        ADC_cr_Get::new(self).clkdiv()
    }
    
    /// Get value of `BURST` field.
    #[inline(always)]
    pub fn burst(&self) -> ADC_cr_burst {
        ADC_cr_Get::new(self).burst()
    }
    
    /// Get value of `CLKS` field.
    #[inline(always)]
    pub fn clks(&self) -> ADC_cr_clks {
        ADC_cr_Get::new(self).clks()
    }
    
    /// Get value of `START` field.
    #[inline(always)]
    pub fn start(&self) -> ADC_cr_start {
        ADC_cr_Get::new(self).start()
    }
    
    /// Get value of `EDGE` field.
    #[inline(always)]
    pub fn edge(&self) -> ADC_cr_edge {
        ADC_cr_Get::new(self).edge()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_cr_Update {
        ADC_cr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'a>(&'a mut self, new_value: u32) -> ADC_cr_Update<'a> {
        let mut setter: ADC_cr_Update = ADC_cr_Update::new(self);
        setter.set_sel(new_value);
        setter
    }
    
    /// Set value of `CLKDIV` field.
    #[inline(always)]
    pub fn set_clkdiv<'a>(&'a mut self, new_value: u32) -> ADC_cr_Update<'a> {
        let mut setter: ADC_cr_Update = ADC_cr_Update::new(self);
        setter.set_clkdiv(new_value);
        setter
    }
    
    /// Set value of `BURST` field.
    #[inline(always)]
    pub fn set_burst<'a>(&'a mut self, new_value: ADC_cr_burst) -> ADC_cr_Update<'a> {
        let mut setter: ADC_cr_Update = ADC_cr_Update::new(self);
        setter.set_burst(new_value);
        setter
    }
    
    /// Set value of `CLKS` field.
    #[inline(always)]
    pub fn set_clks<'a>(&'a mut self, new_value: ADC_cr_clks) -> ADC_cr_Update<'a> {
        let mut setter: ADC_cr_Update = ADC_cr_Update::new(self);
        setter.set_clks(new_value);
        setter
    }
    
    /// Set value of `START` field.
    #[inline(always)]
    pub fn set_start<'a>(&'a mut self, new_value: ADC_cr_start) -> ADC_cr_Update<'a> {
        let mut setter: ADC_cr_Update = ADC_cr_Update::new(self);
        setter.set_start(new_value);
        setter
    }
    
    /// Set value of `EDGE` field.
    #[inline(always)]
    pub fn set_edge<'a>(&'a mut self, new_value: ADC_cr_edge) -> ADC_cr_Update<'a> {
        let mut setter: ADC_cr_Update = ADC_cr_Update::new(self);
        setter.set_edge(new_value);
        setter
    }
    

    }


// Getter for ADC_cr
/// `CR`: A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_cr_Get {
    value: u32,
}

impl ADC_cr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_cr) -> ADC_cr_Get {
        ADC_cr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SEL` field: Selects which of the AD7:0 pins is (are) to be sampled and converted. Bit 0 selects Pin AD0, bit 1 selects pin AD1,..., and bit 7 selects pin AD7.  In software-controlled mode (BURST = 0), only one channel can be selected, i.e. only one of these bits should be 1.  In hardware scan mode (BURST = 1), any numbers of channels can be selected, i.e any or all bits can be set to 1. If all bits are set to 0, channel 0 is selected automatically (SEL = 0x01).
    #[inline(always)]
    pub fn sel(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `CLKDIV` field: The APB clock (PCLK) is divided by CLKDIV +1 to produce the clock for the ADC, which should be less than or equal to 4.5 MHz. Typically, software should program the smallest value in this field that yields a clock of 4.5 MHz or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable.
    #[inline(always)]
    pub fn clkdiv(&self) -> u32 {
        (self.value >> 8) & 255
        }
    /// Get value of `BURST` field: Burst mode
    #[inline(always)]
    pub fn burst(&self) -> ADC_cr_burst {
        match (self.value >> 16) & 1 {
            0 => ::core::option::Option::Some(ADC_cr_burst::SoftwareControlled),
            1 => ::core::option::Option::Some(ADC_cr_burst::HardwareScan),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CLKS` field: This field selects the number of clocks used for each conversion in Burst mode, and the number of bits of accuracy of the result in the LS bits of ADDR, between 11 clocks (10 bits) and 4 clocks (3 bits).
    #[inline(always)]
    pub fn clks(&self) -> ADC_cr_clks {
        match (self.value >> 17) & 7 {
            0 => ::core::option::Option::Some(ADC_cr_clks::Bits10),
            1 => ::core::option::Option::Some(ADC_cr_clks::Bits9),
            2 => ::core::option::Option::Some(ADC_cr_clks::Bits8),
            3 => ::core::option::Option::Some(ADC_cr_clks::Bits7),
            4 => ::core::option::Option::Some(ADC_cr_clks::Bits6),
            5 => ::core::option::Option::Some(ADC_cr_clks::Bits5),
            6 => ::core::option::Option::Some(ADC_cr_clks::Bits4),
            7 => ::core::option::Option::Some(ADC_cr_clks::Bits3),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `START` field: When the BURST bit is 0, these bits control whether and when an A/D conversion is started:
    #[inline(always)]
    pub fn start(&self) -> ADC_cr_start {
        match (self.value >> 24) & 7 {
            0 => ::core::option::Option::Some(ADC_cr_start::Stopped),
            1 => ::core::option::Option::Some(ADC_cr_start::Started),
            2 => ::core::option::Option::Some(ADC_cr_start::EdgePort0Pin2),
            3 => ::core::option::Option::Some(ADC_cr_start::EdgePortPin5),
            4 => ::core::option::Option::Some(ADC_cr_start::EdgeCT32B0_MAT0_1),
            5 => ::core::option::Option::Some(ADC_cr_start::EdgeCT32B0_MAT1_1),
            6 => ::core::option::Option::Some(ADC_cr_start::EdgeCT16B0_MAT0_1),
            7 => ::core::option::Option::Some(ADC_cr_start::EdgeCT16B0_MAT1_1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EDGE` field: This bit is significant only when the START field contains 010-111. In these cases: Start conversion on a falling edge on the selected CAP/MAT signal.
    #[inline(always)]
    pub fn edge(&self) -> ADC_cr_edge {
        match (self.value >> 27) & 1 {
            0 => ::core::option::Option::Some(ADC_cr_edge::Rising),
            1 => ::core::option::Option::Some(ADC_cr_edge::Falling),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for ADC_cr_Get { }


// Updater for ADC_cr
/// Updater for `CR` register.
#[allow(non_camel_case_types)]
pub struct ADC_cr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_cr,
}

/// This performs the register update.
impl <'a> Drop for ADC_cr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_cr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_cr) -> ADC_cr_Update<'a> {
        ADC_cr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_cr) -> ADC_cr_Update<'a> {
        ADC_cr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_cr_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `CLKDIV` field.
    #[inline(always)]
    pub fn set_clkdiv<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_cr_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Set value of `BURST` field.
    #[inline(always)]
    pub fn set_burst<'b>(&'b mut self, new_value: ADC_cr_burst) -> &'b mut ADC_cr_Update<'a> {
        self.value = (self.value & !(1 << 16))
                   | ((new_value as u32) & 1) << 16;
        self.mask |= 1 << 16;
        self
    }
    /// Set value of `CLKS` field.
    #[inline(always)]
    pub fn set_clks<'b>(&'b mut self, new_value: ADC_cr_clks) -> &'b mut ADC_cr_Update<'a> {
        self.value = (self.value & !(7 << 17))
                   | ((new_value as u32) & 7) << 17;
        self.mask |= 7 << 17;
        self
    }
    /// Set value of `START` field.
    #[inline(always)]
    pub fn set_start<'b>(&'b mut self, new_value: ADC_cr_start) -> &'b mut ADC_cr_Update<'a> {
        self.value = (self.value & !(7 << 24))
                   | ((new_value as u32) & 7) << 24;
        self.mask |= 7 << 24;
        self
    }
    /// Set value of `EDGE` field.
    #[inline(always)]
    pub fn set_edge<'b>(&'b mut self, new_value: ADC_cr_edge) -> &'b mut ADC_cr_Update<'a> {
        self.value = (self.value & !(1 << 27))
                   | ((new_value as u32) & 1) << 27;
        self.mask |= 1 << 27;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ADC_cr_burst {
    /// Software-controlled mode: Conversions are software-controlled and require 11 clocks.
    SoftwareControlled = 0,
    /// Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher  bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start.
    HardwareScan = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ADC_cr_clks {
    /// 11 clocks / 10 bits
    Bits10 = 0,
    /// 10 clocks / 9 bits
    Bits9 = 1,
    /// 9 clocks / 8 bits
    Bits8 = 2,
    /// 8 clocks / 7 bits
    Bits7 = 3,
    /// 7 clocks / 6 bits
    Bits6 = 4,
    /// 6 clocks / 5 bits
    Bits5 = 5,
    /// 5 clocks / 4 bits
    Bits4 = 6,
    /// 4 clocks / 3 bits
    Bits3 = 7,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ADC_cr_start {
    /// No start (this value should be used when clearing PDN to 0).
    Stopped = 0,
    /// Start conversion now.
    Started = 1,
    /// Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0.
    EdgePort0Pin2 = 2,
    /// Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0.
    EdgePortPin5 = 3,
    /// Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0[1].
    EdgeCT32B0_MAT0_1 = 4,
    /// Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1[1].
    EdgeCT32B0_MAT1_1 = 5,
    /// Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0[1].
    EdgeCT16B0_MAT0_1 = 6,
    /// Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1[1].
    EdgeCT16B0_MAT1_1 = 7,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum ADC_cr_edge {
    /// Start conversion on a rising edge on the selected CAP/MAT signal.
    Rising = 0,
    /// Start conversion on a rising edge on the selected CAP/MAT signal.
    Falling = 1,
    }







// Register GDR implementation


/// Register `GDR`: A/D Global Data Register. Contains the result of the most recent A/D conversion.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_gdr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_gdr { }

impl ADC_gdr {
    
    // Getters
    /// Fetch the value of the `GDR` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_gdr_Get {
        ADC_gdr_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_gdr_Get::new(self).v_vref()
    }
    
    /// Get value of `CHN` field.
    #[inline(always)]
    pub fn chn(&self) -> u32 {
        ADC_gdr_Get::new(self).chn()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_gdr_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_gdr_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `GDR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_gdr_Update {
        ADC_gdr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_gdr_Update<'a> {
        let mut setter: ADC_gdr_Update = ADC_gdr_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `CHN` field.
    #[inline(always)]
    pub fn set_chn<'a>(&'a mut self, new_value: u32) -> ADC_gdr_Update<'a> {
        let mut setter: ADC_gdr_Update = ADC_gdr_Update::new(self);
        setter.set_chn(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_gdr_Update<'a> {
        let mut setter: ADC_gdr_Update = ADC_gdr_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_gdr_Update<'a> {
        let mut setter: ADC_gdr_Update = ADC_gdr_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_gdr
/// `GDR`: A/D Global Data Register. Contains the result of the most recent A/D conversion.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_gdr_Get {
    value: u32,
}

impl ADC_gdr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_gdr) -> ADC_gdr_Get {
        ADC_gdr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin selected by the SEL field, divided by the voltage on the VDD pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VSS, while 0x3FF indicates that the voltage on ADn was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `CHN` field: These bits contain the channel from which the result bits V_VREF were converted.
    #[inline(always)]
    pub fn chn(&self) -> u32 {
        (self.value >> 24) & 7
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read and when the ADCR is written. If the ADCR is written while a conversion is still in progress, this bit is set and a new conversion is started.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_gdr_Get { }


// Updater for ADC_gdr
/// Updater for `GDR` register.
#[allow(non_camel_case_types)]
pub struct ADC_gdr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_gdr,
}

/// This performs the register update.
impl <'a> Drop for ADC_gdr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_gdr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_gdr) -> ADC_gdr_Update<'a> {
        ADC_gdr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_gdr) -> ADC_gdr_Update<'a> {
        ADC_gdr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_gdr_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `CHN` field.
    #[inline(always)]
    pub fn set_chn<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_gdr_Update<'a> {
        self.value = (self.value & !(7 << 24))
                   | ((new_value as u32) & 7) << 24;
        self.mask |= 7 << 24;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_gdr_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_gdr_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register STAT implementation


/// Register `STAT`: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_stat {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_stat { }

impl ADC_stat {
    
    // Getters
    /// Fetch the value of the `STAT` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_stat_Get {
        ADC_stat_Get::new(self)
    }

    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> u32 {
        ADC_stat_Get::new(self).done()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> u32 {
        ADC_stat_Get::new(self).overrun()
    }
    
    /// Get value of `ADINT` field.
    #[inline(always)]
    pub fn adint(&self) -> bool {
        ADC_stat_Get::new(self).adint()
    }
    

    }


// Getter for ADC_stat
/// `STAT`: A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_stat_Get {
    value: u32,
}

impl ADC_stat_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_stat) -> ADC_stat_Get {
        ADC_stat_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DONE` field: These bits mirror the DONE status flags that appear in the result register for each A/D channel n.
    #[inline(always)]
    pub fn done(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `OVERRUN` field: These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel n. Reading ADSTAT allows checking the status of all A/D channels simultaneously.
    #[inline(always)]
    pub fn overrun(&self) -> u32 {
        (self.value >> 8) & 255
        }
    /// Get value of `ADINT` field: This bit is the A/D interrupt flag. It is one when any of the individual A/D channel Done flags is asserted and enabled to contribute to the A/D interrupt via the ADINTEN register.
    #[inline(always)]
    pub fn adint(&self) -> bool {
        (self.value >> 16) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_stat_Get { }







// Register INTEN implementation


/// Register `INTEN`: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_inten {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_inten { }

impl ADC_inten {
    
    // Getters
    /// Fetch the value of the `INTEN` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_inten_Get {
        ADC_inten_Get::new(self)
    }

    
    /// Get value of `ADINTENn` field.
    #[inline(always)]
    pub fn adintenn(&self) -> u32 {
        ADC_inten_Get::new(self).adintenn()
    }
    
    /// Get value of `ADGINTEN` field.
    #[inline(always)]
    pub fn adginten(&self) -> bool {
        ADC_inten_Get::new(self).adginten()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `INTEN` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_inten_Update {
        ADC_inten_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ADINTENn` field.
    #[inline(always)]
    pub fn set_adintenn<'a>(&'a mut self, new_value: u32) -> ADC_inten_Update<'a> {
        let mut setter: ADC_inten_Update = ADC_inten_Update::new(self);
        setter.set_adintenn(new_value);
        setter
    }
    
    /// Set value of `ADGINTEN` field.
    #[inline(always)]
    pub fn set_adginten<'a>(&'a mut self, new_value: bool) -> ADC_inten_Update<'a> {
        let mut setter: ADC_inten_Update = ADC_inten_Update::new(self);
        setter.set_adginten(new_value);
        setter
    }
    

    }


// Getter for ADC_inten
/// `INTEN`: A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_inten_Get {
    value: u32,
}

impl ADC_inten_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_inten) -> ADC_inten_Get {
        ADC_inten_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ADINTENn` field: These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc.
    #[inline(always)]
    pub fn adintenn(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `ADGINTEN` field: When 1, enables the global DONE flag in ADDR to generate an interrupt. When 0, only the individual A/D channels enabled by ADINTEN 7:0 will generate interrupts.
    #[inline(always)]
    pub fn adginten(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_inten_Get { }


// Updater for ADC_inten
/// Updater for `INTEN` register.
#[allow(non_camel_case_types)]
pub struct ADC_inten_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_inten,
}

/// This performs the register update.
impl <'a> Drop for ADC_inten_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_inten_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_inten) -> ADC_inten_Update<'a> {
        ADC_inten_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_inten) -> ADC_inten_Update<'a> {
        ADC_inten_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ADINTENn` field.
    #[inline(always)]
    pub fn set_adintenn<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_inten_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `ADGINTEN` field.
    #[inline(always)]
    pub fn set_adginten<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_inten_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR0 implementation


/// Register `DR0`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr0 { }

impl ADC_dr0 {
    
    // Getters
    /// Fetch the value of the `DR0` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr0_Get {
        ADC_dr0_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr0_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr0_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr0_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr0_Update {
        ADC_dr0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr0_Update<'a> {
        let mut setter: ADC_dr0_Update = ADC_dr0_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr0_Update<'a> {
        let mut setter: ADC_dr0_Update = ADC_dr0_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr0_Update<'a> {
        let mut setter: ADC_dr0_Update = ADC_dr0_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr0
/// `DR0`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr0_Get {
    value: u32,
}

impl ADC_dr0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr0) -> ADC_dr0_Get {
        ADC_dr0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr0_Get { }


// Updater for ADC_dr0
/// Updater for `DR0` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr0,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr0) -> ADC_dr0_Update<'a> {
        ADC_dr0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr0) -> ADC_dr0_Update<'a> {
        ADC_dr0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr0_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr0_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr0_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR1 implementation


/// Register `DR1`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr1 { }

impl ADC_dr1 {
    
    // Getters
    /// Fetch the value of the `DR1` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr1_Get {
        ADC_dr1_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr1_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr1_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr1_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr1_Update {
        ADC_dr1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr1_Update<'a> {
        let mut setter: ADC_dr1_Update = ADC_dr1_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr1_Update<'a> {
        let mut setter: ADC_dr1_Update = ADC_dr1_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr1_Update<'a> {
        let mut setter: ADC_dr1_Update = ADC_dr1_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr1
/// `DR1`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr1_Get {
    value: u32,
}

impl ADC_dr1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr1) -> ADC_dr1_Get {
        ADC_dr1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr1_Get { }


// Updater for ADC_dr1
/// Updater for `DR1` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr1,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr1) -> ADC_dr1_Update<'a> {
        ADC_dr1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr1) -> ADC_dr1_Update<'a> {
        ADC_dr1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr1_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr1_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr1_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR2 implementation


/// Register `DR2`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr2 { }

impl ADC_dr2 {
    
    // Getters
    /// Fetch the value of the `DR2` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr2_Get {
        ADC_dr2_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr2_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr2_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr2_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr2_Update {
        ADC_dr2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr2_Update<'a> {
        let mut setter: ADC_dr2_Update = ADC_dr2_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr2_Update<'a> {
        let mut setter: ADC_dr2_Update = ADC_dr2_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr2_Update<'a> {
        let mut setter: ADC_dr2_Update = ADC_dr2_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr2
/// `DR2`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr2_Get {
    value: u32,
}

impl ADC_dr2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr2) -> ADC_dr2_Get {
        ADC_dr2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr2_Get { }


// Updater for ADC_dr2
/// Updater for `DR2` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr2,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr2) -> ADC_dr2_Update<'a> {
        ADC_dr2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr2) -> ADC_dr2_Update<'a> {
        ADC_dr2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr2_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr2_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr2_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR3 implementation


/// Register `DR3`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr3 { }

impl ADC_dr3 {
    
    // Getters
    /// Fetch the value of the `DR3` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr3_Get {
        ADC_dr3_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr3_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr3_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr3_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr3_Update {
        ADC_dr3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr3_Update<'a> {
        let mut setter: ADC_dr3_Update = ADC_dr3_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr3_Update<'a> {
        let mut setter: ADC_dr3_Update = ADC_dr3_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr3_Update<'a> {
        let mut setter: ADC_dr3_Update = ADC_dr3_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr3
/// `DR3`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr3_Get {
    value: u32,
}

impl ADC_dr3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr3) -> ADC_dr3_Get {
        ADC_dr3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr3_Get { }


// Updater for ADC_dr3
/// Updater for `DR3` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr3,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr3) -> ADC_dr3_Update<'a> {
        ADC_dr3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr3) -> ADC_dr3_Update<'a> {
        ADC_dr3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr3_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr3_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr3_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR4 implementation


/// Register `DR4`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr4 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr4 { }

impl ADC_dr4 {
    
    // Getters
    /// Fetch the value of the `DR4` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr4_Get {
        ADC_dr4_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr4_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr4_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr4_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR4` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr4_Update {
        ADC_dr4_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr4_Update<'a> {
        let mut setter: ADC_dr4_Update = ADC_dr4_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr4_Update<'a> {
        let mut setter: ADC_dr4_Update = ADC_dr4_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr4_Update<'a> {
        let mut setter: ADC_dr4_Update = ADC_dr4_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr4
/// `DR4`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr4_Get {
    value: u32,
}

impl ADC_dr4_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr4) -> ADC_dr4_Get {
        ADC_dr4_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr4_Get { }


// Updater for ADC_dr4
/// Updater for `DR4` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr4_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr4,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr4_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr4_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr4) -> ADC_dr4_Update<'a> {
        ADC_dr4_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr4) -> ADC_dr4_Update<'a> {
        ADC_dr4_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr4_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr4_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr4_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR5 implementation


/// Register `DR5`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr5 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr5 { }

impl ADC_dr5 {
    
    // Getters
    /// Fetch the value of the `DR5` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr5_Get {
        ADC_dr5_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr5_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr5_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr5_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR5` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr5_Update {
        ADC_dr5_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr5_Update<'a> {
        let mut setter: ADC_dr5_Update = ADC_dr5_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr5_Update<'a> {
        let mut setter: ADC_dr5_Update = ADC_dr5_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr5_Update<'a> {
        let mut setter: ADC_dr5_Update = ADC_dr5_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr5
/// `DR5`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr5_Get {
    value: u32,
}

impl ADC_dr5_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr5) -> ADC_dr5_Get {
        ADC_dr5_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr5_Get { }


// Updater for ADC_dr5
/// Updater for `DR5` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr5_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr5,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr5_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr5_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr5) -> ADC_dr5_Update<'a> {
        ADC_dr5_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr5) -> ADC_dr5_Update<'a> {
        ADC_dr5_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr5_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr5_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr5_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR6 implementation


/// Register `DR6`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr6 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr6 { }

impl ADC_dr6 {
    
    // Getters
    /// Fetch the value of the `DR6` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr6_Get {
        ADC_dr6_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr6_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr6_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr6_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR6` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr6_Update {
        ADC_dr6_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr6_Update<'a> {
        let mut setter: ADC_dr6_Update = ADC_dr6_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr6_Update<'a> {
        let mut setter: ADC_dr6_Update = ADC_dr6_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr6_Update<'a> {
        let mut setter: ADC_dr6_Update = ADC_dr6_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr6
/// `DR6`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr6_Get {
    value: u32,
}

impl ADC_dr6_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr6) -> ADC_dr6_Get {
        ADC_dr6_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr6_Get { }


// Updater for ADC_dr6
/// Updater for `DR6` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr6_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr6,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr6_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr6_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr6) -> ADC_dr6_Update<'a> {
        ADC_dr6_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr6) -> ADC_dr6_Update<'a> {
        ADC_dr6_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr6_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr6_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr6_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DR7 implementation


/// Register `DR7`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct ADC_dr7 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for ADC_dr7 { }

impl ADC_dr7 {
    
    // Getters
    /// Fetch the value of the `DR7` register.
    #[inline(always)]
    pub fn get(&self) -> ADC_dr7_Get {
        ADC_dr7_Get::new(self)
    }

    
    /// Get value of `V_VREF` field.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        ADC_dr7_Get::new(self).v_vref()
    }
    
    /// Get value of `OVERRUN` field.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        ADC_dr7_Get::new(self).overrun()
    }
    
    /// Get value of `DONE` field.
    #[inline(always)]
    pub fn done(&self) -> bool {
        ADC_dr7_Get::new(self).done()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR7` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> ADC_dr7_Update {
        ADC_dr7_Update::new_ignoring_state(self)
    }

    
    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'a>(&'a mut self, new_value: u32) -> ADC_dr7_Update<'a> {
        let mut setter: ADC_dr7_Update = ADC_dr7_Update::new(self);
        setter.set_v_vref(new_value);
        setter
    }
    
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'a>(&'a mut self, new_value: bool) -> ADC_dr7_Update<'a> {
        let mut setter: ADC_dr7_Update = ADC_dr7_Update::new(self);
        setter.set_overrun(new_value);
        setter
    }
    
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'a>(&'a mut self, new_value: bool) -> ADC_dr7_Update<'a> {
        let mut setter: ADC_dr7_Update = ADC_dr7_Update::new(self);
        setter.set_done(new_value);
        setter
    }
    

    }


// Getter for ADC_dr7
/// `DR7`: A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct ADC_dr7_Get {
    value: u32,
}

impl ADC_dr7_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &ADC_dr7) -> ADC_dr7_Get {
        ADC_dr7_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `V_VREF` field: When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF.
    #[inline(always)]
    pub fn v_vref(&self) -> u32 {
        (self.value >> 6) & 1023
        }
    /// Get value of `OVERRUN` field: This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register.
    #[inline(always)]
    pub fn overrun(&self) -> bool {
        (self.value >> 30) & 1 != 0
        }
    /// Get value of `DONE` field: This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read.
    #[inline(always)]
    pub fn done(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for ADC_dr7_Get { }


// Updater for ADC_dr7
/// Updater for `DR7` register.
#[allow(non_camel_case_types)]
pub struct ADC_dr7_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a ADC_dr7,
}

/// This performs the register update.
impl <'a> Drop for ADC_dr7_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> ADC_dr7_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a ADC_dr7) -> ADC_dr7_Update<'a> {
        ADC_dr7_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a ADC_dr7) -> ADC_dr7_Update<'a> {
        ADC_dr7_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `V_VREF` field.
    #[inline(always)]
    pub fn set_v_vref<'b>(&'b mut self, new_value: u32) -> &'b mut ADC_dr7_Update<'a> {
        self.value = (self.value & !(1023 << 6))
                   | ((new_value as u32) & 1023) << 6;
        self.mask |= 1023 << 6;
        self
    }
    /// Set value of `OVERRUN` field.
    #[inline(always)]
    pub fn set_overrun<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr7_Update<'a> {
        self.value = (self.value & !(1 << 30))
                   | ((new_value as u32) & 1) << 30;
        self.mask |= 1 << 30;
        self
    }
    /// Set value of `DONE` field.
    #[inline(always)]
    pub fn set_done<'b>(&'b mut self, new_value: bool) -> &'b mut ADC_dr7_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral ADC implementation

/// 10-bit ADC
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct ADC;

impl ADC {
    /// A/D Control Register. The ADCR register must be written to select the operating mode before A/D conversion can occur.
    #[inline(always)]
    pub fn cr() -> &'static mut ADC_cr {
        unsafe { ::core::intrinsics::transmute(0x4001c000 as usize) }
    }
    /// A/D Global Data Register. Contains the result of the most recent A/D conversion.
    #[inline(always)]
    pub fn gdr() -> &'static mut ADC_gdr {
        unsafe { ::core::intrinsics::transmute(0x4001c004 as usize) }
    }
    /// A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag.
    #[inline(always)]
    pub fn stat() -> &'static mut ADC_stat {
        unsafe { ::core::intrinsics::transmute(0x4001c030 as usize) }
    }
    /// A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt.
    #[inline(always)]
    pub fn inten() -> &'static mut ADC_inten {
        unsafe { ::core::intrinsics::transmute(0x4001c00c as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr0() -> &'static mut ADC_dr0 {
        unsafe { ::core::intrinsics::transmute(0x4001c010 as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr1() -> &'static mut ADC_dr1 {
        unsafe { ::core::intrinsics::transmute(0x4001c014 as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr2() -> &'static mut ADC_dr2 {
        unsafe { ::core::intrinsics::transmute(0x4001c018 as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr3() -> &'static mut ADC_dr3 {
        unsafe { ::core::intrinsics::transmute(0x4001c01c as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr4() -> &'static mut ADC_dr4 {
        unsafe { ::core::intrinsics::transmute(0x4001c020 as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr5() -> &'static mut ADC_dr5 {
        unsafe { ::core::intrinsics::transmute(0x4001c024 as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr6() -> &'static mut ADC_dr6 {
        unsafe { ::core::intrinsics::transmute(0x4001c028 as usize) }
    }
    /// A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n.
    #[inline(always)]
    pub fn dr7() -> &'static mut ADC_dr7 {
        unsafe { ::core::intrinsics::transmute(0x4001c02c as usize) }
    }
    }



// Registers for PMU





// Register PCON implementation


/// Register `PCON`: Power control register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct PMU_pcon {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for PMU_pcon { }

impl PMU_pcon {
    
    // Getters
    /// Fetch the value of the `PCON` register.
    #[inline(always)]
    pub fn get(&self) -> PMU_pcon_Get {
        PMU_pcon_Get::new(self)
    }

    
    /// Get value of `DPDEN` field.
    #[inline(always)]
    pub fn dpden(&self) -> PMU_pcon_dpden {
        PMU_pcon_Get::new(self).dpden()
    }
    
    /// Get value of `SLEEPFLAG` field.
    #[inline(always)]
    pub fn sleepflag(&self) -> PMU_pcon_sleepflag {
        PMU_pcon_Get::new(self).sleepflag()
    }
    
    /// Get value of `DPDFLAG` field.
    #[inline(always)]
    pub fn dpdflag(&self) -> PMU_pcon_dpdflag {
        PMU_pcon_Get::new(self).dpdflag()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PCON` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> PMU_pcon_Update {
        PMU_pcon_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DPDEN` field.
    #[inline(always)]
    pub fn set_dpden<'a>(&'a mut self, new_value: PMU_pcon_dpden) -> PMU_pcon_Update<'a> {
        let mut setter: PMU_pcon_Update = PMU_pcon_Update::new(self);
        setter.set_dpden(new_value);
        setter
    }
    
    /// Set value of `SLEEPFLAG` field.
    #[inline(always)]
    pub fn set_sleepflag<'a>(&'a mut self, new_value: PMU_pcon_sleepflag) -> PMU_pcon_Update<'a> {
        let mut setter: PMU_pcon_Update = PMU_pcon_Update::new(self);
        setter.set_sleepflag(new_value);
        setter
    }
    
    /// Set value of `DPDFLAG` field.
    #[inline(always)]
    pub fn set_dpdflag<'a>(&'a mut self, new_value: PMU_pcon_dpdflag) -> PMU_pcon_Update<'a> {
        let mut setter: PMU_pcon_Update = PMU_pcon_Update::new(self);
        setter.set_dpdflag(new_value);
        setter
    }
    

    }


// Getter for PMU_pcon
/// `PCON`: Power control register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct PMU_pcon_Get {
    value: u32,
}

impl PMU_pcon_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &PMU_pcon) -> PMU_pcon_Get {
        PMU_pcon_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DPDEN` field: Deep power-down mode enable
    #[inline(always)]
    pub fn dpden(&self) -> PMU_pcon_dpden {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(PMU_pcon_dpden::SleepMode),
            1 => ::core::option::Option::Some(PMU_pcon_dpden::DeepPowerDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SLEEPFLAG` field: Sleep mode flag
    #[inline(always)]
    pub fn sleepflag(&self) -> PMU_pcon_sleepflag {
        match (self.value >> 8) & 1 {
            0 => ::core::option::Option::Some(PMU_pcon_sleepflag::NoPowerDown),
            1 => ::core::option::Option::Some(PMU_pcon_sleepflag::PowerDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DPDFLAG` field: Deep power-down flag
    #[inline(always)]
    pub fn dpdflag(&self) -> PMU_pcon_dpdflag {
        match (self.value >> 11) & 1 {
            0 => ::core::option::Option::Some(PMU_pcon_dpdflag::NoDeepPowerDown),
            1 => ::core::option::Option::Some(PMU_pcon_dpdflag::DeepPowerDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for PMU_pcon_Get { }


// Updater for PMU_pcon
/// Updater for `PCON` register.
#[allow(non_camel_case_types)]
pub struct PMU_pcon_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a PMU_pcon,
}

/// This performs the register update.
impl <'a> Drop for PMU_pcon_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> PMU_pcon_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a PMU_pcon) -> PMU_pcon_Update<'a> {
        PMU_pcon_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a PMU_pcon) -> PMU_pcon_Update<'a> {
        PMU_pcon_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DPDEN` field.
    #[inline(always)]
    pub fn set_dpden<'b>(&'b mut self, new_value: PMU_pcon_dpden) -> &'b mut PMU_pcon_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `SLEEPFLAG` field.
    #[inline(always)]
    pub fn set_sleepflag<'b>(&'b mut self, new_value: PMU_pcon_sleepflag) -> &'b mut PMU_pcon_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `DPDFLAG` field.
    #[inline(always)]
    pub fn set_dpdflag<'b>(&'b mut self, new_value: PMU_pcon_dpdflag) -> &'b mut PMU_pcon_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum PMU_pcon_dpden {
    /// ARM WFI will enter Sleep or Deep-sleep mode (clock to ARM Cortex-M0 core turned off).
    SleepMode = 0,
    /// ARM WFI will enter Deep-power down mode (ARM Cortex-M0 core powered-down).
    DeepPowerDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum PMU_pcon_sleepflag {
    /// Read: No power-down mode entered. LPC111x/LPC11C1x is in Active mode. Write: No effect.
    NoPowerDown = 0,
    /// Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0.
    PowerDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum PMU_pcon_dpdflag {
    /// Read: Deep power-down mode  not entered. Write: No effect.
    NoDeepPowerDown = 0,
    /// Read: Deep power-down mode entered. Write: Clear the Deep power-down flag.
    DeepPowerDown = 1,
    }







// Register GPREG0 implementation


/// Register `GPREG0`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct PMU_gpreg0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for PMU_gpreg0 { }

impl PMU_gpreg0 {
    
    // Getters
    /// Fetch the value of the `GPREG0` register.
    #[inline(always)]
    pub fn get(&self) -> PMU_gpreg0_Get {
        PMU_gpreg0_Get::new(self)
    }

    
    /// Get value of `GPDATA` field.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        PMU_gpreg0_Get::new(self).gpdata()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `GPREG0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> PMU_gpreg0_Update {
        PMU_gpreg0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'a>(&'a mut self, new_value: u32) -> PMU_gpreg0_Update<'a> {
        let mut setter: PMU_gpreg0_Update = PMU_gpreg0_Update::new(self);
        setter.set_gpdata(new_value);
        setter
    }
    

    }


// Getter for PMU_gpreg0
/// `GPREG0`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct PMU_gpreg0_Get {
    value: u32,
}

impl PMU_gpreg0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &PMU_gpreg0) -> PMU_gpreg0_Get {
        PMU_gpreg0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GPDATA` field: Data retained during Deep power-down mode.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for PMU_gpreg0_Get { }


// Updater for PMU_gpreg0
/// Updater for `GPREG0` register.
#[allow(non_camel_case_types)]
pub struct PMU_gpreg0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a PMU_gpreg0,
}

/// This performs the register update.
impl <'a> Drop for PMU_gpreg0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> PMU_gpreg0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a PMU_gpreg0) -> PMU_gpreg0_Update<'a> {
        PMU_gpreg0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a PMU_gpreg0) -> PMU_gpreg0_Update<'a> {
        PMU_gpreg0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'b>(&'b mut self, new_value: u32) -> &'b mut PMU_gpreg0_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register GPREG1 implementation


/// Register `GPREG1`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct PMU_gpreg1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for PMU_gpreg1 { }

impl PMU_gpreg1 {
    
    // Getters
    /// Fetch the value of the `GPREG1` register.
    #[inline(always)]
    pub fn get(&self) -> PMU_gpreg1_Get {
        PMU_gpreg1_Get::new(self)
    }

    
    /// Get value of `GPDATA` field.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        PMU_gpreg1_Get::new(self).gpdata()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `GPREG1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> PMU_gpreg1_Update {
        PMU_gpreg1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'a>(&'a mut self, new_value: u32) -> PMU_gpreg1_Update<'a> {
        let mut setter: PMU_gpreg1_Update = PMU_gpreg1_Update::new(self);
        setter.set_gpdata(new_value);
        setter
    }
    

    }


// Getter for PMU_gpreg1
/// `GPREG1`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct PMU_gpreg1_Get {
    value: u32,
}

impl PMU_gpreg1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &PMU_gpreg1) -> PMU_gpreg1_Get {
        PMU_gpreg1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GPDATA` field: Data retained during Deep power-down mode.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for PMU_gpreg1_Get { }


// Updater for PMU_gpreg1
/// Updater for `GPREG1` register.
#[allow(non_camel_case_types)]
pub struct PMU_gpreg1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a PMU_gpreg1,
}

/// This performs the register update.
impl <'a> Drop for PMU_gpreg1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> PMU_gpreg1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a PMU_gpreg1) -> PMU_gpreg1_Update<'a> {
        PMU_gpreg1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a PMU_gpreg1) -> PMU_gpreg1_Update<'a> {
        PMU_gpreg1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'b>(&'b mut self, new_value: u32) -> &'b mut PMU_gpreg1_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register GPREG2 implementation


/// Register `GPREG2`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct PMU_gpreg2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for PMU_gpreg2 { }

impl PMU_gpreg2 {
    
    // Getters
    /// Fetch the value of the `GPREG2` register.
    #[inline(always)]
    pub fn get(&self) -> PMU_gpreg2_Get {
        PMU_gpreg2_Get::new(self)
    }

    
    /// Get value of `GPDATA` field.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        PMU_gpreg2_Get::new(self).gpdata()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `GPREG2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> PMU_gpreg2_Update {
        PMU_gpreg2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'a>(&'a mut self, new_value: u32) -> PMU_gpreg2_Update<'a> {
        let mut setter: PMU_gpreg2_Update = PMU_gpreg2_Update::new(self);
        setter.set_gpdata(new_value);
        setter
    }
    

    }


// Getter for PMU_gpreg2
/// `GPREG2`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct PMU_gpreg2_Get {
    value: u32,
}

impl PMU_gpreg2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &PMU_gpreg2) -> PMU_gpreg2_Get {
        PMU_gpreg2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GPDATA` field: Data retained during Deep power-down mode.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for PMU_gpreg2_Get { }


// Updater for PMU_gpreg2
/// Updater for `GPREG2` register.
#[allow(non_camel_case_types)]
pub struct PMU_gpreg2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a PMU_gpreg2,
}

/// This performs the register update.
impl <'a> Drop for PMU_gpreg2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> PMU_gpreg2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a PMU_gpreg2) -> PMU_gpreg2_Update<'a> {
        PMU_gpreg2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a PMU_gpreg2) -> PMU_gpreg2_Update<'a> {
        PMU_gpreg2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'b>(&'b mut self, new_value: u32) -> &'b mut PMU_gpreg2_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register GPREG3 implementation


/// Register `GPREG3`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct PMU_gpreg3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for PMU_gpreg3 { }

impl PMU_gpreg3 {
    
    // Getters
    /// Fetch the value of the `GPREG3` register.
    #[inline(always)]
    pub fn get(&self) -> PMU_gpreg3_Get {
        PMU_gpreg3_Get::new(self)
    }

    
    /// Get value of `GPDATA` field.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        PMU_gpreg3_Get::new(self).gpdata()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `GPREG3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> PMU_gpreg3_Update {
        PMU_gpreg3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'a>(&'a mut self, new_value: u32) -> PMU_gpreg3_Update<'a> {
        let mut setter: PMU_gpreg3_Update = PMU_gpreg3_Update::new(self);
        setter.set_gpdata(new_value);
        setter
    }
    

    }


// Getter for PMU_gpreg3
/// `GPREG3`: General purpose register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct PMU_gpreg3_Get {
    value: u32,
}

impl PMU_gpreg3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &PMU_gpreg3) -> PMU_gpreg3_Get {
        PMU_gpreg3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `GPDATA` field: Data retained during Deep power-down mode.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for PMU_gpreg3_Get { }


// Updater for PMU_gpreg3
/// Updater for `GPREG3` register.
#[allow(non_camel_case_types)]
pub struct PMU_gpreg3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a PMU_gpreg3,
}

/// This performs the register update.
impl <'a> Drop for PMU_gpreg3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> PMU_gpreg3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a PMU_gpreg3) -> PMU_gpreg3_Update<'a> {
        PMU_gpreg3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a PMU_gpreg3) -> PMU_gpreg3_Update<'a> {
        PMU_gpreg3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'b>(&'b mut self, new_value: u32) -> &'b mut PMU_gpreg3_Update<'a> {
        self.value = (self.value & !(4294967295 << 0))
                   | ((new_value as u32) & 4294967295) << 0;
        self.mask |= 4294967295 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register GPREG4 implementation


/// Register `GPREG4`: General purpose register 4
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct PMU_gpreg4 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for PMU_gpreg4 { }

impl PMU_gpreg4 {
    
    // Getters
    /// Fetch the value of the `GPREG4` register.
    #[inline(always)]
    pub fn get(&self) -> PMU_gpreg4_Get {
        PMU_gpreg4_Get::new(self)
    }

    
    /// Get value of `WAKEUPHYS` field.
    #[inline(always)]
    pub fn wakeuphys(&self) -> PMU_gpreg4_wakeuphys {
        PMU_gpreg4_Get::new(self).wakeuphys()
    }
    
    /// Get value of `GPDATA` field.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        PMU_gpreg4_Get::new(self).gpdata()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `GPREG4` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> PMU_gpreg4_Update {
        PMU_gpreg4_Update::new_ignoring_state(self)
    }

    
    /// Set value of `WAKEUPHYS` field.
    #[inline(always)]
    pub fn set_wakeuphys<'a>(&'a mut self, new_value: PMU_gpreg4_wakeuphys) -> PMU_gpreg4_Update<'a> {
        let mut setter: PMU_gpreg4_Update = PMU_gpreg4_Update::new(self);
        setter.set_wakeuphys(new_value);
        setter
    }
    
    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'a>(&'a mut self, new_value: u32) -> PMU_gpreg4_Update<'a> {
        let mut setter: PMU_gpreg4_Update = PMU_gpreg4_Update::new(self);
        setter.set_gpdata(new_value);
        setter
    }
    

    }


// Getter for PMU_gpreg4
/// `GPREG4`: General purpose register 4
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct PMU_gpreg4_Get {
    value: u32,
}

impl PMU_gpreg4_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &PMU_gpreg4) -> PMU_gpreg4_Get {
        PMU_gpreg4_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `WAKEUPHYS` field: WAKEUP pin hysteresis enable
    #[inline(always)]
    pub fn wakeuphys(&self) -> PMU_gpreg4_wakeuphys {
        match (self.value >> 10) & 1 {
            1 => ::core::option::Option::Some(PMU_gpreg4_wakeuphys::Enabled),
            0 => ::core::option::Option::Some(PMU_gpreg4_wakeuphys::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `GPDATA` field: Data retained during Deep power-down mode.
    #[inline(always)]
    pub fn gpdata(&self) -> u32 {
        (self.value >> 11) & 2097151
        }
    }

impl ::core::marker::Copy for PMU_gpreg4_Get { }


// Updater for PMU_gpreg4
/// Updater for `GPREG4` register.
#[allow(non_camel_case_types)]
pub struct PMU_gpreg4_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a PMU_gpreg4,
}

/// This performs the register update.
impl <'a> Drop for PMU_gpreg4_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> PMU_gpreg4_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a PMU_gpreg4) -> PMU_gpreg4_Update<'a> {
        PMU_gpreg4_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a PMU_gpreg4) -> PMU_gpreg4_Update<'a> {
        PMU_gpreg4_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `WAKEUPHYS` field.
    #[inline(always)]
    pub fn set_wakeuphys<'b>(&'b mut self, new_value: PMU_gpreg4_wakeuphys) -> &'b mut PMU_gpreg4_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `GPDATA` field.
    #[inline(always)]
    pub fn set_gpdata<'b>(&'b mut self, new_value: u32) -> &'b mut PMU_gpreg4_Update<'a> {
        self.value = (self.value & !(2097151 << 11))
                   | ((new_value as u32) & 2097151) << 11;
        self.mask |= 2097151 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum PMU_gpreg4_wakeuphys {
    /// Hysteresis for WAKEUP pin enabled.
    Enabled = 1,
    /// Hysteresis for WAKUP pin disabled.
    Disabled = 0,
    }





// Peripheral PMU implementation

/// power management unit
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct PMU;

impl PMU {
    /// Power control register
    #[inline(always)]
    pub fn pcon() -> &'static mut PMU_pcon {
        unsafe { ::core::intrinsics::transmute(0x40038000 as usize) }
    }
    /// General purpose register
    #[inline(always)]
    pub fn gpreg0() -> &'static mut PMU_gpreg0 {
        unsafe { ::core::intrinsics::transmute(0x40038004 as usize) }
    }
    /// General purpose register
    #[inline(always)]
    pub fn gpreg1() -> &'static mut PMU_gpreg1 {
        unsafe { ::core::intrinsics::transmute(0x40038008 as usize) }
    }
    /// General purpose register
    #[inline(always)]
    pub fn gpreg2() -> &'static mut PMU_gpreg2 {
        unsafe { ::core::intrinsics::transmute(0x4003800c as usize) }
    }
    /// General purpose register
    #[inline(always)]
    pub fn gpreg3() -> &'static mut PMU_gpreg3 {
        unsafe { ::core::intrinsics::transmute(0x40038010 as usize) }
    }
    /// General purpose register 4
    #[inline(always)]
    pub fn gpreg4() -> &'static mut PMU_gpreg4 {
        unsafe { ::core::intrinsics::transmute(0x40038014 as usize) }
    }
    }



// Registers for FLASHCTRL





// Register FLASHCFG implementation


/// Register `FLASHCFG`: Flash memory access time configuration register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_flashcfg {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_flashcfg { }

impl FLASHCTRL_flashcfg {
    
    // Getters
    /// Fetch the value of the `FLASHCFG` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_flashcfg_Get {
        FLASHCTRL_flashcfg_Get::new(self)
    }

    
    /// Get value of `FLASHTIM` field.
    #[inline(always)]
    pub fn flashtim(&self) -> FLASHCTRL_flashcfg_flashtim {
        FLASHCTRL_flashcfg_Get::new(self).flashtim()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `FLASHCFG` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> FLASHCTRL_flashcfg_Update {
        FLASHCTRL_flashcfg_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FLASHTIM` field.
    #[inline(always)]
    pub fn set_flashtim<'a>(&'a mut self, new_value: FLASHCTRL_flashcfg_flashtim) -> FLASHCTRL_flashcfg_Update<'a> {
        let mut setter: FLASHCTRL_flashcfg_Update = FLASHCTRL_flashcfg_Update::new(self);
        setter.set_flashtim(new_value);
        setter
    }
    

    }


// Getter for FLASHCTRL_flashcfg
/// `FLASHCFG`: Flash memory access time configuration register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_flashcfg_Get {
    value: u32,
}

impl FLASHCTRL_flashcfg_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_flashcfg) -> FLASHCTRL_flashcfg_Get {
        FLASHCTRL_flashcfg_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FLASHTIM` field: Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access.
    #[inline(always)]
    pub fn flashtim(&self) -> FLASHCTRL_flashcfg_flashtim {
        match (self.value >> 0) & 3 {
            1 => ::core::option::Option::Some(FLASHCTRL_flashcfg_flashtim::FlashAccessTime1SCLK),
            2 => ::core::option::Option::Some(FLASHCTRL_flashcfg_flashtim::FlashAccessTime2SCLK),
            3 => ::core::option::Option::Some(FLASHCTRL_flashcfg_flashtim::FlashAccessTime3SCLK),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for FLASHCTRL_flashcfg_Get { }


// Updater for FLASHCTRL_flashcfg
/// Updater for `FLASHCFG` register.
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_flashcfg_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a FLASHCTRL_flashcfg,
}

/// This performs the register update.
impl <'a> Drop for FLASHCTRL_flashcfg_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> FLASHCTRL_flashcfg_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a FLASHCTRL_flashcfg) -> FLASHCTRL_flashcfg_Update<'a> {
        FLASHCTRL_flashcfg_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a FLASHCTRL_flashcfg) -> FLASHCTRL_flashcfg_Update<'a> {
        FLASHCTRL_flashcfg_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FLASHTIM` field.
    #[inline(always)]
    pub fn set_flashtim<'b>(&'b mut self, new_value: FLASHCTRL_flashcfg_flashtim) -> &'b mut FLASHCTRL_flashcfg_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum FLASHCTRL_flashcfg_flashtim {
    /// 1 system clock flash access time (for system clock frequencies of up to 20 MHz).
    FlashAccessTime1SCLK = 1,
    /// 2 system clocks flash access time (for system clock frequencies of up to 40 MHz).
    FlashAccessTime2SCLK = 2,
    /// 3 system clocks flash access time (for system clock frequencies of up to 50 MHz).
    FlashAccessTime3SCLK = 3,
    }







// Register FMSSTART implementation


/// Register `FMSSTART`: Signature start address register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmsstart {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmsstart { }

impl FLASHCTRL_fmsstart {
    
    // Getters
    /// Fetch the value of the `FMSSTART` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_fmsstart_Get {
        FLASHCTRL_fmsstart_Get::new(self)
    }

    
    /// Get value of `START` field.
    #[inline(always)]
    pub fn start(&self) -> u32 {
        FLASHCTRL_fmsstart_Get::new(self).start()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `FMSSTART` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> FLASHCTRL_fmsstart_Update {
        FLASHCTRL_fmsstart_Update::new_ignoring_state(self)
    }

    
    /// Set value of `START` field.
    #[inline(always)]
    pub fn set_start<'a>(&'a mut self, new_value: u32) -> FLASHCTRL_fmsstart_Update<'a> {
        let mut setter: FLASHCTRL_fmsstart_Update = FLASHCTRL_fmsstart_Update::new(self);
        setter.set_start(new_value);
        setter
    }
    

    }


// Getter for FLASHCTRL_fmsstart
/// `FMSSTART`: Signature start address register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsstart_Get {
    value: u32,
}

impl FLASHCTRL_fmsstart_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_fmsstart) -> FLASHCTRL_fmsstart_Get {
        FLASHCTRL_fmsstart_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `START` field: Signature generation start address (corresponds to AHB byte address bits[20:4]).
    #[inline(always)]
    pub fn start(&self) -> u32 {
        (self.value >> 0) & 131071
        }
    }

impl ::core::marker::Copy for FLASHCTRL_fmsstart_Get { }


// Updater for FLASHCTRL_fmsstart
/// Updater for `FMSSTART` register.
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsstart_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a FLASHCTRL_fmsstart,
}

/// This performs the register update.
impl <'a> Drop for FLASHCTRL_fmsstart_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> FLASHCTRL_fmsstart_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a FLASHCTRL_fmsstart) -> FLASHCTRL_fmsstart_Update<'a> {
        FLASHCTRL_fmsstart_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a FLASHCTRL_fmsstart) -> FLASHCTRL_fmsstart_Update<'a> {
        FLASHCTRL_fmsstart_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `START` field.
    #[inline(always)]
    pub fn set_start<'b>(&'b mut self, new_value: u32) -> &'b mut FLASHCTRL_fmsstart_Update<'a> {
        self.value = (self.value & !(131071 << 0))
                   | ((new_value as u32) & 131071) << 0;
        self.mask |= 131071 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register FMSSTOP implementation


/// Register `FMSSTOP`: Signature stop-address register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmsstop {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmsstop { }

impl FLASHCTRL_fmsstop {
    
    // Getters
    /// Fetch the value of the `FMSSTOP` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_fmsstop_Get {
        FLASHCTRL_fmsstop_Get::new(self)
    }

    
    /// Get value of `STOP` field.
    #[inline(always)]
    pub fn stop(&self) -> u32 {
        FLASHCTRL_fmsstop_Get::new(self).stop()
    }
    
    /// Get value of `SIG_START` field.
    #[inline(always)]
    pub fn sig_start(&self) -> FLASHCTRL_fmsstop_sig_start {
        FLASHCTRL_fmsstop_Get::new(self).sig_start()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `FMSSTOP` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> FLASHCTRL_fmsstop_Update {
        FLASHCTRL_fmsstop_Update::new_ignoring_state(self)
    }

    
    /// Set value of `STOP` field.
    #[inline(always)]
    pub fn set_stop<'a>(&'a mut self, new_value: u32) -> FLASHCTRL_fmsstop_Update<'a> {
        let mut setter: FLASHCTRL_fmsstop_Update = FLASHCTRL_fmsstop_Update::new(self);
        setter.set_stop(new_value);
        setter
    }
    
    /// Set value of `SIG_START` field.
    #[inline(always)]
    pub fn set_sig_start<'a>(&'a mut self, new_value: FLASHCTRL_fmsstop_sig_start) -> FLASHCTRL_fmsstop_Update<'a> {
        let mut setter: FLASHCTRL_fmsstop_Update = FLASHCTRL_fmsstop_Update::new(self);
        setter.set_sig_start(new_value);
        setter
    }
    

    }


// Getter for FLASHCTRL_fmsstop
/// `FMSSTOP`: Signature stop-address register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsstop_Get {
    value: u32,
}

impl FLASHCTRL_fmsstop_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_fmsstop) -> FLASHCTRL_fmsstop_Get {
        FLASHCTRL_fmsstop_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `STOP` field: BIST stop address divided by 16 (corresponds to AHB byte address [20:4]).
    #[inline(always)]
    pub fn stop(&self) -> u32 {
        (self.value >> 0) & 131071
        }
    /// Get value of `SIG_START` field: Start control bit for signature generation.
    #[inline(always)]
    pub fn sig_start(&self) -> FLASHCTRL_fmsstop_sig_start {
        match (self.value >> 17) & 1 {
            0 => ::core::option::Option::Some(FLASHCTRL_fmsstop_sig_start::Stopped),
            1 => ::core::option::Option::Some(FLASHCTRL_fmsstop_sig_start::InitiateSignatureGeneration),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for FLASHCTRL_fmsstop_Get { }


// Updater for FLASHCTRL_fmsstop
/// Updater for `FMSSTOP` register.
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsstop_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a FLASHCTRL_fmsstop,
}

/// This performs the register update.
impl <'a> Drop for FLASHCTRL_fmsstop_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> FLASHCTRL_fmsstop_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a FLASHCTRL_fmsstop) -> FLASHCTRL_fmsstop_Update<'a> {
        FLASHCTRL_fmsstop_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a FLASHCTRL_fmsstop) -> FLASHCTRL_fmsstop_Update<'a> {
        FLASHCTRL_fmsstop_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `STOP` field.
    #[inline(always)]
    pub fn set_stop<'b>(&'b mut self, new_value: u32) -> &'b mut FLASHCTRL_fmsstop_Update<'a> {
        self.value = (self.value & !(131071 << 0))
                   | ((new_value as u32) & 131071) << 0;
        self.mask |= 131071 << 0;
        self
    }
    /// Set value of `SIG_START` field.
    #[inline(always)]
    pub fn set_sig_start<'b>(&'b mut self, new_value: FLASHCTRL_fmsstop_sig_start) -> &'b mut FLASHCTRL_fmsstop_Update<'a> {
        self.value = (self.value & !(1 << 17))
                   | ((new_value as u32) & 1) << 17;
        self.mask |= 1 << 17;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum FLASHCTRL_fmsstop_sig_start {
    /// Signature generation is stopped
    Stopped = 0,
    /// Initiate signature generation
    InitiateSignatureGeneration = 1,
    }







// Register FMSW0 implementation


/// Register `FMSW0`: Word 0 [31:0]
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmsw0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmsw0 { }

impl FLASHCTRL_fmsw0 {
    
    // Getters
    /// Fetch the value of the `FMSW0` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_fmsw0_Get {
        FLASHCTRL_fmsw0_Get::new(self)
    }

    
    /// Get value of `SW0_31_0` field.
    #[inline(always)]
    pub fn sw0_31_0(&self) -> u32 {
        FLASHCTRL_fmsw0_Get::new(self).sw0_31_0()
    }
    

    }


// Getter for FLASHCTRL_fmsw0
/// `FMSW0`: Word 0 [31:0]
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsw0_Get {
    value: u32,
}

impl FLASHCTRL_fmsw0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_fmsw0) -> FLASHCTRL_fmsw0_Get {
        FLASHCTRL_fmsw0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SW0_31_0` field: Word 0 of 128-bit signature (bits 31 to 0).
    #[inline(always)]
    pub fn sw0_31_0(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for FLASHCTRL_fmsw0_Get { }







// Register FMSW1 implementation


/// Register `FMSW1`: Word 1 [63:32]
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmsw1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmsw1 { }

impl FLASHCTRL_fmsw1 {
    
    // Getters
    /// Fetch the value of the `FMSW1` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_fmsw1_Get {
        FLASHCTRL_fmsw1_Get::new(self)
    }

    
    /// Get value of `SW1_63_32` field.
    #[inline(always)]
    pub fn sw1_63_32(&self) -> u32 {
        FLASHCTRL_fmsw1_Get::new(self).sw1_63_32()
    }
    

    }


// Getter for FLASHCTRL_fmsw1
/// `FMSW1`: Word 1 [63:32]
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsw1_Get {
    value: u32,
}

impl FLASHCTRL_fmsw1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_fmsw1) -> FLASHCTRL_fmsw1_Get {
        FLASHCTRL_fmsw1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SW1_63_32` field: Word 1 of 128-bit signature (bits 63 to 32).
    #[inline(always)]
    pub fn sw1_63_32(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for FLASHCTRL_fmsw1_Get { }







// Register FMSW2 implementation


/// Register `FMSW2`: Word 2 [95:64]
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmsw2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmsw2 { }

impl FLASHCTRL_fmsw2 {
    
    // Getters
    /// Fetch the value of the `FMSW2` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_fmsw2_Get {
        FLASHCTRL_fmsw2_Get::new(self)
    }

    
    /// Get value of `SW2_95_64` field.
    #[inline(always)]
    pub fn sw2_95_64(&self) -> u32 {
        FLASHCTRL_fmsw2_Get::new(self).sw2_95_64()
    }
    

    }


// Getter for FLASHCTRL_fmsw2
/// `FMSW2`: Word 2 [95:64]
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsw2_Get {
    value: u32,
}

impl FLASHCTRL_fmsw2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_fmsw2) -> FLASHCTRL_fmsw2_Get {
        FLASHCTRL_fmsw2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SW2_95_64` field: Word 2 of 128-bit signature (bits 95 to 64).
    #[inline(always)]
    pub fn sw2_95_64(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for FLASHCTRL_fmsw2_Get { }







// Register FMSW3 implementation


/// Register `FMSW3`: Word 3 [127:96]
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmsw3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmsw3 { }

impl FLASHCTRL_fmsw3 {
    
    // Getters
    /// Fetch the value of the `FMSW3` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_fmsw3_Get {
        FLASHCTRL_fmsw3_Get::new(self)
    }

    
    /// Get value of `SW3_127_96` field.
    #[inline(always)]
    pub fn sw3_127_96(&self) -> u32 {
        FLASHCTRL_fmsw3_Get::new(self).sw3_127_96()
    }
    

    }


// Getter for FLASHCTRL_fmsw3
/// `FMSW3`: Word 3 [127:96]
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmsw3_Get {
    value: u32,
}

impl FLASHCTRL_fmsw3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_fmsw3) -> FLASHCTRL_fmsw3_Get {
        FLASHCTRL_fmsw3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SW3_127_96` field: Word 3 of 128-bit signature (bits 127 to 96).
    #[inline(always)]
    pub fn sw3_127_96(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for FLASHCTRL_fmsw3_Get { }







// Register FMSTAT implementation


/// Register `FMSTAT`: Signature generation status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmstat {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmstat { }

impl FLASHCTRL_fmstat {
    
    // Getters
    /// Fetch the value of the `FMSTAT` register.
    #[inline(always)]
    pub fn get(&self) -> FLASHCTRL_fmstat_Get {
        FLASHCTRL_fmstat_Get::new(self)
    }

    
    /// Get value of `SIG_DONE` field.
    #[inline(always)]
    pub fn sig_done(&self) -> bool {
        FLASHCTRL_fmstat_Get::new(self).sig_done()
    }
    

    }


// Getter for FLASHCTRL_fmstat
/// `FMSTAT`: Signature generation status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmstat_Get {
    value: u32,
}

impl FLASHCTRL_fmstat_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &FLASHCTRL_fmstat) -> FLASHCTRL_fmstat_Get {
        FLASHCTRL_fmstat_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SIG_DONE` field: When 1, a previously started signature generation has completed. See FMSTATCLR register description for clearing this flag.
    #[inline(always)]
    pub fn sig_done(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    }

impl ::core::marker::Copy for FLASHCTRL_fmstat_Get { }







// Register FMSTATCLR implementation


/// Register `FMSTATCLR`: Signature generation status clear register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct FLASHCTRL_fmstatclr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for FLASHCTRL_fmstatclr { }

impl FLASHCTRL_fmstatclr {
    
    // Setters
    /// Create new updater that ignores current value of the `FMSTATCLR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> FLASHCTRL_fmstatclr_Update {
        FLASHCTRL_fmstatclr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SIG_DONE_CLR` field.
    #[inline(always)]
    pub fn set_sig_done_clr<'a>(&'a mut self, new_value: bool) -> FLASHCTRL_fmstatclr_Update<'a> {
        let mut setter: FLASHCTRL_fmstatclr_Update = FLASHCTRL_fmstatclr_Update::new(self);
        setter.set_sig_done_clr(new_value);
        setter
    }
    

    }


// Updater for FLASHCTRL_fmstatclr
/// Updater for `FMSTATCLR` register.
#[allow(non_camel_case_types)]
pub struct FLASHCTRL_fmstatclr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a FLASHCTRL_fmstatclr,
}

/// This performs the register update.
impl <'a> Drop for FLASHCTRL_fmstatclr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> FLASHCTRL_fmstatclr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a FLASHCTRL_fmstatclr) -> FLASHCTRL_fmstatclr_Update<'a> {
        FLASHCTRL_fmstatclr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a FLASHCTRL_fmstatclr) -> FLASHCTRL_fmstatclr_Update<'a> {
        FLASHCTRL_fmstatclr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SIG_DONE_CLR` field.
    #[inline(always)]
    pub fn set_sig_done_clr<'b>(&'b mut self, new_value: bool) -> &'b mut FLASHCTRL_fmstatclr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral FLASHCTRL implementation

/// Product name title=UM10462 Chapter title=LPC11U1x Flash programming firmware Modification date=3/17/2011 Major revision=0 Minor revision=3 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct FLASHCTRL;

impl FLASHCTRL {
    /// Flash memory access time configuration register
    #[inline(always)]
    pub fn flashcfg() -> &'static mut FLASHCTRL_flashcfg {
        unsafe { ::core::intrinsics::transmute(0x4003c010 as usize) }
    }
    /// Signature start address register
    #[inline(always)]
    pub fn fmsstart() -> &'static mut FLASHCTRL_fmsstart {
        unsafe { ::core::intrinsics::transmute(0x4003c020 as usize) }
    }
    /// Signature stop-address register
    #[inline(always)]
    pub fn fmsstop() -> &'static mut FLASHCTRL_fmsstop {
        unsafe { ::core::intrinsics::transmute(0x4003c024 as usize) }
    }
    /// Word 0 [31:0]
    #[inline(always)]
    pub fn fmsw0() -> &'static mut FLASHCTRL_fmsw0 {
        unsafe { ::core::intrinsics::transmute(0x4003c02c as usize) }
    }
    /// Word 1 [63:32]
    #[inline(always)]
    pub fn fmsw1() -> &'static mut FLASHCTRL_fmsw1 {
        unsafe { ::core::intrinsics::transmute(0x4003c030 as usize) }
    }
    /// Word 2 [95:64]
    #[inline(always)]
    pub fn fmsw2() -> &'static mut FLASHCTRL_fmsw2 {
        unsafe { ::core::intrinsics::transmute(0x4003c034 as usize) }
    }
    /// Word 3 [127:96]
    #[inline(always)]
    pub fn fmsw3() -> &'static mut FLASHCTRL_fmsw3 {
        unsafe { ::core::intrinsics::transmute(0x4003c038 as usize) }
    }
    /// Signature generation status register
    #[inline(always)]
    pub fn fmstat() -> &'static mut FLASHCTRL_fmstat {
        unsafe { ::core::intrinsics::transmute(0x4003cfe0 as usize) }
    }
    /// Signature generation status clear register
    #[inline(always)]
    pub fn fmstatclr() -> &'static mut FLASHCTRL_fmstatclr {
        unsafe { ::core::intrinsics::transmute(0x4003cfe8 as usize) }
    }
    }



// Registers for SPI0





// Register CR0 implementation


/// Register `CR0`: Control Register 0. Selects the serial clock rate, bus type, and data size.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_cr0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_cr0 { }

impl SPI0_cr0 {
    
    // Getters
    /// Fetch the value of the `CR0` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_cr0_Get {
        SPI0_cr0_Get::new(self)
    }

    
    /// Get value of `DSS` field.
    #[inline(always)]
    pub fn dss(&self) -> SPI0_cr0_dss {
        SPI0_cr0_Get::new(self).dss()
    }
    
    /// Get value of `FRF` field.
    #[inline(always)]
    pub fn frf(&self) -> SPI0_cr0_frf {
        SPI0_cr0_Get::new(self).frf()
    }
    
    /// Get value of `CPOL` field.
    #[inline(always)]
    pub fn cpol(&self) -> SPI0_cr0_cpol {
        SPI0_cr0_Get::new(self).cpol()
    }
    
    /// Get value of `CPHA` field.
    #[inline(always)]
    pub fn cpha(&self) -> SPI0_cr0_cpha {
        SPI0_cr0_Get::new(self).cpha()
    }
    
    /// Get value of `SCR` field.
    #[inline(always)]
    pub fn scr(&self) -> u32 {
        SPI0_cr0_Get::new(self).scr()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CR0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SPI0_cr0_Update {
        SPI0_cr0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DSS` field.
    #[inline(always)]
    pub fn set_dss<'a>(&'a mut self, new_value: SPI0_cr0_dss) -> SPI0_cr0_Update<'a> {
        let mut setter: SPI0_cr0_Update = SPI0_cr0_Update::new(self);
        setter.set_dss(new_value);
        setter
    }
    
    /// Set value of `FRF` field.
    #[inline(always)]
    pub fn set_frf<'a>(&'a mut self, new_value: SPI0_cr0_frf) -> SPI0_cr0_Update<'a> {
        let mut setter: SPI0_cr0_Update = SPI0_cr0_Update::new(self);
        setter.set_frf(new_value);
        setter
    }
    
    /// Set value of `CPOL` field.
    #[inline(always)]
    pub fn set_cpol<'a>(&'a mut self, new_value: SPI0_cr0_cpol) -> SPI0_cr0_Update<'a> {
        let mut setter: SPI0_cr0_Update = SPI0_cr0_Update::new(self);
        setter.set_cpol(new_value);
        setter
    }
    
    /// Set value of `CPHA` field.
    #[inline(always)]
    pub fn set_cpha<'a>(&'a mut self, new_value: SPI0_cr0_cpha) -> SPI0_cr0_Update<'a> {
        let mut setter: SPI0_cr0_Update = SPI0_cr0_Update::new(self);
        setter.set_cpha(new_value);
        setter
    }
    
    /// Set value of `SCR` field.
    #[inline(always)]
    pub fn set_scr<'a>(&'a mut self, new_value: u32) -> SPI0_cr0_Update<'a> {
        let mut setter: SPI0_cr0_Update = SPI0_cr0_Update::new(self);
        setter.set_scr(new_value);
        setter
    }
    

    }


// Getter for SPI0_cr0
/// `CR0`: Control Register 0. Selects the serial clock rate, bus type, and data size.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_cr0_Get {
    value: u32,
}

impl SPI0_cr0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_cr0) -> SPI0_cr0_Get {
        SPI0_cr0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DSS` field: Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used.
    #[inline(always)]
    pub fn dss(&self) -> SPI0_cr0_dss {
        match (self.value >> 0) & 15 {
            3 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize4Bits),
            4 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize5Bits),
            5 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize6Bits),
            6 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize7Bits),
            7 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize8Bits),
            8 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize9Bits),
            9 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize10Bits),
            10 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize11Bits),
            11 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize12Bits),
            12 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize13Bits),
            13 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize14Bits),
            14 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize15Bits),
            15 => ::core::option::Option::Some(SPI0_cr0_dss::DataSize16Bits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FRF` field: Frame Format.
    #[inline(always)]
    pub fn frf(&self) -> SPI0_cr0_frf {
        match (self.value >> 4) & 3 {
            0 => ::core::option::Option::Some(SPI0_cr0_frf::SPI),
            1 => ::core::option::Option::Some(SPI0_cr0_frf::TI),
            2 => ::core::option::Option::Some(SPI0_cr0_frf::Microwire),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CPOL` field: Clock Out Polarity. This bit is only used in SPI mode.
    #[inline(always)]
    pub fn cpol(&self) -> SPI0_cr0_cpol {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(SPI0_cr0_cpol::Low),
            1 => ::core::option::Option::Some(SPI0_cr0_cpol::High),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CPHA` field: Clock Out Phase. This bit is only used in SPI mode.
    #[inline(always)]
    pub fn cpha(&self) -> SPI0_cr0_cpha {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(SPI0_cr0_cpha::FirstClock),
            1 => ::core::option::Option::Some(SPI0_cr0_cpha::SecondClock),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SCR` field: Serial Clock Rate. The number of prescaler output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR X [SCR+1]).
    #[inline(always)]
    pub fn scr(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for SPI0_cr0_Get { }


// Updater for SPI0_cr0
/// Updater for `CR0` register.
#[allow(non_camel_case_types)]
pub struct SPI0_cr0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SPI0_cr0,
}

/// This performs the register update.
impl <'a> Drop for SPI0_cr0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SPI0_cr0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SPI0_cr0) -> SPI0_cr0_Update<'a> {
        SPI0_cr0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SPI0_cr0) -> SPI0_cr0_Update<'a> {
        SPI0_cr0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DSS` field.
    #[inline(always)]
    pub fn set_dss<'b>(&'b mut self, new_value: SPI0_cr0_dss) -> &'b mut SPI0_cr0_Update<'a> {
        self.value = (self.value & !(15 << 0))
                   | ((new_value as u32) & 15) << 0;
        self.mask |= 15 << 0;
        self
    }
    /// Set value of `FRF` field.
    #[inline(always)]
    pub fn set_frf<'b>(&'b mut self, new_value: SPI0_cr0_frf) -> &'b mut SPI0_cr0_Update<'a> {
        self.value = (self.value & !(3 << 4))
                   | ((new_value as u32) & 3) << 4;
        self.mask |= 3 << 4;
        self
    }
    /// Set value of `CPOL` field.
    #[inline(always)]
    pub fn set_cpol<'b>(&'b mut self, new_value: SPI0_cr0_cpol) -> &'b mut SPI0_cr0_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `CPHA` field.
    #[inline(always)]
    pub fn set_cpha<'b>(&'b mut self, new_value: SPI0_cr0_cpha) -> &'b mut SPI0_cr0_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `SCR` field.
    #[inline(always)]
    pub fn set_scr<'b>(&'b mut self, new_value: u32) -> &'b mut SPI0_cr0_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SPI0_cr0_dss {
    /// 4-bit transfer
    DataSize4Bits = 3,
    /// 5-bit transfer
    DataSize5Bits = 4,
    /// 6-bit transfer
    DataSize6Bits = 5,
    /// 7-bit transfer
    DataSize7Bits = 6,
    /// 8-bit transfer
    DataSize8Bits = 7,
    /// 9-bit transfer
    DataSize9Bits = 8,
    /// 10-bit transfer
    DataSize10Bits = 9,
    /// 11-bit transfer
    DataSize11Bits = 10,
    /// 12-bit transfer
    DataSize12Bits = 11,
    /// 13-bit transfer
    DataSize13Bits = 12,
    /// 14-bit transfer
    DataSize14Bits = 13,
    /// 15-bit transfer
    DataSize15Bits = 14,
    /// 16-bit transfer
    DataSize16Bits = 15,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SPI0_cr0_frf {
    /// SPI
    SPI = 0,
    /// TI
    TI = 1,
    /// Microwire
    Microwire = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SPI0_cr0_cpol {
    /// SPI controller maintains the bus clock low between frames.
    Low = 0,
    /// SPI controller maintains the bus clock high between frames.
    High = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SPI0_cr0_cpha {
    /// SPI controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line.
    FirstClock = 0,
    /// SPI controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line.
    SecondClock = 1,
    }







// Register CR1 implementation


/// Register `CR1`: Control Register 1. Selects master/slave and other modes.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_cr1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_cr1 { }

impl SPI0_cr1 {
    
    // Getters
    /// Fetch the value of the `CR1` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_cr1_Get {
        SPI0_cr1_Get::new(self)
    }

    
    /// Get value of `LBM` field.
    #[inline(always)]
    pub fn lbm(&self) -> SPI0_cr1_lbm {
        SPI0_cr1_Get::new(self).lbm()
    }
    
    /// Get value of `SSE` field.
    #[inline(always)]
    pub fn sse(&self) -> SPI0_cr1_sse {
        SPI0_cr1_Get::new(self).sse()
    }
    
    /// Get value of `MS` field.
    #[inline(always)]
    pub fn ms(&self) -> SPI0_cr1_ms {
        SPI0_cr1_Get::new(self).ms()
    }
    
    /// Get value of `SOD` field.
    #[inline(always)]
    pub fn sod(&self) -> bool {
        SPI0_cr1_Get::new(self).sod()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CR1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SPI0_cr1_Update {
        SPI0_cr1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `LBM` field.
    #[inline(always)]
    pub fn set_lbm<'a>(&'a mut self, new_value: SPI0_cr1_lbm) -> SPI0_cr1_Update<'a> {
        let mut setter: SPI0_cr1_Update = SPI0_cr1_Update::new(self);
        setter.set_lbm(new_value);
        setter
    }
    
    /// Set value of `SSE` field.
    #[inline(always)]
    pub fn set_sse<'a>(&'a mut self, new_value: SPI0_cr1_sse) -> SPI0_cr1_Update<'a> {
        let mut setter: SPI0_cr1_Update = SPI0_cr1_Update::new(self);
        setter.set_sse(new_value);
        setter
    }
    
    /// Set value of `MS` field.
    #[inline(always)]
    pub fn set_ms<'a>(&'a mut self, new_value: SPI0_cr1_ms) -> SPI0_cr1_Update<'a> {
        let mut setter: SPI0_cr1_Update = SPI0_cr1_Update::new(self);
        setter.set_ms(new_value);
        setter
    }
    
    /// Set value of `SOD` field.
    #[inline(always)]
    pub fn set_sod<'a>(&'a mut self, new_value: bool) -> SPI0_cr1_Update<'a> {
        let mut setter: SPI0_cr1_Update = SPI0_cr1_Update::new(self);
        setter.set_sod(new_value);
        setter
    }
    

    }


// Getter for SPI0_cr1
/// `CR1`: Control Register 1. Selects master/slave and other modes.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_cr1_Get {
    value: u32,
}

impl SPI0_cr1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_cr1) -> SPI0_cr1_Get {
        SPI0_cr1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `LBM` field: Loop Back Mode.
    #[inline(always)]
    pub fn lbm(&self) -> SPI0_cr1_lbm {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SPI0_cr1_lbm::Normal),
            1 => ::core::option::Option::Some(SPI0_cr1_lbm::Loopback),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SSE` field: SPI Enable.
    #[inline(always)]
    pub fn sse(&self) -> SPI0_cr1_sse {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(SPI0_cr1_sse::Disabled),
            1 => ::core::option::Option::Some(SPI0_cr1_sse::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MS` field: Master/Slave Mode.This bit can only be written when the SSE bit is 0.
    #[inline(always)]
    pub fn ms(&self) -> SPI0_cr1_ms {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(SPI0_cr1_ms::Master),
            1 => ::core::option::Option::Some(SPI0_cr1_ms::Slave),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SOD` field: Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SPI controller from driving the transmit data line (MISO).
    #[inline(always)]
    pub fn sod(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    }

impl ::core::marker::Copy for SPI0_cr1_Get { }


// Updater for SPI0_cr1
/// Updater for `CR1` register.
#[allow(non_camel_case_types)]
pub struct SPI0_cr1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SPI0_cr1,
}

/// This performs the register update.
impl <'a> Drop for SPI0_cr1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SPI0_cr1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SPI0_cr1) -> SPI0_cr1_Update<'a> {
        SPI0_cr1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SPI0_cr1) -> SPI0_cr1_Update<'a> {
        SPI0_cr1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `LBM` field.
    #[inline(always)]
    pub fn set_lbm<'b>(&'b mut self, new_value: SPI0_cr1_lbm) -> &'b mut SPI0_cr1_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `SSE` field.
    #[inline(always)]
    pub fn set_sse<'b>(&'b mut self, new_value: SPI0_cr1_sse) -> &'b mut SPI0_cr1_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `MS` field.
    #[inline(always)]
    pub fn set_ms<'b>(&'b mut self, new_value: SPI0_cr1_ms) -> &'b mut SPI0_cr1_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `SOD` field.
    #[inline(always)]
    pub fn set_sod<'b>(&'b mut self, new_value: bool) -> &'b mut SPI0_cr1_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SPI0_cr1_lbm {
    /// During normal operation.
    Normal = 0,
    /// Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively).
    Loopback = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SPI0_cr1_sse {
    /// The SPI controller is disabled.
    Disabled = 0,
    /// The SPI controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SPI/SSP registers and interrupt controller registers, before setting this bit.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SPI0_cr1_ms {
    /// The SPI controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line.
    Master = 0,
    /// The SPI controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines.
    Slave = 1,
    }







// Register DR implementation


/// Register `DR`: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_dr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_dr { }

impl SPI0_dr {
    
    // Getters
    /// Fetch the value of the `DR` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_dr_Get {
        SPI0_dr_Get::new(self)
    }

    
    /// Get value of `DATA` field.
    #[inline(always)]
    pub fn data(&self) -> u32 {
        SPI0_dr_Get::new(self).data()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SPI0_dr_Update {
        SPI0_dr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA` field.
    #[inline(always)]
    pub fn set_data<'a>(&'a mut self, new_value: u32) -> SPI0_dr_Update<'a> {
        let mut setter: SPI0_dr_Update = SPI0_dr_Update::new(self);
        setter.set_data(new_value);
        setter
    }
    

    }


// Getter for SPI0_dr
/// `DR`: Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_dr_Get {
    value: u32,
}

impl SPI0_dr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_dr) -> SPI0_dr_Get {
        SPI0_dr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA` field: Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SPI controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bit, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SPI controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bit, the data is right-justified in this field with higher order bits filled with 0s.
    #[inline(always)]
    pub fn data(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for SPI0_dr_Get { }


// Updater for SPI0_dr
/// Updater for `DR` register.
#[allow(non_camel_case_types)]
pub struct SPI0_dr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SPI0_dr,
}

/// This performs the register update.
impl <'a> Drop for SPI0_dr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SPI0_dr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SPI0_dr) -> SPI0_dr_Update<'a> {
        SPI0_dr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SPI0_dr) -> SPI0_dr_Update<'a> {
        SPI0_dr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA` field.
    #[inline(always)]
    pub fn set_data<'b>(&'b mut self, new_value: u32) -> &'b mut SPI0_dr_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register SR implementation


/// Register `SR`: Status Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_sr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_sr { }

impl SPI0_sr {
    
    // Getters
    /// Fetch the value of the `SR` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_sr_Get {
        SPI0_sr_Get::new(self)
    }

    
    /// Get value of `TFE` field.
    #[inline(always)]
    pub fn tfe(&self) -> bool {
        SPI0_sr_Get::new(self).tfe()
    }
    
    /// Get value of `TNF` field.
    #[inline(always)]
    pub fn tnf(&self) -> bool {
        SPI0_sr_Get::new(self).tnf()
    }
    
    /// Get value of `RNE` field.
    #[inline(always)]
    pub fn rne(&self) -> bool {
        SPI0_sr_Get::new(self).rne()
    }
    
    /// Get value of `RFF` field.
    #[inline(always)]
    pub fn rff(&self) -> bool {
        SPI0_sr_Get::new(self).rff()
    }
    
    /// Get value of `BSY` field.
    #[inline(always)]
    pub fn bsy(&self) -> bool {
        SPI0_sr_Get::new(self).bsy()
    }
    

    }


// Getter for SPI0_sr
/// `SR`: Status Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_sr_Get {
    value: u32,
}

impl SPI0_sr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_sr) -> SPI0_sr_Get {
        SPI0_sr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TFE` field: Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not.
    #[inline(always)]
    pub fn tfe(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `TNF` field: Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not.
    #[inline(always)]
    pub fn tnf(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `RNE` field: Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not.
    #[inline(always)]
    pub fn rne(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `RFF` field: Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not.
    #[inline(always)]
    pub fn rff(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `BSY` field: Busy. This bit is 0 if the SPI controller is idle, 1 if it is currently sending/receiving a frame and/or the Tx FIFO is not empty.
    #[inline(always)]
    pub fn bsy(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    }

impl ::core::marker::Copy for SPI0_sr_Get { }







// Register CPSR implementation


/// Register `CPSR`: Clock Prescale Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_cpsr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_cpsr { }

impl SPI0_cpsr {
    
    // Getters
    /// Fetch the value of the `CPSR` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_cpsr_Get {
        SPI0_cpsr_Get::new(self)
    }

    
    /// Get value of `CPSDVSR` field.
    #[inline(always)]
    pub fn cpsdvsr(&self) -> u32 {
        SPI0_cpsr_Get::new(self).cpsdvsr()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CPSR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SPI0_cpsr_Update {
        SPI0_cpsr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CPSDVSR` field.
    #[inline(always)]
    pub fn set_cpsdvsr<'a>(&'a mut self, new_value: u32) -> SPI0_cpsr_Update<'a> {
        let mut setter: SPI0_cpsr_Update = SPI0_cpsr_Update::new(self);
        setter.set_cpsdvsr(new_value);
        setter
    }
    

    }


// Getter for SPI0_cpsr
/// `CPSR`: Clock Prescale Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_cpsr_Get {
    value: u32,
}

impl SPI0_cpsr_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_cpsr) -> SPI0_cpsr_Get {
        SPI0_cpsr_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CPSDVSR` field: This even value between 2 and 254, by which SPI_PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0.
    #[inline(always)]
    pub fn cpsdvsr(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SPI0_cpsr_Get { }


// Updater for SPI0_cpsr
/// Updater for `CPSR` register.
#[allow(non_camel_case_types)]
pub struct SPI0_cpsr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SPI0_cpsr,
}

/// This performs the register update.
impl <'a> Drop for SPI0_cpsr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SPI0_cpsr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SPI0_cpsr) -> SPI0_cpsr_Update<'a> {
        SPI0_cpsr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SPI0_cpsr) -> SPI0_cpsr_Update<'a> {
        SPI0_cpsr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CPSDVSR` field.
    #[inline(always)]
    pub fn set_cpsdvsr<'b>(&'b mut self, new_value: u32) -> &'b mut SPI0_cpsr_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register IMSC implementation


/// Register `IMSC`: Interrupt Mask Set and Clear Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_imsc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_imsc { }

impl SPI0_imsc {
    
    // Getters
    /// Fetch the value of the `IMSC` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_imsc_Get {
        SPI0_imsc_Get::new(self)
    }

    
    /// Get value of `RORIM` field.
    #[inline(always)]
    pub fn rorim(&self) -> bool {
        SPI0_imsc_Get::new(self).rorim()
    }
    
    /// Get value of `RTIM` field.
    #[inline(always)]
    pub fn rtim(&self) -> bool {
        SPI0_imsc_Get::new(self).rtim()
    }
    
    /// Get value of `RXIM` field.
    #[inline(always)]
    pub fn rxim(&self) -> bool {
        SPI0_imsc_Get::new(self).rxim()
    }
    
    /// Get value of `TXIM` field.
    #[inline(always)]
    pub fn txim(&self) -> bool {
        SPI0_imsc_Get::new(self).txim()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IMSC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SPI0_imsc_Update {
        SPI0_imsc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `RORIM` field.
    #[inline(always)]
    pub fn set_rorim<'a>(&'a mut self, new_value: bool) -> SPI0_imsc_Update<'a> {
        let mut setter: SPI0_imsc_Update = SPI0_imsc_Update::new(self);
        setter.set_rorim(new_value);
        setter
    }
    
    /// Set value of `RTIM` field.
    #[inline(always)]
    pub fn set_rtim<'a>(&'a mut self, new_value: bool) -> SPI0_imsc_Update<'a> {
        let mut setter: SPI0_imsc_Update = SPI0_imsc_Update::new(self);
        setter.set_rtim(new_value);
        setter
    }
    
    /// Set value of `RXIM` field.
    #[inline(always)]
    pub fn set_rxim<'a>(&'a mut self, new_value: bool) -> SPI0_imsc_Update<'a> {
        let mut setter: SPI0_imsc_Update = SPI0_imsc_Update::new(self);
        setter.set_rxim(new_value);
        setter
    }
    
    /// Set value of `TXIM` field.
    #[inline(always)]
    pub fn set_txim<'a>(&'a mut self, new_value: bool) -> SPI0_imsc_Update<'a> {
        let mut setter: SPI0_imsc_Update = SPI0_imsc_Update::new(self);
        setter.set_txim(new_value);
        setter
    }
    

    }


// Getter for SPI0_imsc
/// `IMSC`: Interrupt Mask Set and Clear Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_imsc_Get {
    value: u32,
}

impl SPI0_imsc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_imsc) -> SPI0_imsc_Get {
        SPI0_imsc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RORIM` field: Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.
    #[inline(always)]
    pub fn rorim(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `RTIM` field: Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1]).
    #[inline(always)]
    pub fn rtim(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `RXIM` field: Software should set this bit to enable interrupt when the Rx FIFO is at least half full.
    #[inline(always)]
    pub fn rxim(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `TXIM` field: Software should set this bit to enable interrupt when the Tx FIFO is at least half empty.
    #[inline(always)]
    pub fn txim(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    }

impl ::core::marker::Copy for SPI0_imsc_Get { }


// Updater for SPI0_imsc
/// Updater for `IMSC` register.
#[allow(non_camel_case_types)]
pub struct SPI0_imsc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SPI0_imsc,
}

/// This performs the register update.
impl <'a> Drop for SPI0_imsc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SPI0_imsc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SPI0_imsc) -> SPI0_imsc_Update<'a> {
        SPI0_imsc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SPI0_imsc) -> SPI0_imsc_Update<'a> {
        SPI0_imsc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `RORIM` field.
    #[inline(always)]
    pub fn set_rorim<'b>(&'b mut self, new_value: bool) -> &'b mut SPI0_imsc_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `RTIM` field.
    #[inline(always)]
    pub fn set_rtim<'b>(&'b mut self, new_value: bool) -> &'b mut SPI0_imsc_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `RXIM` field.
    #[inline(always)]
    pub fn set_rxim<'b>(&'b mut self, new_value: bool) -> &'b mut SPI0_imsc_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `TXIM` field.
    #[inline(always)]
    pub fn set_txim<'b>(&'b mut self, new_value: bool) -> &'b mut SPI0_imsc_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register RIS implementation


/// Register `RIS`: Raw Interrupt Status Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_ris {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_ris { }

impl SPI0_ris {
    
    // Getters
    /// Fetch the value of the `RIS` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_ris_Get {
        SPI0_ris_Get::new(self)
    }

    
    /// Get value of `RORRIS` field.
    #[inline(always)]
    pub fn rorris(&self) -> bool {
        SPI0_ris_Get::new(self).rorris()
    }
    
    /// Get value of `RTRIS` field.
    #[inline(always)]
    pub fn rtris(&self) -> bool {
        SPI0_ris_Get::new(self).rtris()
    }
    
    /// Get value of `RXRIS` field.
    #[inline(always)]
    pub fn rxris(&self) -> bool {
        SPI0_ris_Get::new(self).rxris()
    }
    
    /// Get value of `TXRIS` field.
    #[inline(always)]
    pub fn txris(&self) -> bool {
        SPI0_ris_Get::new(self).txris()
    }
    

    }


// Getter for SPI0_ris
/// `RIS`: Raw Interrupt Status Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_ris_Get {
    value: u32,
}

impl SPI0_ris_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_ris) -> SPI0_ris_Get {
        SPI0_ris_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RORRIS` field: This bit is 1 if another frame was completely received while the RxFIFO was full. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs.
    #[inline(always)]
    pub fn rorris(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `RTRIS` field: This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1]).
    #[inline(always)]
    pub fn rtris(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `RXRIS` field: This bit is 1 if the Rx FIFO is at least half full.
    #[inline(always)]
    pub fn rxris(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `TXRIS` field: This bit is 1 if the Tx FIFO is at least half empty.
    #[inline(always)]
    pub fn txris(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    }

impl ::core::marker::Copy for SPI0_ris_Get { }







// Register MIS implementation


/// Register `MIS`: Masked Interrupt Status Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_mis {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_mis { }

impl SPI0_mis {
    
    // Getters
    /// Fetch the value of the `MIS` register.
    #[inline(always)]
    pub fn get(&self) -> SPI0_mis_Get {
        SPI0_mis_Get::new(self)
    }

    
    /// Get value of `RORMIS` field.
    #[inline(always)]
    pub fn rormis(&self) -> bool {
        SPI0_mis_Get::new(self).rormis()
    }
    
    /// Get value of `RTMIS` field.
    #[inline(always)]
    pub fn rtmis(&self) -> bool {
        SPI0_mis_Get::new(self).rtmis()
    }
    
    /// Get value of `RXMIS` field.
    #[inline(always)]
    pub fn rxmis(&self) -> bool {
        SPI0_mis_Get::new(self).rxmis()
    }
    
    /// Get value of `TXMIS` field.
    #[inline(always)]
    pub fn txmis(&self) -> bool {
        SPI0_mis_Get::new(self).txmis()
    }
    

    }


// Getter for SPI0_mis
/// `MIS`: Masked Interrupt Status Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SPI0_mis_Get {
    value: u32,
}

impl SPI0_mis_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SPI0_mis) -> SPI0_mis_Get {
        SPI0_mis_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RORMIS` field: This bit is 1 if another frame was completely received while the RxFIFO was full, and this interrupt is enabled.
    #[inline(always)]
    pub fn rormis(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `RTMIS` field: This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out period, and this interrupt is enabled. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1]).
    #[inline(always)]
    pub fn rtmis(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `RXMIS` field: This bit is 1 if the Rx FIFO is at least half full, and this interrupt is enabled.
    #[inline(always)]
    pub fn rxmis(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `TXMIS` field: This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is enabled.
    #[inline(always)]
    pub fn txmis(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    }

impl ::core::marker::Copy for SPI0_mis_Get { }







// Register ICR implementation


/// Register `ICR`: SSPICR Interrupt Clear Register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SPI0_icr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SPI0_icr { }

impl SPI0_icr {
    
    // Setters
    /// Create new updater that ignores current value of the `ICR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SPI0_icr_Update {
        SPI0_icr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `RORIC` field.
    #[inline(always)]
    pub fn set_roric<'a>(&'a mut self, new_value: bool) -> SPI0_icr_Update<'a> {
        let mut setter: SPI0_icr_Update = SPI0_icr_Update::new(self);
        setter.set_roric(new_value);
        setter
    }
    
    /// Set value of `RTIC` field.
    #[inline(always)]
    pub fn set_rtic<'a>(&'a mut self, new_value: bool) -> SPI0_icr_Update<'a> {
        let mut setter: SPI0_icr_Update = SPI0_icr_Update::new(self);
        setter.set_rtic(new_value);
        setter
    }
    

    }


// Updater for SPI0_icr
/// Updater for `ICR` register.
#[allow(non_camel_case_types)]
pub struct SPI0_icr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SPI0_icr,
}

/// This performs the register update.
impl <'a> Drop for SPI0_icr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SPI0_icr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SPI0_icr) -> SPI0_icr_Update<'a> {
        SPI0_icr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SPI0_icr) -> SPI0_icr_Update<'a> {
        SPI0_icr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `RORIC` field.
    #[inline(always)]
    pub fn set_roric<'b>(&'b mut self, new_value: bool) -> &'b mut SPI0_icr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `RTIC` field.
    #[inline(always)]
    pub fn set_rtic<'b>(&'b mut self, new_value: bool) -> &'b mut SPI0_icr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral SPI0 implementation

/// SPI0
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct SPI0;

impl SPI0 {
    /// Control Register 0. Selects the serial clock rate, bus type, and data size.
    #[inline(always)]
    pub fn cr0() -> &'static mut SPI0_cr0 {
        unsafe { ::core::intrinsics::transmute(0x40040000 as usize) }
    }
    /// Control Register 1. Selects master/slave and other modes.
    #[inline(always)]
    pub fn cr1() -> &'static mut SPI0_cr1 {
        unsafe { ::core::intrinsics::transmute(0x40040004 as usize) }
    }
    /// Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
    #[inline(always)]
    pub fn dr() -> &'static mut SPI0_dr {
        unsafe { ::core::intrinsics::transmute(0x40040008 as usize) }
    }
    /// Status Register
    #[inline(always)]
    pub fn sr() -> &'static mut SPI0_sr {
        unsafe { ::core::intrinsics::transmute(0x4004000c as usize) }
    }
    /// Clock Prescale Register
    #[inline(always)]
    pub fn cpsr() -> &'static mut SPI0_cpsr {
        unsafe { ::core::intrinsics::transmute(0x40040010 as usize) }
    }
    /// Interrupt Mask Set and Clear Register
    #[inline(always)]
    pub fn imsc() -> &'static mut SPI0_imsc {
        unsafe { ::core::intrinsics::transmute(0x40040014 as usize) }
    }
    /// Raw Interrupt Status Register
    #[inline(always)]
    pub fn ris() -> &'static mut SPI0_ris {
        unsafe { ::core::intrinsics::transmute(0x40040018 as usize) }
    }
    /// Masked Interrupt Status Register
    #[inline(always)]
    pub fn mis() -> &'static mut SPI0_mis {
        unsafe { ::core::intrinsics::transmute(0x4004001c as usize) }
    }
    /// SSPICR Interrupt Clear Register
    #[inline(always)]
    pub fn icr() -> &'static mut SPI0_icr {
        unsafe { ::core::intrinsics::transmute(0x40040020 as usize) }
    }
    }



// Registers for IOCON





// Register IOCON_PIO2_6 implementation


/// Register `IOCON_PIO2_6`: I/O configuration for pin PIO2_6/ CT32B0_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_6 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_6 { }

impl IOCON_iocon_pio2_6 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_6` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_6_Get {
        IOCON_iocon_pio2_6_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_6_func {
        IOCON_iocon_pio2_6_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_6_mode {
        IOCON_iocon_pio2_6_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_6_hys {
        IOCON_iocon_pio2_6_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_6_od {
        IOCON_iocon_pio2_6_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_6` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_6_Update {
        IOCON_iocon_pio2_6_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_6_func) -> IOCON_iocon_pio2_6_Update<'a> {
        let mut setter: IOCON_iocon_pio2_6_Update = IOCON_iocon_pio2_6_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_6_mode) -> IOCON_iocon_pio2_6_Update<'a> {
        let mut setter: IOCON_iocon_pio2_6_Update = IOCON_iocon_pio2_6_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_6_hys) -> IOCON_iocon_pio2_6_Update<'a> {
        let mut setter: IOCON_iocon_pio2_6_Update = IOCON_iocon_pio2_6_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_6_od) -> IOCON_iocon_pio2_6_Update<'a> {
        let mut setter: IOCON_iocon_pio2_6_Update = IOCON_iocon_pio2_6_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_6
/// `IOCON_PIO2_6`: I/O configuration for pin PIO2_6/ CT32B0_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_6_Get {
    value: u32,
}

impl IOCON_iocon_pio2_6_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_6) -> IOCON_iocon_pio2_6_Get {
        IOCON_iocon_pio2_6_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_6_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_6_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_6_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_6_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_6_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_6_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_6_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_6_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_6_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_6_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_6_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_6_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_6_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_6_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_6_Get { }


// Updater for IOCON_iocon_pio2_6
/// Updater for `IOCON_PIO2_6` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_6_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_6,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_6_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_6_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_6) -> IOCON_iocon_pio2_6_Update<'a> {
        IOCON_iocon_pio2_6_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_6) -> IOCON_iocon_pio2_6_Update<'a> {
        IOCON_iocon_pio2_6_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_6_func) -> &'b mut IOCON_iocon_pio2_6_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_6_mode) -> &'b mut IOCON_iocon_pio2_6_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_6_hys) -> &'b mut IOCON_iocon_pio2_6_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_6_od) -> &'b mut IOCON_iocon_pio2_6_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_6_func {
    /// Selects function PIO2_6.
    GPIO = 0,
    /// Selects function CT32B0_MAT1.
    CT32B0_MAT1 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_6_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_6_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_6_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_0 implementation


/// Register `IOCON_PIO2_0`: I/O configuration for pin PIO2_0/DTR/SSEL1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_0 { }

impl IOCON_iocon_pio2_0 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_0` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_0_Get {
        IOCON_iocon_pio2_0_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_0_func {
        IOCON_iocon_pio2_0_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_0_mode {
        IOCON_iocon_pio2_0_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_0_hys {
        IOCON_iocon_pio2_0_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_0_od {
        IOCON_iocon_pio2_0_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_0_Update {
        IOCON_iocon_pio2_0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_0_func) -> IOCON_iocon_pio2_0_Update<'a> {
        let mut setter: IOCON_iocon_pio2_0_Update = IOCON_iocon_pio2_0_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_0_mode) -> IOCON_iocon_pio2_0_Update<'a> {
        let mut setter: IOCON_iocon_pio2_0_Update = IOCON_iocon_pio2_0_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_0_hys) -> IOCON_iocon_pio2_0_Update<'a> {
        let mut setter: IOCON_iocon_pio2_0_Update = IOCON_iocon_pio2_0_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_0_od) -> IOCON_iocon_pio2_0_Update<'a> {
        let mut setter: IOCON_iocon_pio2_0_Update = IOCON_iocon_pio2_0_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_0
/// `IOCON_PIO2_0`: I/O configuration for pin PIO2_0/DTR/SSEL1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_0_Get {
    value: u32,
}

impl IOCON_iocon_pio2_0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_0) -> IOCON_iocon_pio2_0_Get {
        IOCON_iocon_pio2_0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_0_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_0_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_0_func::DTR),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_0_func::SSEL1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_0_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_0_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_0_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_0_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_0_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_0_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_0_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_0_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_0_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_0_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_0_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_0_Get { }


// Updater for IOCON_iocon_pio2_0
/// Updater for `IOCON_PIO2_0` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_0,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_0) -> IOCON_iocon_pio2_0_Update<'a> {
        IOCON_iocon_pio2_0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_0) -> IOCON_iocon_pio2_0_Update<'a> {
        IOCON_iocon_pio2_0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_0_func) -> &'b mut IOCON_iocon_pio2_0_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_0_mode) -> &'b mut IOCON_iocon_pio2_0_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_0_hys) -> &'b mut IOCON_iocon_pio2_0_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_0_od) -> &'b mut IOCON_iocon_pio2_0_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_0_func {
    /// Selects function PIO2_0.
    GPIO = 0,
    /// Select function DTR.
    DTR = 1,
    /// Select function SSEL1.
    SSEL1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_0_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_0_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_0_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_RESET_PIO0_0 implementation


/// Register `IOCON_RESET_PIO0_0`: I/O configuration for pin RESET/PIO0_0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_reset_pio0_0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_reset_pio0_0 { }

impl IOCON_iocon_reset_pio0_0 {
    
    // Getters
    /// Fetch the value of the `IOCON_RESET_PIO0_0` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_reset_pio0_0_Get {
        IOCON_iocon_reset_pio0_0_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_reset_pio0_0_func {
        IOCON_iocon_reset_pio0_0_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_reset_pio0_0_mode {
        IOCON_iocon_reset_pio0_0_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_reset_pio0_0_hys {
        IOCON_iocon_reset_pio0_0_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_reset_pio0_0_od {
        IOCON_iocon_reset_pio0_0_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_RESET_PIO0_0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_reset_pio0_0_Update {
        IOCON_iocon_reset_pio0_0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_reset_pio0_0_func) -> IOCON_iocon_reset_pio0_0_Update<'a> {
        let mut setter: IOCON_iocon_reset_pio0_0_Update = IOCON_iocon_reset_pio0_0_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_reset_pio0_0_mode) -> IOCON_iocon_reset_pio0_0_Update<'a> {
        let mut setter: IOCON_iocon_reset_pio0_0_Update = IOCON_iocon_reset_pio0_0_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_reset_pio0_0_hys) -> IOCON_iocon_reset_pio0_0_Update<'a> {
        let mut setter: IOCON_iocon_reset_pio0_0_Update = IOCON_iocon_reset_pio0_0_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_reset_pio0_0_od) -> IOCON_iocon_reset_pio0_0_Update<'a> {
        let mut setter: IOCON_iocon_reset_pio0_0_Update = IOCON_iocon_reset_pio0_0_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_reset_pio0_0
/// `IOCON_RESET_PIO0_0`: I/O configuration for pin RESET/PIO0_0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_reset_pio0_0_Get {
    value: u32,
}

impl IOCON_iocon_reset_pio0_0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_reset_pio0_0) -> IOCON_iocon_reset_pio0_0_Get {
        IOCON_iocon_reset_pio0_0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_reset_pio0_0_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_func::Reset),
            1 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_func::GPIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_reset_pio0_0_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_reset_pio0_0_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_reset_pio0_0_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_reset_pio0_0_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_reset_pio0_0_Get { }


// Updater for IOCON_iocon_reset_pio0_0
/// Updater for `IOCON_RESET_PIO0_0` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_reset_pio0_0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_reset_pio0_0,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_reset_pio0_0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_reset_pio0_0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_reset_pio0_0) -> IOCON_iocon_reset_pio0_0_Update<'a> {
        IOCON_iocon_reset_pio0_0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_reset_pio0_0) -> IOCON_iocon_reset_pio0_0_Update<'a> {
        IOCON_iocon_reset_pio0_0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_reset_pio0_0_func) -> &'b mut IOCON_iocon_reset_pio0_0_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_reset_pio0_0_mode) -> &'b mut IOCON_iocon_reset_pio0_0_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_reset_pio0_0_hys) -> &'b mut IOCON_iocon_reset_pio0_0_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_reset_pio0_0_od) -> &'b mut IOCON_iocon_reset_pio0_0_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_reset_pio0_0_func {
    /// Selects function RESET.
    Reset = 0,
    /// Selects function PIO0_0.
    GPIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_reset_pio0_0_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_reset_pio0_0_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_reset_pio0_0_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_1 implementation


/// Register `IOCON_PIO0_1`: I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_1 { }

impl IOCON_iocon_pio0_1 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_1` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_1_Get {
        IOCON_iocon_pio0_1_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_1_func {
        IOCON_iocon_pio0_1_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_1_mode {
        IOCON_iocon_pio0_1_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_1_hys {
        IOCON_iocon_pio0_1_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_1_od {
        IOCON_iocon_pio0_1_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_1_Update {
        IOCON_iocon_pio0_1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_1_func) -> IOCON_iocon_pio0_1_Update<'a> {
        let mut setter: IOCON_iocon_pio0_1_Update = IOCON_iocon_pio0_1_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_1_mode) -> IOCON_iocon_pio0_1_Update<'a> {
        let mut setter: IOCON_iocon_pio0_1_Update = IOCON_iocon_pio0_1_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio0_1_hys) -> IOCON_iocon_pio0_1_Update<'a> {
        let mut setter: IOCON_iocon_pio0_1_Update = IOCON_iocon_pio0_1_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio0_1_od) -> IOCON_iocon_pio0_1_Update<'a> {
        let mut setter: IOCON_iocon_pio0_1_Update = IOCON_iocon_pio0_1_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_1
/// `IOCON_PIO0_1`: I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_1_Get {
    value: u32,
}

impl IOCON_iocon_pio0_1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_1) -> IOCON_iocon_pio0_1_Get {
        IOCON_iocon_pio0_1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_1_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_1_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_1_func::CLKOUT),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_1_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_1_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_1_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_1_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_1_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio0_1_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_1_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_1_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_1_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_1_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_1_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_1_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_1_Get { }


// Updater for IOCON_iocon_pio0_1
/// Updater for `IOCON_PIO0_1` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_1,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_1) -> IOCON_iocon_pio0_1_Update<'a> {
        IOCON_iocon_pio0_1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_1) -> IOCON_iocon_pio0_1_Update<'a> {
        IOCON_iocon_pio0_1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_1_func) -> &'b mut IOCON_iocon_pio0_1_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_1_mode) -> &'b mut IOCON_iocon_pio0_1_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio0_1_hys) -> &'b mut IOCON_iocon_pio0_1_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio0_1_od) -> &'b mut IOCON_iocon_pio0_1_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_1_func {
    /// Selects function PIO0_1.
    GPIO = 0,
    /// Selects function CLKOUT.
    CLKOUT = 1,
    /// Selects function CT32B0_MAT2.
    CT32B0_MAT1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_1_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_1_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_1_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO1_8 implementation


/// Register `IOCON_PIO1_8`: I/O configuration for pin PIO1_8/CT16B1_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_8 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_8 { }

impl IOCON_iocon_pio1_8 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_8` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_8_Get {
        IOCON_iocon_pio1_8_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_8_func {
        IOCON_iocon_pio1_8_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_8_mode {
        IOCON_iocon_pio1_8_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_8_hys {
        IOCON_iocon_pio1_8_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_8_od {
        IOCON_iocon_pio1_8_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_8` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_8_Update {
        IOCON_iocon_pio1_8_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_8_func) -> IOCON_iocon_pio1_8_Update<'a> {
        let mut setter: IOCON_iocon_pio1_8_Update = IOCON_iocon_pio1_8_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_8_mode) -> IOCON_iocon_pio1_8_Update<'a> {
        let mut setter: IOCON_iocon_pio1_8_Update = IOCON_iocon_pio1_8_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_8_hys) -> IOCON_iocon_pio1_8_Update<'a> {
        let mut setter: IOCON_iocon_pio1_8_Update = IOCON_iocon_pio1_8_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_8_od) -> IOCON_iocon_pio1_8_Update<'a> {
        let mut setter: IOCON_iocon_pio1_8_Update = IOCON_iocon_pio1_8_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_8
/// `IOCON_PIO1_8`: I/O configuration for pin PIO1_8/CT16B1_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_8_Get {
    value: u32,
}

impl IOCON_iocon_pio1_8_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_8) -> IOCON_iocon_pio1_8_Get {
        IOCON_iocon_pio1_8_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_8_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_8_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_8_func::CT16B1_CAP0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_8_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_8_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_8_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_8_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_8_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_8_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_8_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_8_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_8_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_8_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_8_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_8_Get { }


// Updater for IOCON_iocon_pio1_8
/// Updater for `IOCON_PIO1_8` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_8_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_8,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_8_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_8_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_8) -> IOCON_iocon_pio1_8_Update<'a> {
        IOCON_iocon_pio1_8_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_8) -> IOCON_iocon_pio1_8_Update<'a> {
        IOCON_iocon_pio1_8_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_8_func) -> &'b mut IOCON_iocon_pio1_8_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_8_mode) -> &'b mut IOCON_iocon_pio1_8_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_8_hys) -> &'b mut IOCON_iocon_pio1_8_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_8_od) -> &'b mut IOCON_iocon_pio1_8_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_8_func {
    /// Selects function PIO1_8.
    GPIO = 0,
    /// Selects function CT16B1_CAP0.
    CT16B1_CAP0 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_8_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_8_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_8_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_2 implementation


/// Register `IOCON_PIO0_2`: I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_2 { }

impl IOCON_iocon_pio0_2 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_2` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_2_Get {
        IOCON_iocon_pio0_2_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_2_func {
        IOCON_iocon_pio0_2_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_2_mode {
        IOCON_iocon_pio0_2_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_2_hys {
        IOCON_iocon_pio0_2_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_2_od {
        IOCON_iocon_pio0_2_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_2_Update {
        IOCON_iocon_pio0_2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_2_func) -> IOCON_iocon_pio0_2_Update<'a> {
        let mut setter: IOCON_iocon_pio0_2_Update = IOCON_iocon_pio0_2_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_2_mode) -> IOCON_iocon_pio0_2_Update<'a> {
        let mut setter: IOCON_iocon_pio0_2_Update = IOCON_iocon_pio0_2_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio0_2_hys) -> IOCON_iocon_pio0_2_Update<'a> {
        let mut setter: IOCON_iocon_pio0_2_Update = IOCON_iocon_pio0_2_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio0_2_od) -> IOCON_iocon_pio0_2_Update<'a> {
        let mut setter: IOCON_iocon_pio0_2_Update = IOCON_iocon_pio0_2_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_2
/// `IOCON_PIO0_2`: I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_2_Get {
    value: u32,
}

impl IOCON_iocon_pio0_2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_2) -> IOCON_iocon_pio0_2_Get {
        IOCON_iocon_pio0_2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_2_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_2_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_2_func::SSEL0),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_2_func::CT16B1_CAP0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_2_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_2_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_2_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_2_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio0_2_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_2_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_2_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_2_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_2_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_2_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_2_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_2_Get { }


// Updater for IOCON_iocon_pio0_2
/// Updater for `IOCON_PIO0_2` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_2,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_2) -> IOCON_iocon_pio0_2_Update<'a> {
        IOCON_iocon_pio0_2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_2) -> IOCON_iocon_pio0_2_Update<'a> {
        IOCON_iocon_pio0_2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_2_func) -> &'b mut IOCON_iocon_pio0_2_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_2_mode) -> &'b mut IOCON_iocon_pio0_2_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio0_2_hys) -> &'b mut IOCON_iocon_pio0_2_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio0_2_od) -> &'b mut IOCON_iocon_pio0_2_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_2_func {
    /// Selects function PIO0_2.
    GPIO = 0,
    /// Selects function SSEL0.
    SSEL0 = 1,
    /// Selects function CT16B0_CAP0.
    CT16B1_CAP0 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_2_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_2_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_2_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_7 implementation


/// Register `IOCON_PIO2_7`: I/O configuration for pin PIO2_7/ CT32B0_MAT2/RXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_7 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_7 { }

impl IOCON_iocon_pio2_7 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_7` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_7_Get {
        IOCON_iocon_pio2_7_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_7_func {
        IOCON_iocon_pio2_7_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_7_mode {
        IOCON_iocon_pio2_7_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_7_hys {
        IOCON_iocon_pio2_7_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_7_od {
        IOCON_iocon_pio2_7_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_7` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_7_Update {
        IOCON_iocon_pio2_7_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_7_func) -> IOCON_iocon_pio2_7_Update<'a> {
        let mut setter: IOCON_iocon_pio2_7_Update = IOCON_iocon_pio2_7_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_7_mode) -> IOCON_iocon_pio2_7_Update<'a> {
        let mut setter: IOCON_iocon_pio2_7_Update = IOCON_iocon_pio2_7_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_7_hys) -> IOCON_iocon_pio2_7_Update<'a> {
        let mut setter: IOCON_iocon_pio2_7_Update = IOCON_iocon_pio2_7_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_7_od) -> IOCON_iocon_pio2_7_Update<'a> {
        let mut setter: IOCON_iocon_pio2_7_Update = IOCON_iocon_pio2_7_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_7
/// `IOCON_PIO2_7`: I/O configuration for pin PIO2_7/ CT32B0_MAT2/RXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_7_Get {
    value: u32,
}

impl IOCON_iocon_pio2_7_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_7) -> IOCON_iocon_pio2_7_Get {
        IOCON_iocon_pio2_7_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_7_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_7_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_7_func::CT32B0_MAT1),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_7_func::RXD),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_7_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_7_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_7_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_7_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_7_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_7_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_7_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_7_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_7_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_7_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_7_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_7_Get { }


// Updater for IOCON_iocon_pio2_7
/// Updater for `IOCON_PIO2_7` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_7_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_7,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_7_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_7_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_7) -> IOCON_iocon_pio2_7_Update<'a> {
        IOCON_iocon_pio2_7_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_7) -> IOCON_iocon_pio2_7_Update<'a> {
        IOCON_iocon_pio2_7_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_7_func) -> &'b mut IOCON_iocon_pio2_7_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_7_mode) -> &'b mut IOCON_iocon_pio2_7_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_7_hys) -> &'b mut IOCON_iocon_pio2_7_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_7_od) -> &'b mut IOCON_iocon_pio2_7_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_7_func {
    /// Selects function PIO2_7.
    GPIO = 0,
    /// Selects function CT32B0_MAT2.
    CT32B0_MAT1 = 1,
    /// Selects function RXD.
    RXD = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_7_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_7_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_7_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_8 implementation


/// Register `IOCON_PIO2_8`: I/O configuration for pin PIO2_8/ CT32B0_MAT3/TXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_8 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_8 { }

impl IOCON_iocon_pio2_8 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_8` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_8_Get {
        IOCON_iocon_pio2_8_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_8_func {
        IOCON_iocon_pio2_8_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_8_mode {
        IOCON_iocon_pio2_8_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_8_hys {
        IOCON_iocon_pio2_8_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_8_od {
        IOCON_iocon_pio2_8_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_8` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_8_Update {
        IOCON_iocon_pio2_8_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_8_func) -> IOCON_iocon_pio2_8_Update<'a> {
        let mut setter: IOCON_iocon_pio2_8_Update = IOCON_iocon_pio2_8_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_8_mode) -> IOCON_iocon_pio2_8_Update<'a> {
        let mut setter: IOCON_iocon_pio2_8_Update = IOCON_iocon_pio2_8_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_8_hys) -> IOCON_iocon_pio2_8_Update<'a> {
        let mut setter: IOCON_iocon_pio2_8_Update = IOCON_iocon_pio2_8_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_8_od) -> IOCON_iocon_pio2_8_Update<'a> {
        let mut setter: IOCON_iocon_pio2_8_Update = IOCON_iocon_pio2_8_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_8
/// `IOCON_PIO2_8`: I/O configuration for pin PIO2_8/ CT32B0_MAT3/TXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_8_Get {
    value: u32,
}

impl IOCON_iocon_pio2_8_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_8) -> IOCON_iocon_pio2_8_Get {
        IOCON_iocon_pio2_8_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_8_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_8_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_8_func::CT32B0_MAT1),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_8_func::TXD),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_8_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_8_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_8_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_8_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_8_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_8_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_8_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_8_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_8_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_8_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_8_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_8_Get { }


// Updater for IOCON_iocon_pio2_8
/// Updater for `IOCON_PIO2_8` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_8_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_8,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_8_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_8_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_8) -> IOCON_iocon_pio2_8_Update<'a> {
        IOCON_iocon_pio2_8_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_8) -> IOCON_iocon_pio2_8_Update<'a> {
        IOCON_iocon_pio2_8_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_8_func) -> &'b mut IOCON_iocon_pio2_8_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_8_mode) -> &'b mut IOCON_iocon_pio2_8_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_8_hys) -> &'b mut IOCON_iocon_pio2_8_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_8_od) -> &'b mut IOCON_iocon_pio2_8_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_8_func {
    /// Selects function PIO2_8.
    GPIO = 0,
    /// Selects function CT32B0_MAT3.
    CT32B0_MAT1 = 1,
    /// Selects function TXD.
    TXD = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_8_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_8_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_8_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_1 implementation


/// Register `IOCON_PIO2_1`: I/O configuration for pin PIO2_1/DSR/SCK1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_1 { }

impl IOCON_iocon_pio2_1 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_1` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_1_Get {
        IOCON_iocon_pio2_1_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_1_func {
        IOCON_iocon_pio2_1_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_1_mode {
        IOCON_iocon_pio2_1_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_1_hys {
        IOCON_iocon_pio2_1_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_1_od {
        IOCON_iocon_pio2_1_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_1_Update {
        IOCON_iocon_pio2_1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_1_func) -> IOCON_iocon_pio2_1_Update<'a> {
        let mut setter: IOCON_iocon_pio2_1_Update = IOCON_iocon_pio2_1_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_1_mode) -> IOCON_iocon_pio2_1_Update<'a> {
        let mut setter: IOCON_iocon_pio2_1_Update = IOCON_iocon_pio2_1_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_1_hys) -> IOCON_iocon_pio2_1_Update<'a> {
        let mut setter: IOCON_iocon_pio2_1_Update = IOCON_iocon_pio2_1_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_1_od) -> IOCON_iocon_pio2_1_Update<'a> {
        let mut setter: IOCON_iocon_pio2_1_Update = IOCON_iocon_pio2_1_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_1
/// `IOCON_PIO2_1`: I/O configuration for pin PIO2_1/DSR/SCK1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_1_Get {
    value: u32,
}

impl IOCON_iocon_pio2_1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_1) -> IOCON_iocon_pio2_1_Get {
        IOCON_iocon_pio2_1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_1_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_1_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_1_func::DSR),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_1_func::SCK1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_1_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_1_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_1_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_1_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_1_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_1_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_1_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_1_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_1_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_1_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_1_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_1_Get { }


// Updater for IOCON_iocon_pio2_1
/// Updater for `IOCON_PIO2_1` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_1,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_1) -> IOCON_iocon_pio2_1_Update<'a> {
        IOCON_iocon_pio2_1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_1) -> IOCON_iocon_pio2_1_Update<'a> {
        IOCON_iocon_pio2_1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_1_func) -> &'b mut IOCON_iocon_pio2_1_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_1_mode) -> &'b mut IOCON_iocon_pio2_1_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_1_hys) -> &'b mut IOCON_iocon_pio2_1_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_1_od) -> &'b mut IOCON_iocon_pio2_1_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_1_func {
    /// Selects function PIO2_1.
    GPIO = 0,
    /// Select function DSR.
    DSR = 1,
    /// Select function SCK1.
    SCK1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_1_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_1_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_1_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_3 implementation


/// Register `IOCON_PIO0_3`: I/O configuration for pin PIO0_3
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_3 { }

impl IOCON_iocon_pio0_3 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_3` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_3_Get {
        IOCON_iocon_pio0_3_Get::new(self)
    }

    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_3_mode {
        IOCON_iocon_pio0_3_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_3_hys {
        IOCON_iocon_pio0_3_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_3_od {
        IOCON_iocon_pio0_3_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_3_Update {
        IOCON_iocon_pio0_3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_3_mode) -> IOCON_iocon_pio0_3_Update<'a> {
        let mut setter: IOCON_iocon_pio0_3_Update = IOCON_iocon_pio0_3_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio0_3_hys) -> IOCON_iocon_pio0_3_Update<'a> {
        let mut setter: IOCON_iocon_pio0_3_Update = IOCON_iocon_pio0_3_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio0_3_od) -> IOCON_iocon_pio0_3_Update<'a> {
        let mut setter: IOCON_iocon_pio0_3_Update = IOCON_iocon_pio0_3_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_3
/// `IOCON_PIO0_3`: I/O configuration for pin PIO0_3
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_3_Get {
    value: u32,
}

impl IOCON_iocon_pio0_3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_3) -> IOCON_iocon_pio0_3_Get {
        IOCON_iocon_pio0_3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_3_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_3_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_3_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_3_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio0_3_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_3_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_3_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_3_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_3_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_3_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_3_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_3_Get { }


// Updater for IOCON_iocon_pio0_3
/// Updater for `IOCON_PIO0_3` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_3,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_3) -> IOCON_iocon_pio0_3_Update<'a> {
        IOCON_iocon_pio0_3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_3) -> IOCON_iocon_pio0_3_Update<'a> {
        IOCON_iocon_pio0_3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_3_mode) -> &'b mut IOCON_iocon_pio0_3_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio0_3_hys) -> &'b mut IOCON_iocon_pio0_3_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio0_3_od) -> &'b mut IOCON_iocon_pio0_3_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_3_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_3_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_3_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_4 implementation


/// Register `IOCON_PIO0_4`: I/O configuration for pin PIO0_4/SCL
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_4 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_4 { }

impl IOCON_iocon_pio0_4 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_4` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_4_Get {
        IOCON_iocon_pio0_4_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_4_func {
        IOCON_iocon_pio0_4_Get::new(self).func()
    }
    
    /// Get value of `I2CMODE` field.
    #[inline(always)]
    pub fn i2cmode(&self) -> IOCON_iocon_pio0_4_i2cmode {
        IOCON_iocon_pio0_4_Get::new(self).i2cmode()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_4` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_4_Update {
        IOCON_iocon_pio0_4_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_4_func) -> IOCON_iocon_pio0_4_Update<'a> {
        let mut setter: IOCON_iocon_pio0_4_Update = IOCON_iocon_pio0_4_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `I2CMODE` field.
    #[inline(always)]
    pub fn set_i2cmode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_4_i2cmode) -> IOCON_iocon_pio0_4_Update<'a> {
        let mut setter: IOCON_iocon_pio0_4_Update = IOCON_iocon_pio0_4_Update::new(self);
        setter.set_i2cmode(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_4
/// `IOCON_PIO0_4`: I/O configuration for pin PIO0_4/SCL
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_4_Get {
    value: u32,
}

impl IOCON_iocon_pio0_4_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_4) -> IOCON_iocon_pio0_4_Get {
        IOCON_iocon_pio0_4_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_4_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_4_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_4_func::SCL),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `I2CMODE` field: Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000).
    #[inline(always)]
    pub fn i2cmode(&self) -> IOCON_iocon_pio0_4_i2cmode {
        match (self.value >> 8) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_4_i2cmode::StandardModeI2C),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_4_i2cmode::StandardIOFunction),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_4_i2cmode::FastModeI2C),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_4_Get { }


// Updater for IOCON_iocon_pio0_4
/// Updater for `IOCON_PIO0_4` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_4_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_4,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_4_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_4_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_4) -> IOCON_iocon_pio0_4_Update<'a> {
        IOCON_iocon_pio0_4_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_4) -> IOCON_iocon_pio0_4_Update<'a> {
        IOCON_iocon_pio0_4_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_4_func) -> &'b mut IOCON_iocon_pio0_4_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `I2CMODE` field.
    #[inline(always)]
    pub fn set_i2cmode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_4_i2cmode) -> &'b mut IOCON_iocon_pio0_4_Update<'a> {
        self.value = (self.value & !(3 << 8))
                   | ((new_value as u32) & 3) << 8;
        self.mask |= 3 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_4_func {
    /// Selects function PIO0_4 (open-drain pin).
    GPIO = 0,
    /// Selects I2C function SCL (open-drain pin).
    SCL = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_4_i2cmode {
    /// Standard mode/ Fast-mode I2C.
    StandardModeI2C = 0,
    /// Standard I/O functionality
    StandardIOFunction = 1,
    /// Fast-mode Plus I2C
    FastModeI2C = 2,
    }







// Register IOCON_PIO0_5 implementation


/// Register `IOCON_PIO0_5`: I/O configuration for pin PIO0_5/SDA
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_5 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_5 { }

impl IOCON_iocon_pio0_5 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_5` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_5_Get {
        IOCON_iocon_pio0_5_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_5_func {
        IOCON_iocon_pio0_5_Get::new(self).func()
    }
    
    /// Get value of `I2CMODE` field.
    #[inline(always)]
    pub fn i2cmode(&self) -> IOCON_iocon_pio0_5_i2cmode {
        IOCON_iocon_pio0_5_Get::new(self).i2cmode()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_5` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_5_Update {
        IOCON_iocon_pio0_5_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_5_func) -> IOCON_iocon_pio0_5_Update<'a> {
        let mut setter: IOCON_iocon_pio0_5_Update = IOCON_iocon_pio0_5_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `I2CMODE` field.
    #[inline(always)]
    pub fn set_i2cmode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_5_i2cmode) -> IOCON_iocon_pio0_5_Update<'a> {
        let mut setter: IOCON_iocon_pio0_5_Update = IOCON_iocon_pio0_5_Update::new(self);
        setter.set_i2cmode(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_5
/// `IOCON_PIO0_5`: I/O configuration for pin PIO0_5/SDA
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_5_Get {
    value: u32,
}

impl IOCON_iocon_pio0_5_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_5) -> IOCON_iocon_pio0_5_Get {
        IOCON_iocon_pio0_5_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_5_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_5_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_5_func::SDA),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `I2CMODE` field: Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000).
    #[inline(always)]
    pub fn i2cmode(&self) -> IOCON_iocon_pio0_5_i2cmode {
        match (self.value >> 8) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_5_i2cmode::StandardModeI2C),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_5_i2cmode::StandardIOFunction),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_5_i2cmode::FastModeI2C),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_5_Get { }


// Updater for IOCON_iocon_pio0_5
/// Updater for `IOCON_PIO0_5` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_5_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_5,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_5_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_5_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_5) -> IOCON_iocon_pio0_5_Update<'a> {
        IOCON_iocon_pio0_5_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_5) -> IOCON_iocon_pio0_5_Update<'a> {
        IOCON_iocon_pio0_5_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_5_func) -> &'b mut IOCON_iocon_pio0_5_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `I2CMODE` field.
    #[inline(always)]
    pub fn set_i2cmode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_5_i2cmode) -> &'b mut IOCON_iocon_pio0_5_Update<'a> {
        self.value = (self.value & !(3 << 8))
                   | ((new_value as u32) & 3) << 8;
        self.mask |= 3 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_5_func {
    /// Selects function PIO0_5 (open-drain pin).
    GPIO = 0,
    /// Selects I2C function SDA (open-drain pin).
    SDA = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_5_i2cmode {
    /// Standard mode/ Fast-mode I2C.
    StandardModeI2C = 0,
    /// Standard I/O functionality
    StandardIOFunction = 1,
    /// Fast-mode Plus I2C
    FastModeI2C = 2,
    }







// Register IOCON_PIO1_9 implementation


/// Register `IOCON_PIO1_9`: I/O configuration for pin PIO1_9/CT16B1_MAT0/ MOSI1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_9 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_9 { }

impl IOCON_iocon_pio1_9 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_9` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_9_Get {
        IOCON_iocon_pio1_9_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_9_func {
        IOCON_iocon_pio1_9_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_9_mode {
        IOCON_iocon_pio1_9_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_9_hys {
        IOCON_iocon_pio1_9_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_9_od {
        IOCON_iocon_pio1_9_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_9` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_9_Update {
        IOCON_iocon_pio1_9_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_9_func) -> IOCON_iocon_pio1_9_Update<'a> {
        let mut setter: IOCON_iocon_pio1_9_Update = IOCON_iocon_pio1_9_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_9_mode) -> IOCON_iocon_pio1_9_Update<'a> {
        let mut setter: IOCON_iocon_pio1_9_Update = IOCON_iocon_pio1_9_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_9_hys) -> IOCON_iocon_pio1_9_Update<'a> {
        let mut setter: IOCON_iocon_pio1_9_Update = IOCON_iocon_pio1_9_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_9_od) -> IOCON_iocon_pio1_9_Update<'a> {
        let mut setter: IOCON_iocon_pio1_9_Update = IOCON_iocon_pio1_9_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_9
/// `IOCON_PIO1_9`: I/O configuration for pin PIO1_9/CT16B1_MAT0/ MOSI1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_9_Get {
    value: u32,
}

impl IOCON_iocon_pio1_9_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_9) -> IOCON_iocon_pio1_9_Get {
        IOCON_iocon_pio1_9_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_9_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_9_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_9_func::CT16B1_CAP0),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_9_func::MOSI1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_9_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_9_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_9_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_9_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_9_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_9_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_9_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_9_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_9_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_9_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_9_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_9_Get { }


// Updater for IOCON_iocon_pio1_9
/// Updater for `IOCON_PIO1_9` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_9_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_9,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_9_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_9_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_9) -> IOCON_iocon_pio1_9_Update<'a> {
        IOCON_iocon_pio1_9_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_9) -> IOCON_iocon_pio1_9_Update<'a> {
        IOCON_iocon_pio1_9_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_9_func) -> &'b mut IOCON_iocon_pio1_9_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_9_mode) -> &'b mut IOCON_iocon_pio1_9_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_9_hys) -> &'b mut IOCON_iocon_pio1_9_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_9_od) -> &'b mut IOCON_iocon_pio1_9_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_9_func {
    /// Selects function PIO1_9.
    GPIO = 0,
    /// Selects function CT16B1_MAT0.
    CT16B1_CAP0 = 1,
    /// Selects function MOSI1.
    MOSI1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_9_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_9_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_9_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO3_4 implementation


/// Register `IOCON_PIO3_4`: I/O configuration for pin PIO3_4/ CT16B0_CAP1/RXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio3_4 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio3_4 { }

impl IOCON_iocon_pio3_4 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO3_4` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio3_4_Get {
        IOCON_iocon_pio3_4_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_4_func {
        IOCON_iocon_pio3_4_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_4_mode {
        IOCON_iocon_pio3_4_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_4_hys {
        IOCON_iocon_pio3_4_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_4_od {
        IOCON_iocon_pio3_4_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO3_4` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio3_4_Update {
        IOCON_iocon_pio3_4_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio3_4_func) -> IOCON_iocon_pio3_4_Update<'a> {
        let mut setter: IOCON_iocon_pio3_4_Update = IOCON_iocon_pio3_4_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio3_4_mode) -> IOCON_iocon_pio3_4_Update<'a> {
        let mut setter: IOCON_iocon_pio3_4_Update = IOCON_iocon_pio3_4_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio3_4_hys) -> IOCON_iocon_pio3_4_Update<'a> {
        let mut setter: IOCON_iocon_pio3_4_Update = IOCON_iocon_pio3_4_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio3_4_od) -> IOCON_iocon_pio3_4_Update<'a> {
        let mut setter: IOCON_iocon_pio3_4_Update = IOCON_iocon_pio3_4_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio3_4
/// `IOCON_PIO3_4`: I/O configuration for pin PIO3_4/ CT16B0_CAP1/RXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_4_Get {
    value: u32,
}

impl IOCON_iocon_pio3_4_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio3_4) -> IOCON_iocon_pio3_4_Get {
        IOCON_iocon_pio3_4_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_4_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_4_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_4_func::CT16B1_CAP0),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_4_func::RXD),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_4_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_4_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_4_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_4_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_4_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_4_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_4_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_4_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_4_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_4_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_4_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio3_4_Get { }


// Updater for IOCON_iocon_pio3_4
/// Updater for `IOCON_PIO3_4` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_4_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio3_4,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio3_4_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio3_4_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio3_4) -> IOCON_iocon_pio3_4_Update<'a> {
        IOCON_iocon_pio3_4_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio3_4) -> IOCON_iocon_pio3_4_Update<'a> {
        IOCON_iocon_pio3_4_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio3_4_func) -> &'b mut IOCON_iocon_pio3_4_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio3_4_mode) -> &'b mut IOCON_iocon_pio3_4_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio3_4_hys) -> &'b mut IOCON_iocon_pio3_4_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio3_4_od) -> &'b mut IOCON_iocon_pio3_4_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_4_func {
    /// Selects function PIO3_4.
    GPIO = 0,
    /// Selects function CT16B0_CAP1.
    CT16B1_CAP0 = 1,
    /// Selects function RXD.
    RXD = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_4_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_4_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_4_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_4 implementation


/// Register `IOCON_PIO2_4`: I/O configuration for pin PIO2_4/ CT16B1_MAT1/ SSEL1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_4 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_4 { }

impl IOCON_iocon_pio2_4 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_4` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_4_Get {
        IOCON_iocon_pio2_4_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_4_func {
        IOCON_iocon_pio2_4_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_4_mode {
        IOCON_iocon_pio2_4_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_4_hys {
        IOCON_iocon_pio2_4_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_4_od {
        IOCON_iocon_pio2_4_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_4` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_4_Update {
        IOCON_iocon_pio2_4_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_4_func) -> IOCON_iocon_pio2_4_Update<'a> {
        let mut setter: IOCON_iocon_pio2_4_Update = IOCON_iocon_pio2_4_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_4_mode) -> IOCON_iocon_pio2_4_Update<'a> {
        let mut setter: IOCON_iocon_pio2_4_Update = IOCON_iocon_pio2_4_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_4_hys) -> IOCON_iocon_pio2_4_Update<'a> {
        let mut setter: IOCON_iocon_pio2_4_Update = IOCON_iocon_pio2_4_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_4_od) -> IOCON_iocon_pio2_4_Update<'a> {
        let mut setter: IOCON_iocon_pio2_4_Update = IOCON_iocon_pio2_4_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_4
/// `IOCON_PIO2_4`: I/O configuration for pin PIO2_4/ CT16B1_MAT1/ SSEL1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_4_Get {
    value: u32,
}

impl IOCON_iocon_pio2_4_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_4) -> IOCON_iocon_pio2_4_Get {
        IOCON_iocon_pio2_4_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_4_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_4_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_4_func::CT16B1_CAP0),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_4_func::SSEL0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_4_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_4_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_4_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_4_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_4_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_4_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_4_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_4_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_4_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_4_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_4_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_4_Get { }


// Updater for IOCON_iocon_pio2_4
/// Updater for `IOCON_PIO2_4` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_4_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_4,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_4_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_4_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_4) -> IOCON_iocon_pio2_4_Update<'a> {
        IOCON_iocon_pio2_4_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_4) -> IOCON_iocon_pio2_4_Update<'a> {
        IOCON_iocon_pio2_4_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_4_func) -> &'b mut IOCON_iocon_pio2_4_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_4_mode) -> &'b mut IOCON_iocon_pio2_4_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_4_hys) -> &'b mut IOCON_iocon_pio2_4_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_4_od) -> &'b mut IOCON_iocon_pio2_4_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_4_func {
    /// Selects function PIO2_4.
    GPIO = 0,
    /// Selects function CT16B1_MAT1.
    CT16B1_CAP0 = 1,
    /// Selects function SSEL1.
    SSEL0 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_4_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_4_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_4_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_5 implementation


/// Register `IOCON_PIO2_5`: I/O configuration for pin PIO2_5/ CT32B0_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_5 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_5 { }

impl IOCON_iocon_pio2_5 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_5` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_5_Get {
        IOCON_iocon_pio2_5_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_5_func {
        IOCON_iocon_pio2_5_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_5_mode {
        IOCON_iocon_pio2_5_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_5_hys {
        IOCON_iocon_pio2_5_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_5_od {
        IOCON_iocon_pio2_5_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_5` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_5_Update {
        IOCON_iocon_pio2_5_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_5_func) -> IOCON_iocon_pio2_5_Update<'a> {
        let mut setter: IOCON_iocon_pio2_5_Update = IOCON_iocon_pio2_5_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_5_mode) -> IOCON_iocon_pio2_5_Update<'a> {
        let mut setter: IOCON_iocon_pio2_5_Update = IOCON_iocon_pio2_5_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_5_hys) -> IOCON_iocon_pio2_5_Update<'a> {
        let mut setter: IOCON_iocon_pio2_5_Update = IOCON_iocon_pio2_5_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_5_od) -> IOCON_iocon_pio2_5_Update<'a> {
        let mut setter: IOCON_iocon_pio2_5_Update = IOCON_iocon_pio2_5_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_5
/// `IOCON_PIO2_5`: I/O configuration for pin PIO2_5/ CT32B0_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_5_Get {
    value: u32,
}

impl IOCON_iocon_pio2_5_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_5) -> IOCON_iocon_pio2_5_Get {
        IOCON_iocon_pio2_5_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_5_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_5_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_5_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_5_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_5_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_5_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_5_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_5_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_5_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_5_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_5_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_5_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_5_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_5_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_5_Get { }


// Updater for IOCON_iocon_pio2_5
/// Updater for `IOCON_PIO2_5` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_5_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_5,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_5_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_5_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_5) -> IOCON_iocon_pio2_5_Update<'a> {
        IOCON_iocon_pio2_5_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_5) -> IOCON_iocon_pio2_5_Update<'a> {
        IOCON_iocon_pio2_5_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_5_func) -> &'b mut IOCON_iocon_pio2_5_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_5_mode) -> &'b mut IOCON_iocon_pio2_5_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_5_hys) -> &'b mut IOCON_iocon_pio2_5_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_5_od) -> &'b mut IOCON_iocon_pio2_5_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_5_func {
    /// Selects function PIO2_5.
    GPIO = 0,
    /// Selects function CT32B0_MAT0.
    CT32B0_MAT1 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_5_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_5_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_5_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO3_5 implementation


/// Register `IOCON_PIO3_5`: I/O configuration for pin PIO3_5/ CT16B1_CAP1/TXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio3_5 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio3_5 { }

impl IOCON_iocon_pio3_5 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO3_5` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio3_5_Get {
        IOCON_iocon_pio3_5_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_5_func {
        IOCON_iocon_pio3_5_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_5_mode {
        IOCON_iocon_pio3_5_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_5_hys {
        IOCON_iocon_pio3_5_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_5_od {
        IOCON_iocon_pio3_5_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO3_5` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio3_5_Update {
        IOCON_iocon_pio3_5_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio3_5_func) -> IOCON_iocon_pio3_5_Update<'a> {
        let mut setter: IOCON_iocon_pio3_5_Update = IOCON_iocon_pio3_5_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio3_5_mode) -> IOCON_iocon_pio3_5_Update<'a> {
        let mut setter: IOCON_iocon_pio3_5_Update = IOCON_iocon_pio3_5_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio3_5_hys) -> IOCON_iocon_pio3_5_Update<'a> {
        let mut setter: IOCON_iocon_pio3_5_Update = IOCON_iocon_pio3_5_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio3_5_od) -> IOCON_iocon_pio3_5_Update<'a> {
        let mut setter: IOCON_iocon_pio3_5_Update = IOCON_iocon_pio3_5_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio3_5
/// `IOCON_PIO3_5`: I/O configuration for pin PIO3_5/ CT16B1_CAP1/TXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_5_Get {
    value: u32,
}

impl IOCON_iocon_pio3_5_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio3_5) -> IOCON_iocon_pio3_5_Get {
        IOCON_iocon_pio3_5_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_5_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_5_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_5_func::CT16B1_CAP0),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_5_func::TXD),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_5_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_5_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_5_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_5_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_5_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_5_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_5_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_5_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_5_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_5_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_5_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio3_5_Get { }


// Updater for IOCON_iocon_pio3_5
/// Updater for `IOCON_PIO3_5` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_5_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio3_5,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio3_5_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio3_5_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio3_5) -> IOCON_iocon_pio3_5_Update<'a> {
        IOCON_iocon_pio3_5_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio3_5) -> IOCON_iocon_pio3_5_Update<'a> {
        IOCON_iocon_pio3_5_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio3_5_func) -> &'b mut IOCON_iocon_pio3_5_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio3_5_mode) -> &'b mut IOCON_iocon_pio3_5_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio3_5_hys) -> &'b mut IOCON_iocon_pio3_5_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio3_5_od) -> &'b mut IOCON_iocon_pio3_5_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_5_func {
    /// Selects function PIO3_5.
    GPIO = 0,
    /// Selects function CT16B1_CAP1.
    CT16B1_CAP0 = 1,
    /// Selects function TXD.
    TXD = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_5_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_5_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_5_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_6 implementation


/// Register `IOCON_PIO0_6`: I/O configuration for pin PIO0_6/SCK0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_6 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_6 { }

impl IOCON_iocon_pio0_6 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_6` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_6_Get {
        IOCON_iocon_pio0_6_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_6_func {
        IOCON_iocon_pio0_6_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_6_mode {
        IOCON_iocon_pio0_6_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_6_hys {
        IOCON_iocon_pio0_6_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_6_od {
        IOCON_iocon_pio0_6_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_6` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_6_Update {
        IOCON_iocon_pio0_6_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_6_func) -> IOCON_iocon_pio0_6_Update<'a> {
        let mut setter: IOCON_iocon_pio0_6_Update = IOCON_iocon_pio0_6_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_6_mode) -> IOCON_iocon_pio0_6_Update<'a> {
        let mut setter: IOCON_iocon_pio0_6_Update = IOCON_iocon_pio0_6_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio0_6_hys) -> IOCON_iocon_pio0_6_Update<'a> {
        let mut setter: IOCON_iocon_pio0_6_Update = IOCON_iocon_pio0_6_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio0_6_od) -> IOCON_iocon_pio0_6_Update<'a> {
        let mut setter: IOCON_iocon_pio0_6_Update = IOCON_iocon_pio0_6_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_6
/// `IOCON_PIO0_6`: I/O configuration for pin PIO0_6/SCK0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_6_Get {
    value: u32,
}

impl IOCON_iocon_pio0_6_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_6) -> IOCON_iocon_pio0_6_Get {
        IOCON_iocon_pio0_6_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_6_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_6_func::GPIO),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_6_func::SCK0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_6_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_6_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_6_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_6_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio0_6_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_6_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_6_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_6_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_6_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_6_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_6_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_6_Get { }


// Updater for IOCON_iocon_pio0_6
/// Updater for `IOCON_PIO0_6` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_6_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_6,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_6_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_6_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_6) -> IOCON_iocon_pio0_6_Update<'a> {
        IOCON_iocon_pio0_6_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_6) -> IOCON_iocon_pio0_6_Update<'a> {
        IOCON_iocon_pio0_6_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_6_func) -> &'b mut IOCON_iocon_pio0_6_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_6_mode) -> &'b mut IOCON_iocon_pio0_6_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio0_6_hys) -> &'b mut IOCON_iocon_pio0_6_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio0_6_od) -> &'b mut IOCON_iocon_pio0_6_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_6_func {
    /// Selects function PIO0_6.
    GPIO = 0,
    /// Selects function SCK0 (only if pin PIO0_6/SCK0 selected in Table 147).
    SCK0 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_6_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_6_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_6_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_7 implementation


/// Register `IOCON_PIO0_7`: I/O configuration for pin PIO0_7/CTS
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_7 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_7 { }

impl IOCON_iocon_pio0_7 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_7` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_7_Get {
        IOCON_iocon_pio0_7_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_7_func {
        IOCON_iocon_pio0_7_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_7_mode {
        IOCON_iocon_pio0_7_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_7_hys {
        IOCON_iocon_pio0_7_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_7_od {
        IOCON_iocon_pio0_7_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_7` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_7_Update {
        IOCON_iocon_pio0_7_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_7_func) -> IOCON_iocon_pio0_7_Update<'a> {
        let mut setter: IOCON_iocon_pio0_7_Update = IOCON_iocon_pio0_7_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_7_mode) -> IOCON_iocon_pio0_7_Update<'a> {
        let mut setter: IOCON_iocon_pio0_7_Update = IOCON_iocon_pio0_7_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio0_7_hys) -> IOCON_iocon_pio0_7_Update<'a> {
        let mut setter: IOCON_iocon_pio0_7_Update = IOCON_iocon_pio0_7_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio0_7_od) -> IOCON_iocon_pio0_7_Update<'a> {
        let mut setter: IOCON_iocon_pio0_7_Update = IOCON_iocon_pio0_7_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_7
/// `IOCON_PIO0_7`: I/O configuration for pin PIO0_7/CTS
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_7_Get {
    value: u32,
}

impl IOCON_iocon_pio0_7_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_7) -> IOCON_iocon_pio0_7_Get {
        IOCON_iocon_pio0_7_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_7_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_7_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_7_func::CTS),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_7_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_7_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_7_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_7_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio0_7_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_7_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_7_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_7_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_7_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_7_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_7_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_7_Get { }


// Updater for IOCON_iocon_pio0_7
/// Updater for `IOCON_PIO0_7` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_7_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_7,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_7_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_7_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_7) -> IOCON_iocon_pio0_7_Update<'a> {
        IOCON_iocon_pio0_7_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_7) -> IOCON_iocon_pio0_7_Update<'a> {
        IOCON_iocon_pio0_7_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_7_func) -> &'b mut IOCON_iocon_pio0_7_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_7_mode) -> &'b mut IOCON_iocon_pio0_7_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio0_7_hys) -> &'b mut IOCON_iocon_pio0_7_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio0_7_od) -> &'b mut IOCON_iocon_pio0_7_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_7_func {
    /// Selects function PIO0_7.
    GPIO = 0,
    /// Select function CTS.
    CTS = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_7_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_7_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_7_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_9 implementation


/// Register `IOCON_PIO2_9`: I/O configuration for pin PIO2_9/ CT32B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_9 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_9 { }

impl IOCON_iocon_pio2_9 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_9` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_9_Get {
        IOCON_iocon_pio2_9_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_9_func {
        IOCON_iocon_pio2_9_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_9_mode {
        IOCON_iocon_pio2_9_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_9_hys {
        IOCON_iocon_pio2_9_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_9_od {
        IOCON_iocon_pio2_9_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_9` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_9_Update {
        IOCON_iocon_pio2_9_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_9_func) -> IOCON_iocon_pio2_9_Update<'a> {
        let mut setter: IOCON_iocon_pio2_9_Update = IOCON_iocon_pio2_9_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_9_mode) -> IOCON_iocon_pio2_9_Update<'a> {
        let mut setter: IOCON_iocon_pio2_9_Update = IOCON_iocon_pio2_9_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_9_hys) -> IOCON_iocon_pio2_9_Update<'a> {
        let mut setter: IOCON_iocon_pio2_9_Update = IOCON_iocon_pio2_9_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_9_od) -> IOCON_iocon_pio2_9_Update<'a> {
        let mut setter: IOCON_iocon_pio2_9_Update = IOCON_iocon_pio2_9_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_9
/// `IOCON_PIO2_9`: I/O configuration for pin PIO2_9/ CT32B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_9_Get {
    value: u32,
}

impl IOCON_iocon_pio2_9_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_9) -> IOCON_iocon_pio2_9_Get {
        IOCON_iocon_pio2_9_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_9_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_9_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_9_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_9_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_9_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_9_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_9_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_9_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_9_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_9_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_9_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_9_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_9_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_9_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_9_Get { }


// Updater for IOCON_iocon_pio2_9
/// Updater for `IOCON_PIO2_9` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_9_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_9,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_9_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_9_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_9) -> IOCON_iocon_pio2_9_Update<'a> {
        IOCON_iocon_pio2_9_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_9) -> IOCON_iocon_pio2_9_Update<'a> {
        IOCON_iocon_pio2_9_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_9_func) -> &'b mut IOCON_iocon_pio2_9_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_9_mode) -> &'b mut IOCON_iocon_pio2_9_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_9_hys) -> &'b mut IOCON_iocon_pio2_9_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_9_od) -> &'b mut IOCON_iocon_pio2_9_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_9_func {
    /// Selects function PIO2_9.
    GPIO = 0,
    /// Selects function CT32B0_CAP0.
    CT32B0_MAT1 = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_9_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_9_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_9_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_10 implementation


/// Register `IOCON_PIO2_10`: I/O configuration for pin PIO2_10
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_10 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_10 { }

impl IOCON_iocon_pio2_10 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_10` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_10_Get {
        IOCON_iocon_pio2_10_Get::new(self)
    }

    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_10_mode {
        IOCON_iocon_pio2_10_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_10_hys {
        IOCON_iocon_pio2_10_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_10_od {
        IOCON_iocon_pio2_10_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_10` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_10_Update {
        IOCON_iocon_pio2_10_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_10_mode) -> IOCON_iocon_pio2_10_Update<'a> {
        let mut setter: IOCON_iocon_pio2_10_Update = IOCON_iocon_pio2_10_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_10_hys) -> IOCON_iocon_pio2_10_Update<'a> {
        let mut setter: IOCON_iocon_pio2_10_Update = IOCON_iocon_pio2_10_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_10_od) -> IOCON_iocon_pio2_10_Update<'a> {
        let mut setter: IOCON_iocon_pio2_10_Update = IOCON_iocon_pio2_10_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_10
/// `IOCON_PIO2_10`: I/O configuration for pin PIO2_10
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_10_Get {
    value: u32,
}

impl IOCON_iocon_pio2_10_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_10) -> IOCON_iocon_pio2_10_Get {
        IOCON_iocon_pio2_10_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_10_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_10_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_10_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_10_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_10_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_10_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_10_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_10_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_10_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_10_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_10_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_10_Get { }


// Updater for IOCON_iocon_pio2_10
/// Updater for `IOCON_PIO2_10` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_10_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_10,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_10_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_10_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_10) -> IOCON_iocon_pio2_10_Update<'a> {
        IOCON_iocon_pio2_10_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_10) -> IOCON_iocon_pio2_10_Update<'a> {
        IOCON_iocon_pio2_10_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_10_mode) -> &'b mut IOCON_iocon_pio2_10_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_10_hys) -> &'b mut IOCON_iocon_pio2_10_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_10_od) -> &'b mut IOCON_iocon_pio2_10_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_10_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_10_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_10_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_2 implementation


/// Register `IOCON_PIO2_2`: I/O configuration for pin PIO2_2/DCD/MISO1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_2 { }

impl IOCON_iocon_pio2_2 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_2` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_2_Get {
        IOCON_iocon_pio2_2_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_2_func {
        IOCON_iocon_pio2_2_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_2_mode {
        IOCON_iocon_pio2_2_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_2_hys {
        IOCON_iocon_pio2_2_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_2_od {
        IOCON_iocon_pio2_2_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_2_Update {
        IOCON_iocon_pio2_2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_2_func) -> IOCON_iocon_pio2_2_Update<'a> {
        let mut setter: IOCON_iocon_pio2_2_Update = IOCON_iocon_pio2_2_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_2_mode) -> IOCON_iocon_pio2_2_Update<'a> {
        let mut setter: IOCON_iocon_pio2_2_Update = IOCON_iocon_pio2_2_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_2_hys) -> IOCON_iocon_pio2_2_Update<'a> {
        let mut setter: IOCON_iocon_pio2_2_Update = IOCON_iocon_pio2_2_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_2_od) -> IOCON_iocon_pio2_2_Update<'a> {
        let mut setter: IOCON_iocon_pio2_2_Update = IOCON_iocon_pio2_2_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_2
/// `IOCON_PIO2_2`: I/O configuration for pin PIO2_2/DCD/MISO1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_2_Get {
    value: u32,
}

impl IOCON_iocon_pio2_2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_2) -> IOCON_iocon_pio2_2_Get {
        IOCON_iocon_pio2_2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_2_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_2_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_2_func::DCD),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_2_func::MISO1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_2_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_2_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_2_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_2_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_2_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_2_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_2_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_2_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_2_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_2_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_2_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_2_Get { }


// Updater for IOCON_iocon_pio2_2
/// Updater for `IOCON_PIO2_2` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_2,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_2) -> IOCON_iocon_pio2_2_Update<'a> {
        IOCON_iocon_pio2_2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_2) -> IOCON_iocon_pio2_2_Update<'a> {
        IOCON_iocon_pio2_2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_2_func) -> &'b mut IOCON_iocon_pio2_2_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_2_mode) -> &'b mut IOCON_iocon_pio2_2_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_2_hys) -> &'b mut IOCON_iocon_pio2_2_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_2_od) -> &'b mut IOCON_iocon_pio2_2_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_2_func {
    /// Selects function PIO2_2.
    GPIO = 0,
    /// Select function DCD.
    DCD = 1,
    /// Select function MISO1.
    MISO1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_2_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_2_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_2_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_8 implementation


/// Register `IOCON_PIO0_8`: I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_8 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_8 { }

impl IOCON_iocon_pio0_8 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_8` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_8_Get {
        IOCON_iocon_pio0_8_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_8_func {
        IOCON_iocon_pio0_8_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_8_mode {
        IOCON_iocon_pio0_8_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_8_hys {
        IOCON_iocon_pio0_8_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_8_od {
        IOCON_iocon_pio0_8_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_8` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_8_Update {
        IOCON_iocon_pio0_8_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_8_func) -> IOCON_iocon_pio0_8_Update<'a> {
        let mut setter: IOCON_iocon_pio0_8_Update = IOCON_iocon_pio0_8_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_8_mode) -> IOCON_iocon_pio0_8_Update<'a> {
        let mut setter: IOCON_iocon_pio0_8_Update = IOCON_iocon_pio0_8_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio0_8_hys) -> IOCON_iocon_pio0_8_Update<'a> {
        let mut setter: IOCON_iocon_pio0_8_Update = IOCON_iocon_pio0_8_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio0_8_od) -> IOCON_iocon_pio0_8_Update<'a> {
        let mut setter: IOCON_iocon_pio0_8_Update = IOCON_iocon_pio0_8_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_8
/// `IOCON_PIO0_8`: I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_8_Get {
    value: u32,
}

impl IOCON_iocon_pio0_8_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_8) -> IOCON_iocon_pio0_8_Get {
        IOCON_iocon_pio0_8_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_8_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_8_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_8_func::MISO0),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_8_func::CT16B1_CAP0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_8_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_8_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_8_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_8_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio0_8_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_8_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_8_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_8_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_8_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_8_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_8_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_8_Get { }


// Updater for IOCON_iocon_pio0_8
/// Updater for `IOCON_PIO0_8` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_8_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_8,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_8_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_8_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_8) -> IOCON_iocon_pio0_8_Update<'a> {
        IOCON_iocon_pio0_8_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_8) -> IOCON_iocon_pio0_8_Update<'a> {
        IOCON_iocon_pio0_8_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_8_func) -> &'b mut IOCON_iocon_pio0_8_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_8_mode) -> &'b mut IOCON_iocon_pio0_8_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio0_8_hys) -> &'b mut IOCON_iocon_pio0_8_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio0_8_od) -> &'b mut IOCON_iocon_pio0_8_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_8_func {
    /// Selects function PIO0_8.
    GPIO = 0,
    /// Selects function MISO0.
    MISO0 = 1,
    /// Selects function CT16B0_MAT0.
    CT16B1_CAP0 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_8_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_8_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_8_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO0_9 implementation


/// Register `IOCON_PIO0_9`: I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio0_9 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio0_9 { }

impl IOCON_iocon_pio0_9 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO0_9` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio0_9_Get {
        IOCON_iocon_pio0_9_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_9_func {
        IOCON_iocon_pio0_9_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_9_mode {
        IOCON_iocon_pio0_9_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_9_hys {
        IOCON_iocon_pio0_9_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_9_od {
        IOCON_iocon_pio0_9_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO0_9` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio0_9_Update {
        IOCON_iocon_pio0_9_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio0_9_func) -> IOCON_iocon_pio0_9_Update<'a> {
        let mut setter: IOCON_iocon_pio0_9_Update = IOCON_iocon_pio0_9_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio0_9_mode) -> IOCON_iocon_pio0_9_Update<'a> {
        let mut setter: IOCON_iocon_pio0_9_Update = IOCON_iocon_pio0_9_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio0_9_hys) -> IOCON_iocon_pio0_9_Update<'a> {
        let mut setter: IOCON_iocon_pio0_9_Update = IOCON_iocon_pio0_9_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio0_9_od) -> IOCON_iocon_pio0_9_Update<'a> {
        let mut setter: IOCON_iocon_pio0_9_Update = IOCON_iocon_pio0_9_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio0_9
/// `IOCON_PIO0_9`: I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_9_Get {
    value: u32,
}

impl IOCON_iocon_pio0_9_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio0_9) -> IOCON_iocon_pio0_9_Get {
        IOCON_iocon_pio0_9_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio0_9_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_9_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_9_func::MOSI1),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_9_func::CT16B1_CAP0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio0_9_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_9_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_9_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio0_9_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio0_9_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio0_9_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_9_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_9_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio0_9_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio0_9_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio0_9_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio0_9_Get { }


// Updater for IOCON_iocon_pio0_9
/// Updater for `IOCON_PIO0_9` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio0_9_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio0_9,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio0_9_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio0_9_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio0_9) -> IOCON_iocon_pio0_9_Update<'a> {
        IOCON_iocon_pio0_9_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio0_9) -> IOCON_iocon_pio0_9_Update<'a> {
        IOCON_iocon_pio0_9_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio0_9_func) -> &'b mut IOCON_iocon_pio0_9_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio0_9_mode) -> &'b mut IOCON_iocon_pio0_9_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio0_9_hys) -> &'b mut IOCON_iocon_pio0_9_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio0_9_od) -> &'b mut IOCON_iocon_pio0_9_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_9_func {
    /// Selects function PIO0_9.
    GPIO = 0,
    /// Selects function MOSI0.
    MOSI1 = 1,
    /// Selects function CT16B0_MAT1.
    CT16B1_CAP0 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_9_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_9_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio0_9_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_SWCLK_PIO0_10 implementation


/// Register `IOCON_SWCLK_PIO0_10`: I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_swclk_pio0_10 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_swclk_pio0_10 { }

impl IOCON_iocon_swclk_pio0_10 {
    
    // Getters
    /// Fetch the value of the `IOCON_SWCLK_PIO0_10` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_swclk_pio0_10_Get {
        IOCON_iocon_swclk_pio0_10_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_swclk_pio0_10_func {
        IOCON_iocon_swclk_pio0_10_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_swclk_pio0_10_mode {
        IOCON_iocon_swclk_pio0_10_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_swclk_pio0_10_hys {
        IOCON_iocon_swclk_pio0_10_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_swclk_pio0_10_od {
        IOCON_iocon_swclk_pio0_10_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_SWCLK_PIO0_10` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_swclk_pio0_10_Update {
        IOCON_iocon_swclk_pio0_10_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_swclk_pio0_10_func) -> IOCON_iocon_swclk_pio0_10_Update<'a> {
        let mut setter: IOCON_iocon_swclk_pio0_10_Update = IOCON_iocon_swclk_pio0_10_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_swclk_pio0_10_mode) -> IOCON_iocon_swclk_pio0_10_Update<'a> {
        let mut setter: IOCON_iocon_swclk_pio0_10_Update = IOCON_iocon_swclk_pio0_10_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_swclk_pio0_10_hys) -> IOCON_iocon_swclk_pio0_10_Update<'a> {
        let mut setter: IOCON_iocon_swclk_pio0_10_Update = IOCON_iocon_swclk_pio0_10_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_swclk_pio0_10_od) -> IOCON_iocon_swclk_pio0_10_Update<'a> {
        let mut setter: IOCON_iocon_swclk_pio0_10_Update = IOCON_iocon_swclk_pio0_10_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_swclk_pio0_10
/// `IOCON_SWCLK_PIO0_10`: I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_swclk_pio0_10_Get {
    value: u32,
}

impl IOCON_iocon_swclk_pio0_10_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_swclk_pio0_10) -> IOCON_iocon_swclk_pio0_10_Get {
        IOCON_iocon_swclk_pio0_10_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_swclk_pio0_10_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_func::SWCLK),
            1 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_func::GPIO),
            2 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_func::SCK0),
            3 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_func::CT16B1_CAP0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_swclk_pio0_10_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_swclk_pio0_10_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_swclk_pio0_10_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_swclk_pio0_10_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_swclk_pio0_10_Get { }


// Updater for IOCON_iocon_swclk_pio0_10
/// Updater for `IOCON_SWCLK_PIO0_10` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_swclk_pio0_10_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_swclk_pio0_10,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_swclk_pio0_10_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_swclk_pio0_10_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_swclk_pio0_10) -> IOCON_iocon_swclk_pio0_10_Update<'a> {
        IOCON_iocon_swclk_pio0_10_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_swclk_pio0_10) -> IOCON_iocon_swclk_pio0_10_Update<'a> {
        IOCON_iocon_swclk_pio0_10_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_swclk_pio0_10_func) -> &'b mut IOCON_iocon_swclk_pio0_10_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_swclk_pio0_10_mode) -> &'b mut IOCON_iocon_swclk_pio0_10_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_swclk_pio0_10_hys) -> &'b mut IOCON_iocon_swclk_pio0_10_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_swclk_pio0_10_od) -> &'b mut IOCON_iocon_swclk_pio0_10_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swclk_pio0_10_func {
    /// Selects function SWCLK.
    SWCLK = 0,
    /// Selects function PIO0_10.
    GPIO = 1,
    /// Selects function SCK0 (only if pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 selected in Table 147).
    SCK0 = 2,
    /// Selects function CT16B0_MAT2.
    CT16B1_CAP0 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swclk_pio0_10_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swclk_pio0_10_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swclk_pio0_10_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO1_10 implementation


/// Register `IOCON_PIO1_10`: I/O configuration for pin PIO1_10/AD6/CT16B1_MAT1/ MISO1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_10 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_10 { }

impl IOCON_iocon_pio1_10 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_10` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_10_Get {
        IOCON_iocon_pio1_10_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_10_func {
        IOCON_iocon_pio1_10_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_10_mode {
        IOCON_iocon_pio1_10_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_10_hys {
        IOCON_iocon_pio1_10_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_pio1_10_admode {
        IOCON_iocon_pio1_10_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_10_od {
        IOCON_iocon_pio1_10_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_10` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_10_Update {
        IOCON_iocon_pio1_10_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_10_func) -> IOCON_iocon_pio1_10_Update<'a> {
        let mut setter: IOCON_iocon_pio1_10_Update = IOCON_iocon_pio1_10_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_10_mode) -> IOCON_iocon_pio1_10_Update<'a> {
        let mut setter: IOCON_iocon_pio1_10_Update = IOCON_iocon_pio1_10_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_10_hys) -> IOCON_iocon_pio1_10_Update<'a> {
        let mut setter: IOCON_iocon_pio1_10_Update = IOCON_iocon_pio1_10_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_10_admode) -> IOCON_iocon_pio1_10_Update<'a> {
        let mut setter: IOCON_iocon_pio1_10_Update = IOCON_iocon_pio1_10_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_10_od) -> IOCON_iocon_pio1_10_Update<'a> {
        let mut setter: IOCON_iocon_pio1_10_Update = IOCON_iocon_pio1_10_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_10
/// `IOCON_PIO1_10`: I/O configuration for pin PIO1_10/AD6/CT16B1_MAT1/ MISO1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_10_Get {
    value: u32,
}

impl IOCON_iocon_pio1_10_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_10) -> IOCON_iocon_pio1_10_Get {
        IOCON_iocon_pio1_10_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_10_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_10_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_10_func::AD6),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_10_func::CT16B1_CAP0),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_10_func::MISO1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_10_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_10_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_10_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_10_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_10_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_10_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_10_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_10_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_pio1_10_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_10_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_10_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_10_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_10_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_10_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_10_Get { }


// Updater for IOCON_iocon_pio1_10
/// Updater for `IOCON_PIO1_10` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_10_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_10,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_10_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_10_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_10) -> IOCON_iocon_pio1_10_Update<'a> {
        IOCON_iocon_pio1_10_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_10) -> IOCON_iocon_pio1_10_Update<'a> {
        IOCON_iocon_pio1_10_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_10_func) -> &'b mut IOCON_iocon_pio1_10_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_10_mode) -> &'b mut IOCON_iocon_pio1_10_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_10_hys) -> &'b mut IOCON_iocon_pio1_10_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_10_admode) -> &'b mut IOCON_iocon_pio1_10_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_10_od) -> &'b mut IOCON_iocon_pio1_10_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_10_func {
    /// Selects function PIO1_10.
    GPIO = 0,
    /// Selects function AD6.
    AD6 = 1,
    /// Selects function CT16B1_MAT1.
    CT16B1_CAP0 = 2,
    /// Selects function MISO1.
    MISO1 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_10_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_10_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_10_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_10_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_11 implementation


/// Register `IOCON_PIO2_11`: I/O configuration for pin PIO2_11/SCK0/ CT32B0_CAP1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_11 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_11 { }

impl IOCON_iocon_pio2_11 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_11` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_11_Get {
        IOCON_iocon_pio2_11_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_11_func {
        IOCON_iocon_pio2_11_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_11_mode {
        IOCON_iocon_pio2_11_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_11_hys {
        IOCON_iocon_pio2_11_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_11_od {
        IOCON_iocon_pio2_11_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_11` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_11_Update {
        IOCON_iocon_pio2_11_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_11_func) -> IOCON_iocon_pio2_11_Update<'a> {
        let mut setter: IOCON_iocon_pio2_11_Update = IOCON_iocon_pio2_11_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_11_mode) -> IOCON_iocon_pio2_11_Update<'a> {
        let mut setter: IOCON_iocon_pio2_11_Update = IOCON_iocon_pio2_11_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_11_hys) -> IOCON_iocon_pio2_11_Update<'a> {
        let mut setter: IOCON_iocon_pio2_11_Update = IOCON_iocon_pio2_11_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_11_od) -> IOCON_iocon_pio2_11_Update<'a> {
        let mut setter: IOCON_iocon_pio2_11_Update = IOCON_iocon_pio2_11_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_11
/// `IOCON_PIO2_11`: I/O configuration for pin PIO2_11/SCK0/ CT32B0_CAP1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_11_Get {
    value: u32,
}

impl IOCON_iocon_pio2_11_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_11) -> IOCON_iocon_pio2_11_Get {
        IOCON_iocon_pio2_11_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_11_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_11_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_11_func::SCK0),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_11_func::CT32B0_CAP1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_11_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_11_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_11_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_11_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_11_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_11_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_11_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_11_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_11_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_11_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_11_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_11_Get { }


// Updater for IOCON_iocon_pio2_11
/// Updater for `IOCON_PIO2_11` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_11_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_11,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_11_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_11_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_11) -> IOCON_iocon_pio2_11_Update<'a> {
        IOCON_iocon_pio2_11_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_11) -> IOCON_iocon_pio2_11_Update<'a> {
        IOCON_iocon_pio2_11_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_11_func) -> &'b mut IOCON_iocon_pio2_11_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_11_mode) -> &'b mut IOCON_iocon_pio2_11_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_11_hys) -> &'b mut IOCON_iocon_pio2_11_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_11_od) -> &'b mut IOCON_iocon_pio2_11_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_11_func {
    /// Selects function PIO2_11.
    GPIO = 0,
    /// Select function SCK0 (only if pin PIO2_11/SCK0 selected in  Table 147).
    SCK0 = 1,
    /// Select function CT32B0_CAP1.
    CT32B0_CAP1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_11_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_11_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_11_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_R_PIO0_11 implementation


/// Register `IOCON_R_PIO0_11`: I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_r_pio0_11 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_r_pio0_11 { }

impl IOCON_iocon_r_pio0_11 {
    
    // Getters
    /// Fetch the value of the `IOCON_R_PIO0_11` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_r_pio0_11_Get {
        IOCON_iocon_r_pio0_11_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio0_11_func {
        IOCON_iocon_r_pio0_11_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio0_11_mode {
        IOCON_iocon_r_pio0_11_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio0_11_hys {
        IOCON_iocon_r_pio0_11_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio0_11_admode {
        IOCON_iocon_r_pio0_11_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio0_11_od {
        IOCON_iocon_r_pio0_11_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_R_PIO0_11` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_r_pio0_11_Update {
        IOCON_iocon_r_pio0_11_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_r_pio0_11_func) -> IOCON_iocon_r_pio0_11_Update<'a> {
        let mut setter: IOCON_iocon_r_pio0_11_Update = IOCON_iocon_r_pio0_11_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio0_11_mode) -> IOCON_iocon_r_pio0_11_Update<'a> {
        let mut setter: IOCON_iocon_r_pio0_11_Update = IOCON_iocon_r_pio0_11_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_r_pio0_11_hys) -> IOCON_iocon_r_pio0_11_Update<'a> {
        let mut setter: IOCON_iocon_r_pio0_11_Update = IOCON_iocon_r_pio0_11_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio0_11_admode) -> IOCON_iocon_r_pio0_11_Update<'a> {
        let mut setter: IOCON_iocon_r_pio0_11_Update = IOCON_iocon_r_pio0_11_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_r_pio0_11_od) -> IOCON_iocon_r_pio0_11_Update<'a> {
        let mut setter: IOCON_iocon_r_pio0_11_Update = IOCON_iocon_r_pio0_11_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_r_pio0_11
/// `IOCON_R_PIO0_11`: I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio0_11_Get {
    value: u32,
}

impl IOCON_iocon_r_pio0_11_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_r_pio0_11) -> IOCON_iocon_r_pio0_11_Get {
        IOCON_iocon_r_pio0_11_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio0_11_func {
        match (self.value >> 0) & 7 {
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_func::GPIO),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_func::AD0),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio0_11_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio0_11_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio0_11_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio0_11_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio0_11_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_r_pio0_11_Get { }


// Updater for IOCON_iocon_r_pio0_11
/// Updater for `IOCON_R_PIO0_11` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio0_11_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_r_pio0_11,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_r_pio0_11_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_r_pio0_11_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_r_pio0_11) -> IOCON_iocon_r_pio0_11_Update<'a> {
        IOCON_iocon_r_pio0_11_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_r_pio0_11) -> IOCON_iocon_r_pio0_11_Update<'a> {
        IOCON_iocon_r_pio0_11_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_r_pio0_11_func) -> &'b mut IOCON_iocon_r_pio0_11_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio0_11_mode) -> &'b mut IOCON_iocon_r_pio0_11_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_r_pio0_11_hys) -> &'b mut IOCON_iocon_r_pio0_11_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio0_11_admode) -> &'b mut IOCON_iocon_r_pio0_11_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_r_pio0_11_od) -> &'b mut IOCON_iocon_r_pio0_11_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio0_11_func {
    /// Selects function PIO0_11.
    GPIO = 1,
    /// Selects function AD0.
    AD0 = 2,
    /// Selects function CT32B0_MAT3.
    CT32B0_MAT1 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio0_11_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio0_11_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio0_11_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio0_11_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_R_PIO1_0 implementation


/// Register `IOCON_R_PIO1_0`: I/O configuration for pin R/PIO1_0/AD1/CT32B1_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_r_pio1_0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_r_pio1_0 { }

impl IOCON_iocon_r_pio1_0 {
    
    // Getters
    /// Fetch the value of the `IOCON_R_PIO1_0` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_r_pio1_0_Get {
        IOCON_iocon_r_pio1_0_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio1_0_func {
        IOCON_iocon_r_pio1_0_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio1_0_mode {
        IOCON_iocon_r_pio1_0_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio1_0_hys {
        IOCON_iocon_r_pio1_0_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio1_0_admode {
        IOCON_iocon_r_pio1_0_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio1_0_od {
        IOCON_iocon_r_pio1_0_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_R_PIO1_0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_r_pio1_0_Update {
        IOCON_iocon_r_pio1_0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_0_func) -> IOCON_iocon_r_pio1_0_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_0_Update = IOCON_iocon_r_pio1_0_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_0_mode) -> IOCON_iocon_r_pio1_0_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_0_Update = IOCON_iocon_r_pio1_0_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_0_hys) -> IOCON_iocon_r_pio1_0_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_0_Update = IOCON_iocon_r_pio1_0_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_0_admode) -> IOCON_iocon_r_pio1_0_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_0_Update = IOCON_iocon_r_pio1_0_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_0_od) -> IOCON_iocon_r_pio1_0_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_0_Update = IOCON_iocon_r_pio1_0_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_r_pio1_0
/// `IOCON_R_PIO1_0`: I/O configuration for pin R/PIO1_0/AD1/CT32B1_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio1_0_Get {
    value: u32,
}

impl IOCON_iocon_r_pio1_0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_r_pio1_0) -> IOCON_iocon_r_pio1_0_Get {
        IOCON_iocon_r_pio1_0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio1_0_func {
        match (self.value >> 0) & 7 {
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_func::GPIO),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_func::AD1),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio1_0_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio1_0_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio1_0_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio1_0_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_0_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_r_pio1_0_Get { }


// Updater for IOCON_iocon_r_pio1_0
/// Updater for `IOCON_R_PIO1_0` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio1_0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_r_pio1_0,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_r_pio1_0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_r_pio1_0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_r_pio1_0) -> IOCON_iocon_r_pio1_0_Update<'a> {
        IOCON_iocon_r_pio1_0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_r_pio1_0) -> IOCON_iocon_r_pio1_0_Update<'a> {
        IOCON_iocon_r_pio1_0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_0_func) -> &'b mut IOCON_iocon_r_pio1_0_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_0_mode) -> &'b mut IOCON_iocon_r_pio1_0_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_0_hys) -> &'b mut IOCON_iocon_r_pio1_0_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_0_admode) -> &'b mut IOCON_iocon_r_pio1_0_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_0_od) -> &'b mut IOCON_iocon_r_pio1_0_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_0_func {
    /// Selects function PIO1_0.
    GPIO = 1,
    /// Selects function AD1.
    AD1 = 2,
    /// Selects function CT32B1_CAP0.
    CT32B0_MAT1 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_0_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_0_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_0_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_0_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_R_PIO1_1 implementation


/// Register `IOCON_R_PIO1_1`: I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_r_pio1_1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_r_pio1_1 { }

impl IOCON_iocon_r_pio1_1 {
    
    // Getters
    /// Fetch the value of the `IOCON_R_PIO1_1` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_r_pio1_1_Get {
        IOCON_iocon_r_pio1_1_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio1_1_func {
        IOCON_iocon_r_pio1_1_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio1_1_mode {
        IOCON_iocon_r_pio1_1_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio1_1_hys {
        IOCON_iocon_r_pio1_1_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio1_1_admode {
        IOCON_iocon_r_pio1_1_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio1_1_od {
        IOCON_iocon_r_pio1_1_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_R_PIO1_1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_r_pio1_1_Update {
        IOCON_iocon_r_pio1_1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_1_func) -> IOCON_iocon_r_pio1_1_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_1_Update = IOCON_iocon_r_pio1_1_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_1_mode) -> IOCON_iocon_r_pio1_1_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_1_Update = IOCON_iocon_r_pio1_1_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_1_hys) -> IOCON_iocon_r_pio1_1_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_1_Update = IOCON_iocon_r_pio1_1_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_1_admode) -> IOCON_iocon_r_pio1_1_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_1_Update = IOCON_iocon_r_pio1_1_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_1_od) -> IOCON_iocon_r_pio1_1_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_1_Update = IOCON_iocon_r_pio1_1_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_r_pio1_1
/// `IOCON_R_PIO1_1`: I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio1_1_Get {
    value: u32,
}

impl IOCON_iocon_r_pio1_1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_r_pio1_1) -> IOCON_iocon_r_pio1_1_Get {
        IOCON_iocon_r_pio1_1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio1_1_func {
        match (self.value >> 0) & 7 {
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_func::GPIO),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_func::AD2),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio1_1_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio1_1_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio1_1_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio1_1_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_1_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_r_pio1_1_Get { }


// Updater for IOCON_iocon_r_pio1_1
/// Updater for `IOCON_R_PIO1_1` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio1_1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_r_pio1_1,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_r_pio1_1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_r_pio1_1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_r_pio1_1) -> IOCON_iocon_r_pio1_1_Update<'a> {
        IOCON_iocon_r_pio1_1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_r_pio1_1) -> IOCON_iocon_r_pio1_1_Update<'a> {
        IOCON_iocon_r_pio1_1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_1_func) -> &'b mut IOCON_iocon_r_pio1_1_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_1_mode) -> &'b mut IOCON_iocon_r_pio1_1_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_1_hys) -> &'b mut IOCON_iocon_r_pio1_1_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_1_admode) -> &'b mut IOCON_iocon_r_pio1_1_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_1_od) -> &'b mut IOCON_iocon_r_pio1_1_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_1_func {
    /// Selects function PIO1_1.
    GPIO = 1,
    /// Selects function AD2.
    AD2 = 2,
    /// Selects function CT32B1_MAT0.
    CT32B0_MAT1 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_1_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_1_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_1_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_1_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_R_PIO1_2 implementation


/// Register `IOCON_R_PIO1_2`: I/O configuration for pin R/PIO1_2/AD3/CT32B1_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_r_pio1_2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_r_pio1_2 { }

impl IOCON_iocon_r_pio1_2 {
    
    // Getters
    /// Fetch the value of the `IOCON_R_PIO1_2` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_r_pio1_2_Get {
        IOCON_iocon_r_pio1_2_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio1_2_func {
        IOCON_iocon_r_pio1_2_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio1_2_mode {
        IOCON_iocon_r_pio1_2_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio1_2_hys {
        IOCON_iocon_r_pio1_2_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio1_2_admode {
        IOCON_iocon_r_pio1_2_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio1_2_od {
        IOCON_iocon_r_pio1_2_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_R_PIO1_2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_r_pio1_2_Update {
        IOCON_iocon_r_pio1_2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_2_func) -> IOCON_iocon_r_pio1_2_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_2_Update = IOCON_iocon_r_pio1_2_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_2_mode) -> IOCON_iocon_r_pio1_2_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_2_Update = IOCON_iocon_r_pio1_2_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_2_hys) -> IOCON_iocon_r_pio1_2_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_2_Update = IOCON_iocon_r_pio1_2_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_2_admode) -> IOCON_iocon_r_pio1_2_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_2_Update = IOCON_iocon_r_pio1_2_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_r_pio1_2_od) -> IOCON_iocon_r_pio1_2_Update<'a> {
        let mut setter: IOCON_iocon_r_pio1_2_Update = IOCON_iocon_r_pio1_2_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_r_pio1_2
/// `IOCON_R_PIO1_2`: I/O configuration for pin R/PIO1_2/AD3/CT32B1_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio1_2_Get {
    value: u32,
}

impl IOCON_iocon_r_pio1_2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_r_pio1_2) -> IOCON_iocon_r_pio1_2_Get {
        IOCON_iocon_r_pio1_2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_r_pio1_2_func {
        match (self.value >> 0) & 7 {
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_func::GPIO),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_func::AD3),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_r_pio1_2_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_r_pio1_2_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_r_pio1_2_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_r_pio1_2_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_r_pio1_2_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_r_pio1_2_Get { }


// Updater for IOCON_iocon_r_pio1_2
/// Updater for `IOCON_R_PIO1_2` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_r_pio1_2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_r_pio1_2,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_r_pio1_2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_r_pio1_2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_r_pio1_2) -> IOCON_iocon_r_pio1_2_Update<'a> {
        IOCON_iocon_r_pio1_2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_r_pio1_2) -> IOCON_iocon_r_pio1_2_Update<'a> {
        IOCON_iocon_r_pio1_2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_2_func) -> &'b mut IOCON_iocon_r_pio1_2_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_2_mode) -> &'b mut IOCON_iocon_r_pio1_2_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_2_hys) -> &'b mut IOCON_iocon_r_pio1_2_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_2_admode) -> &'b mut IOCON_iocon_r_pio1_2_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_r_pio1_2_od) -> &'b mut IOCON_iocon_r_pio1_2_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_2_func {
    /// Selects function PIO1_2.
    GPIO = 1,
    /// Selects function AD3.
    AD3 = 2,
    /// Selects function CT32B1_MAT1.
    CT32B0_MAT1 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_2_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_2_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_2_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_r_pio1_2_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO3_0 implementation


/// Register `IOCON_PIO3_0`: I/O configuration for pin PIO3_0/DTR/CT16B0_MAT0/TXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio3_0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio3_0 { }

impl IOCON_iocon_pio3_0 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO3_0` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio3_0_Get {
        IOCON_iocon_pio3_0_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_0_func {
        IOCON_iocon_pio3_0_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_0_mode {
        IOCON_iocon_pio3_0_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_0_hys {
        IOCON_iocon_pio3_0_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_0_od {
        IOCON_iocon_pio3_0_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO3_0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio3_0_Update {
        IOCON_iocon_pio3_0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio3_0_func) -> IOCON_iocon_pio3_0_Update<'a> {
        let mut setter: IOCON_iocon_pio3_0_Update = IOCON_iocon_pio3_0_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio3_0_mode) -> IOCON_iocon_pio3_0_Update<'a> {
        let mut setter: IOCON_iocon_pio3_0_Update = IOCON_iocon_pio3_0_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio3_0_hys) -> IOCON_iocon_pio3_0_Update<'a> {
        let mut setter: IOCON_iocon_pio3_0_Update = IOCON_iocon_pio3_0_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio3_0_od) -> IOCON_iocon_pio3_0_Update<'a> {
        let mut setter: IOCON_iocon_pio3_0_Update = IOCON_iocon_pio3_0_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio3_0
/// `IOCON_PIO3_0`: I/O configuration for pin PIO3_0/DTR/CT16B0_MAT0/TXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_0_Get {
    value: u32,
}

impl IOCON_iocon_pio3_0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio3_0) -> IOCON_iocon_pio3_0_Get {
        IOCON_iocon_pio3_0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_0_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_0_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_0_func::DTR),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_0_func::CT16B1_CAP0),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_0_func::TXD),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_0_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_0_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_0_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_0_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_0_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_0_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_0_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_0_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_0_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_0_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_0_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio3_0_Get { }


// Updater for IOCON_iocon_pio3_0
/// Updater for `IOCON_PIO3_0` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio3_0,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio3_0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio3_0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio3_0) -> IOCON_iocon_pio3_0_Update<'a> {
        IOCON_iocon_pio3_0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio3_0) -> IOCON_iocon_pio3_0_Update<'a> {
        IOCON_iocon_pio3_0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio3_0_func) -> &'b mut IOCON_iocon_pio3_0_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio3_0_mode) -> &'b mut IOCON_iocon_pio3_0_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio3_0_hys) -> &'b mut IOCON_iocon_pio3_0_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio3_0_od) -> &'b mut IOCON_iocon_pio3_0_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_0_func {
    /// Selects function PIO3_0.
    GPIO = 0,
    /// Selects function DTR.
    DTR = 1,
    /// Selects function CT16B0_MAT0.
    CT16B1_CAP0 = 2,
    /// Selects function TXD.
    TXD = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_0_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_0_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_0_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO3_1 implementation


/// Register `IOCON_PIO3_1`: I/O configuration for pin PIO3_1/DSR/CT16B0_MAT1/RXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio3_1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio3_1 { }

impl IOCON_iocon_pio3_1 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO3_1` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio3_1_Get {
        IOCON_iocon_pio3_1_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_1_func {
        IOCON_iocon_pio3_1_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_1_mode {
        IOCON_iocon_pio3_1_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_1_hys {
        IOCON_iocon_pio3_1_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_1_od {
        IOCON_iocon_pio3_1_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO3_1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio3_1_Update {
        IOCON_iocon_pio3_1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio3_1_func) -> IOCON_iocon_pio3_1_Update<'a> {
        let mut setter: IOCON_iocon_pio3_1_Update = IOCON_iocon_pio3_1_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio3_1_mode) -> IOCON_iocon_pio3_1_Update<'a> {
        let mut setter: IOCON_iocon_pio3_1_Update = IOCON_iocon_pio3_1_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio3_1_hys) -> IOCON_iocon_pio3_1_Update<'a> {
        let mut setter: IOCON_iocon_pio3_1_Update = IOCON_iocon_pio3_1_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio3_1_od) -> IOCON_iocon_pio3_1_Update<'a> {
        let mut setter: IOCON_iocon_pio3_1_Update = IOCON_iocon_pio3_1_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio3_1
/// `IOCON_PIO3_1`: I/O configuration for pin PIO3_1/DSR/CT16B0_MAT1/RXD
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_1_Get {
    value: u32,
}

impl IOCON_iocon_pio3_1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio3_1) -> IOCON_iocon_pio3_1_Get {
        IOCON_iocon_pio3_1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_1_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_1_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_1_func::DSR),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_1_func::CT16B1_CAP0),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_1_func::RXD),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_1_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_1_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_1_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_1_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_1_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_1_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_1_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_1_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_1_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_1_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_1_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio3_1_Get { }


// Updater for IOCON_iocon_pio3_1
/// Updater for `IOCON_PIO3_1` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio3_1,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio3_1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio3_1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio3_1) -> IOCON_iocon_pio3_1_Update<'a> {
        IOCON_iocon_pio3_1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio3_1) -> IOCON_iocon_pio3_1_Update<'a> {
        IOCON_iocon_pio3_1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio3_1_func) -> &'b mut IOCON_iocon_pio3_1_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio3_1_mode) -> &'b mut IOCON_iocon_pio3_1_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio3_1_hys) -> &'b mut IOCON_iocon_pio3_1_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio3_1_od) -> &'b mut IOCON_iocon_pio3_1_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_1_func {
    /// Selects function PIO3_1.
    GPIO = 0,
    /// Selects function DSR.
    DSR = 1,
    /// Selects function CT16B0_MAT1.
    CT16B1_CAP0 = 2,
    /// Selects function RXD.
    RXD = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_1_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_1_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_1_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO2_3 implementation


/// Register `IOCON_PIO2_3`: I/O configuration for pin PIO2_3/RI/MOSI1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio2_3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio2_3 { }

impl IOCON_iocon_pio2_3 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO2_3` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio2_3_Get {
        IOCON_iocon_pio2_3_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_3_func {
        IOCON_iocon_pio2_3_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_3_mode {
        IOCON_iocon_pio2_3_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_3_hys {
        IOCON_iocon_pio2_3_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_3_od {
        IOCON_iocon_pio2_3_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO2_3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio2_3_Update {
        IOCON_iocon_pio2_3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio2_3_func) -> IOCON_iocon_pio2_3_Update<'a> {
        let mut setter: IOCON_iocon_pio2_3_Update = IOCON_iocon_pio2_3_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio2_3_mode) -> IOCON_iocon_pio2_3_Update<'a> {
        let mut setter: IOCON_iocon_pio2_3_Update = IOCON_iocon_pio2_3_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio2_3_hys) -> IOCON_iocon_pio2_3_Update<'a> {
        let mut setter: IOCON_iocon_pio2_3_Update = IOCON_iocon_pio2_3_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio2_3_od) -> IOCON_iocon_pio2_3_Update<'a> {
        let mut setter: IOCON_iocon_pio2_3_Update = IOCON_iocon_pio2_3_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio2_3
/// `IOCON_PIO2_3`: I/O configuration for pin PIO2_3/RI/MOSI1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_3_Get {
    value: u32,
}

impl IOCON_iocon_pio2_3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio2_3) -> IOCON_iocon_pio2_3_Get {
        IOCON_iocon_pio2_3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio2_3_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_3_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_3_func::RI),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_3_func::MOSI1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio2_3_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_3_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_3_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio2_3_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio2_3_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio2_3_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_3_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_3_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio2_3_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio2_3_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio2_3_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio2_3_Get { }


// Updater for IOCON_iocon_pio2_3
/// Updater for `IOCON_PIO2_3` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio2_3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio2_3,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio2_3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio2_3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio2_3) -> IOCON_iocon_pio2_3_Update<'a> {
        IOCON_iocon_pio2_3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio2_3) -> IOCON_iocon_pio2_3_Update<'a> {
        IOCON_iocon_pio2_3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio2_3_func) -> &'b mut IOCON_iocon_pio2_3_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio2_3_mode) -> &'b mut IOCON_iocon_pio2_3_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio2_3_hys) -> &'b mut IOCON_iocon_pio2_3_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio2_3_od) -> &'b mut IOCON_iocon_pio2_3_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_3_func {
    /// Selects function PIO2_3.
    GPIO = 0,
    /// Selects function RI.
    RI = 1,
    /// Selects function MOSI1.
    MOSI1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_3_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_3_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio2_3_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_SWDIO_PIO1_3 implementation


/// Register `IOCON_SWDIO_PIO1_3`: I/O configuration for pin SWDIO/PIO1_3/AD4/CT32B1_MAT2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_swdio_pio1_3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_swdio_pio1_3 { }

impl IOCON_iocon_swdio_pio1_3 {
    
    // Getters
    /// Fetch the value of the `IOCON_SWDIO_PIO1_3` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_swdio_pio1_3_Get {
        IOCON_iocon_swdio_pio1_3_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_swdio_pio1_3_func {
        IOCON_iocon_swdio_pio1_3_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_swdio_pio1_3_mode {
        IOCON_iocon_swdio_pio1_3_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_swdio_pio1_3_hys {
        IOCON_iocon_swdio_pio1_3_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_swdio_pio1_3_admode {
        IOCON_iocon_swdio_pio1_3_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_swdio_pio1_3_od {
        IOCON_iocon_swdio_pio1_3_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_SWDIO_PIO1_3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_swdio_pio1_3_Update {
        IOCON_iocon_swdio_pio1_3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_swdio_pio1_3_func) -> IOCON_iocon_swdio_pio1_3_Update<'a> {
        let mut setter: IOCON_iocon_swdio_pio1_3_Update = IOCON_iocon_swdio_pio1_3_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_swdio_pio1_3_mode) -> IOCON_iocon_swdio_pio1_3_Update<'a> {
        let mut setter: IOCON_iocon_swdio_pio1_3_Update = IOCON_iocon_swdio_pio1_3_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_swdio_pio1_3_hys) -> IOCON_iocon_swdio_pio1_3_Update<'a> {
        let mut setter: IOCON_iocon_swdio_pio1_3_Update = IOCON_iocon_swdio_pio1_3_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_swdio_pio1_3_admode) -> IOCON_iocon_swdio_pio1_3_Update<'a> {
        let mut setter: IOCON_iocon_swdio_pio1_3_Update = IOCON_iocon_swdio_pio1_3_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_swdio_pio1_3_od) -> IOCON_iocon_swdio_pio1_3_Update<'a> {
        let mut setter: IOCON_iocon_swdio_pio1_3_Update = IOCON_iocon_swdio_pio1_3_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_swdio_pio1_3
/// `IOCON_SWDIO_PIO1_3`: I/O configuration for pin SWDIO/PIO1_3/AD4/CT32B1_MAT2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_swdio_pio1_3_Get {
    value: u32,
}

impl IOCON_iocon_swdio_pio1_3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_swdio_pio1_3) -> IOCON_iocon_swdio_pio1_3_Get {
        IOCON_iocon_swdio_pio1_3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_swdio_pio1_3_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_func::SWDIO),
            1 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_func::GPIO),
            2 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_func::AD4),
            3 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_swdio_pio1_3_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_swdio_pio1_3_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_swdio_pio1_3_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_swdio_pio1_3_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_swdio_pio1_3_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_swdio_pio1_3_Get { }


// Updater for IOCON_iocon_swdio_pio1_3
/// Updater for `IOCON_SWDIO_PIO1_3` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_swdio_pio1_3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_swdio_pio1_3,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_swdio_pio1_3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_swdio_pio1_3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_swdio_pio1_3) -> IOCON_iocon_swdio_pio1_3_Update<'a> {
        IOCON_iocon_swdio_pio1_3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_swdio_pio1_3) -> IOCON_iocon_swdio_pio1_3_Update<'a> {
        IOCON_iocon_swdio_pio1_3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_swdio_pio1_3_func) -> &'b mut IOCON_iocon_swdio_pio1_3_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_swdio_pio1_3_mode) -> &'b mut IOCON_iocon_swdio_pio1_3_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_swdio_pio1_3_hys) -> &'b mut IOCON_iocon_swdio_pio1_3_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_swdio_pio1_3_admode) -> &'b mut IOCON_iocon_swdio_pio1_3_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_swdio_pio1_3_od) -> &'b mut IOCON_iocon_swdio_pio1_3_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swdio_pio1_3_func {
    /// Selects function SWDIO.
    SWDIO = 0,
    /// Selects function PIO1_3.
    GPIO = 1,
    /// Selects function AD4.
    AD4 = 2,
    /// Selects function CT32B1_MAT2.
    CT32B0_MAT1 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swdio_pio1_3_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swdio_pio1_3_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swdio_pio1_3_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_swdio_pio1_3_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO1_4 implementation


/// Register `IOCON_PIO1_4`: I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_4 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_4 { }

impl IOCON_iocon_pio1_4 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_4` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_4_Get {
        IOCON_iocon_pio1_4_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_4_func {
        IOCON_iocon_pio1_4_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_4_mode {
        IOCON_iocon_pio1_4_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_4_hys {
        IOCON_iocon_pio1_4_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_pio1_4_admode {
        IOCON_iocon_pio1_4_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_4_od {
        IOCON_iocon_pio1_4_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_4` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_4_Update {
        IOCON_iocon_pio1_4_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_4_func) -> IOCON_iocon_pio1_4_Update<'a> {
        let mut setter: IOCON_iocon_pio1_4_Update = IOCON_iocon_pio1_4_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_4_mode) -> IOCON_iocon_pio1_4_Update<'a> {
        let mut setter: IOCON_iocon_pio1_4_Update = IOCON_iocon_pio1_4_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_4_hys) -> IOCON_iocon_pio1_4_Update<'a> {
        let mut setter: IOCON_iocon_pio1_4_Update = IOCON_iocon_pio1_4_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_4_admode) -> IOCON_iocon_pio1_4_Update<'a> {
        let mut setter: IOCON_iocon_pio1_4_Update = IOCON_iocon_pio1_4_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_4_od) -> IOCON_iocon_pio1_4_Update<'a> {
        let mut setter: IOCON_iocon_pio1_4_Update = IOCON_iocon_pio1_4_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_4
/// `IOCON_PIO1_4`: I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_4_Get {
    value: u32,
}

impl IOCON_iocon_pio1_4_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_4) -> IOCON_iocon_pio1_4_Get {
        IOCON_iocon_pio1_4_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. This pin functions as WAKEUP pin if the LPC111x/LPC11Cxx is in Deep power-down mode regardless of the value of FUNC. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_4_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_4_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_4_func::AD5),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_4_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_4_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_4_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_4_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_4_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_4_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_4_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_4_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_4_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_pio1_4_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_4_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_4_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_4_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_4_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_4_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_4_Get { }


// Updater for IOCON_iocon_pio1_4
/// Updater for `IOCON_PIO1_4` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_4_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_4,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_4_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_4_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_4) -> IOCON_iocon_pio1_4_Update<'a> {
        IOCON_iocon_pio1_4_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_4) -> IOCON_iocon_pio1_4_Update<'a> {
        IOCON_iocon_pio1_4_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_4_func) -> &'b mut IOCON_iocon_pio1_4_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_4_mode) -> &'b mut IOCON_iocon_pio1_4_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_4_hys) -> &'b mut IOCON_iocon_pio1_4_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_4_admode) -> &'b mut IOCON_iocon_pio1_4_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_4_od) -> &'b mut IOCON_iocon_pio1_4_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_4_func {
    /// Selects function PIO1_4.
    GPIO = 0,
    /// Selects function AD5.
    AD5 = 1,
    /// Selects function CT32B1_MAT3.
    CT32B0_MAT1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_4_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_4_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_4_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_4_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO1_11 implementation


/// Register `IOCON_PIO1_11`: I/O configuration for pin PIO1_11/AD7/CT32B1_CAP1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_11 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_11 { }

impl IOCON_iocon_pio1_11 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_11` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_11_Get {
        IOCON_iocon_pio1_11_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_11_func {
        IOCON_iocon_pio1_11_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_11_mode {
        IOCON_iocon_pio1_11_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_11_hys {
        IOCON_iocon_pio1_11_Get::new(self).hys()
    }
    
    /// Get value of `ADMODE` field.
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_pio1_11_admode {
        IOCON_iocon_pio1_11_Get::new(self).admode()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_11_od {
        IOCON_iocon_pio1_11_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_11` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_11_Update {
        IOCON_iocon_pio1_11_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_11_func) -> IOCON_iocon_pio1_11_Update<'a> {
        let mut setter: IOCON_iocon_pio1_11_Update = IOCON_iocon_pio1_11_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_11_mode) -> IOCON_iocon_pio1_11_Update<'a> {
        let mut setter: IOCON_iocon_pio1_11_Update = IOCON_iocon_pio1_11_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_11_hys) -> IOCON_iocon_pio1_11_Update<'a> {
        let mut setter: IOCON_iocon_pio1_11_Update = IOCON_iocon_pio1_11_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_11_admode) -> IOCON_iocon_pio1_11_Update<'a> {
        let mut setter: IOCON_iocon_pio1_11_Update = IOCON_iocon_pio1_11_Update::new(self);
        setter.set_admode(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_11_od) -> IOCON_iocon_pio1_11_Update<'a> {
        let mut setter: IOCON_iocon_pio1_11_Update = IOCON_iocon_pio1_11_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_11
/// `IOCON_PIO1_11`: I/O configuration for pin PIO1_11/AD7/CT32B1_CAP1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_11_Get {
    value: u32,
}

impl IOCON_iocon_pio1_11_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_11) -> IOCON_iocon_pio1_11_Get {
        IOCON_iocon_pio1_11_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_11_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_11_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_11_func::AD7),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_11_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_11_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_11_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_11_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_11_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_11_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_11_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_11_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_11_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADMODE` field: Selects Analog/Digital mode
    #[inline(always)]
    pub fn admode(&self) -> IOCON_iocon_pio1_11_admode {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_11_admode::AnalogInput),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_11_admode::DigitalIO),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_11_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_11_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_11_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_11_Get { }


// Updater for IOCON_iocon_pio1_11
/// Updater for `IOCON_PIO1_11` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_11_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_11,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_11_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_11_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_11) -> IOCON_iocon_pio1_11_Update<'a> {
        IOCON_iocon_pio1_11_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_11) -> IOCON_iocon_pio1_11_Update<'a> {
        IOCON_iocon_pio1_11_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_11_func) -> &'b mut IOCON_iocon_pio1_11_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_11_mode) -> &'b mut IOCON_iocon_pio1_11_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_11_hys) -> &'b mut IOCON_iocon_pio1_11_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ADMODE` field.
    #[inline(always)]
    pub fn set_admode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_11_admode) -> &'b mut IOCON_iocon_pio1_11_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_11_od) -> &'b mut IOCON_iocon_pio1_11_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_11_func {
    /// Selects function PIO1_11.
    GPIO = 0,
    /// Selects function AD7.
    AD7 = 1,
    /// Selects function CT32B1_CAP1.
    CT32B0_MAT1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_11_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_11_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_11_admode {
    /// Analog input mode
    AnalogInput = 0,
    /// Digital functional mode
    DigitalIO = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_11_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO3_2 implementation


/// Register `IOCON_PIO3_2`: I/O configuration for pin PIO3_2/DCD/ CT16B0_MAT2/SCK1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio3_2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio3_2 { }

impl IOCON_iocon_pio3_2 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO3_2` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio3_2_Get {
        IOCON_iocon_pio3_2_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_2_func {
        IOCON_iocon_pio3_2_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_2_mode {
        IOCON_iocon_pio3_2_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_2_hys {
        IOCON_iocon_pio3_2_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_2_od {
        IOCON_iocon_pio3_2_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO3_2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio3_2_Update {
        IOCON_iocon_pio3_2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio3_2_func) -> IOCON_iocon_pio3_2_Update<'a> {
        let mut setter: IOCON_iocon_pio3_2_Update = IOCON_iocon_pio3_2_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio3_2_mode) -> IOCON_iocon_pio3_2_Update<'a> {
        let mut setter: IOCON_iocon_pio3_2_Update = IOCON_iocon_pio3_2_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio3_2_hys) -> IOCON_iocon_pio3_2_Update<'a> {
        let mut setter: IOCON_iocon_pio3_2_Update = IOCON_iocon_pio3_2_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio3_2_od) -> IOCON_iocon_pio3_2_Update<'a> {
        let mut setter: IOCON_iocon_pio3_2_Update = IOCON_iocon_pio3_2_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio3_2
/// `IOCON_PIO3_2`: I/O configuration for pin PIO3_2/DCD/ CT16B0_MAT2/SCK1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_2_Get {
    value: u32,
}

impl IOCON_iocon_pio3_2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio3_2) -> IOCON_iocon_pio3_2_Get {
        IOCON_iocon_pio3_2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_2_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_2_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_2_func::DCD),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_2_func::CT16B1_CAP0),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_2_func::SCK1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_2_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_2_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_2_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_2_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_2_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_2_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_2_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_2_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_2_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_2_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_2_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio3_2_Get { }


// Updater for IOCON_iocon_pio3_2
/// Updater for `IOCON_PIO3_2` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio3_2,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio3_2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio3_2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio3_2) -> IOCON_iocon_pio3_2_Update<'a> {
        IOCON_iocon_pio3_2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio3_2) -> IOCON_iocon_pio3_2_Update<'a> {
        IOCON_iocon_pio3_2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio3_2_func) -> &'b mut IOCON_iocon_pio3_2_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio3_2_mode) -> &'b mut IOCON_iocon_pio3_2_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio3_2_hys) -> &'b mut IOCON_iocon_pio3_2_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio3_2_od) -> &'b mut IOCON_iocon_pio3_2_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_2_func {
    /// Selects function PIO3_2.
    GPIO = 0,
    /// Selects function DCD.
    DCD = 1,
    /// Selects function CT16B0_MAT2.
    CT16B1_CAP0 = 2,
    /// Selects function SCK1.
    SCK1 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_2_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_2_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_2_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO1_5 implementation


/// Register `IOCON_PIO1_5`: I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_5 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_5 { }

impl IOCON_iocon_pio1_5 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_5` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_5_Get {
        IOCON_iocon_pio1_5_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_5_func {
        IOCON_iocon_pio1_5_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_5_mode {
        IOCON_iocon_pio1_5_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_5_hys {
        IOCON_iocon_pio1_5_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_5_od {
        IOCON_iocon_pio1_5_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_5` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_5_Update {
        IOCON_iocon_pio1_5_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_5_func) -> IOCON_iocon_pio1_5_Update<'a> {
        let mut setter: IOCON_iocon_pio1_5_Update = IOCON_iocon_pio1_5_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_5_mode) -> IOCON_iocon_pio1_5_Update<'a> {
        let mut setter: IOCON_iocon_pio1_5_Update = IOCON_iocon_pio1_5_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_5_hys) -> IOCON_iocon_pio1_5_Update<'a> {
        let mut setter: IOCON_iocon_pio1_5_Update = IOCON_iocon_pio1_5_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_5_od) -> IOCON_iocon_pio1_5_Update<'a> {
        let mut setter: IOCON_iocon_pio1_5_Update = IOCON_iocon_pio1_5_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_5
/// `IOCON_PIO1_5`: I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_5_Get {
    value: u32,
}

impl IOCON_iocon_pio1_5_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_5) -> IOCON_iocon_pio1_5_Get {
        IOCON_iocon_pio1_5_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_5_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_5_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_5_func::RTS),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_5_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_5_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_5_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_5_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_5_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_5_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_5_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_5_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_5_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_5_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_5_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_5_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_5_Get { }


// Updater for IOCON_iocon_pio1_5
/// Updater for `IOCON_PIO1_5` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_5_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_5,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_5_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_5_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_5) -> IOCON_iocon_pio1_5_Update<'a> {
        IOCON_iocon_pio1_5_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_5) -> IOCON_iocon_pio1_5_Update<'a> {
        IOCON_iocon_pio1_5_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_5_func) -> &'b mut IOCON_iocon_pio1_5_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_5_mode) -> &'b mut IOCON_iocon_pio1_5_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_5_hys) -> &'b mut IOCON_iocon_pio1_5_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_5_od) -> &'b mut IOCON_iocon_pio1_5_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_5_func {
    /// Selects function PIO1_5.
    GPIO = 0,
    /// Selects function RTS.
    RTS = 1,
    /// Selects function CT32B0_CAP0.
    CT32B0_MAT1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_5_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_5_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_5_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO1_6 implementation


/// Register `IOCON_PIO1_6`: I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_6 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_6 { }

impl IOCON_iocon_pio1_6 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_6` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_6_Get {
        IOCON_iocon_pio1_6_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_6_func {
        IOCON_iocon_pio1_6_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_6_mode {
        IOCON_iocon_pio1_6_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_6_hys {
        IOCON_iocon_pio1_6_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_6_od {
        IOCON_iocon_pio1_6_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_6` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_6_Update {
        IOCON_iocon_pio1_6_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_6_func) -> IOCON_iocon_pio1_6_Update<'a> {
        let mut setter: IOCON_iocon_pio1_6_Update = IOCON_iocon_pio1_6_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_6_mode) -> IOCON_iocon_pio1_6_Update<'a> {
        let mut setter: IOCON_iocon_pio1_6_Update = IOCON_iocon_pio1_6_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_6_hys) -> IOCON_iocon_pio1_6_Update<'a> {
        let mut setter: IOCON_iocon_pio1_6_Update = IOCON_iocon_pio1_6_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_6_od) -> IOCON_iocon_pio1_6_Update<'a> {
        let mut setter: IOCON_iocon_pio1_6_Update = IOCON_iocon_pio1_6_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_6
/// `IOCON_PIO1_6`: I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_6_Get {
    value: u32,
}

impl IOCON_iocon_pio1_6_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_6) -> IOCON_iocon_pio1_6_Get {
        IOCON_iocon_pio1_6_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_6_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_6_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_6_func::RXD),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_6_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_6_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_6_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_6_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_6_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_6_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_6_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_6_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_6_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_6_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_6_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_6_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_6_Get { }


// Updater for IOCON_iocon_pio1_6
/// Updater for `IOCON_PIO1_6` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_6_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_6,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_6_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_6_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_6) -> IOCON_iocon_pio1_6_Update<'a> {
        IOCON_iocon_pio1_6_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_6) -> IOCON_iocon_pio1_6_Update<'a> {
        IOCON_iocon_pio1_6_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_6_func) -> &'b mut IOCON_iocon_pio1_6_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_6_mode) -> &'b mut IOCON_iocon_pio1_6_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_6_hys) -> &'b mut IOCON_iocon_pio1_6_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_6_od) -> &'b mut IOCON_iocon_pio1_6_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_6_func {
    /// Selects function PIO1_6.
    GPIO = 0,
    /// Selects function RXD.
    RXD = 1,
    /// Selects function CT32B0_MAT0.
    CT32B0_MAT1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_6_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_6_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_6_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO1_7 implementation


/// Register `IOCON_PIO1_7`: I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio1_7 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio1_7 { }

impl IOCON_iocon_pio1_7 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO1_7` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio1_7_Get {
        IOCON_iocon_pio1_7_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_7_func {
        IOCON_iocon_pio1_7_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_7_mode {
        IOCON_iocon_pio1_7_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_7_hys {
        IOCON_iocon_pio1_7_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_7_od {
        IOCON_iocon_pio1_7_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO1_7` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio1_7_Update {
        IOCON_iocon_pio1_7_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio1_7_func) -> IOCON_iocon_pio1_7_Update<'a> {
        let mut setter: IOCON_iocon_pio1_7_Update = IOCON_iocon_pio1_7_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio1_7_mode) -> IOCON_iocon_pio1_7_Update<'a> {
        let mut setter: IOCON_iocon_pio1_7_Update = IOCON_iocon_pio1_7_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio1_7_hys) -> IOCON_iocon_pio1_7_Update<'a> {
        let mut setter: IOCON_iocon_pio1_7_Update = IOCON_iocon_pio1_7_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio1_7_od) -> IOCON_iocon_pio1_7_Update<'a> {
        let mut setter: IOCON_iocon_pio1_7_Update = IOCON_iocon_pio1_7_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio1_7
/// `IOCON_PIO1_7`: I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_7_Get {
    value: u32,
}

impl IOCON_iocon_pio1_7_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio1_7) -> IOCON_iocon_pio1_7_Get {
        IOCON_iocon_pio1_7_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio1_7_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_7_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_7_func::TXD),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_7_func::CT32B0_MAT1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio1_7_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_7_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_7_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio1_7_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio1_7_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio1_7_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_7_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_7_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio1_7_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio1_7_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio1_7_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio1_7_Get { }


// Updater for IOCON_iocon_pio1_7
/// Updater for `IOCON_PIO1_7` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio1_7_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio1_7,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio1_7_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio1_7_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio1_7) -> IOCON_iocon_pio1_7_Update<'a> {
        IOCON_iocon_pio1_7_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio1_7) -> IOCON_iocon_pio1_7_Update<'a> {
        IOCON_iocon_pio1_7_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio1_7_func) -> &'b mut IOCON_iocon_pio1_7_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio1_7_mode) -> &'b mut IOCON_iocon_pio1_7_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio1_7_hys) -> &'b mut IOCON_iocon_pio1_7_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio1_7_od) -> &'b mut IOCON_iocon_pio1_7_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_7_func {
    /// Selects function PIO1_7.
    GPIO = 0,
    /// Selects function TXD.
    TXD = 1,
    /// Selects function CT32B0_MAT1.
    CT32B0_MAT1 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_7_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_7_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio1_7_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_PIO3_3 implementation


/// Register `IOCON_PIO3_3`: I/O configuration for pin PIO3_3/RI/ CT16B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_pio3_3 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_pio3_3 { }

impl IOCON_iocon_pio3_3 {
    
    // Getters
    /// Fetch the value of the `IOCON_PIO3_3` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_pio3_3_Get {
        IOCON_iocon_pio3_3_Get::new(self)
    }

    
    /// Get value of `FUNC` field.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_3_func {
        IOCON_iocon_pio3_3_Get::new(self).func()
    }
    
    /// Get value of `MODE` field.
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_3_mode {
        IOCON_iocon_pio3_3_Get::new(self).mode()
    }
    
    /// Get value of `HYS` field.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_3_hys {
        IOCON_iocon_pio3_3_Get::new(self).hys()
    }
    
    /// Get value of `OD` field.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_3_od {
        IOCON_iocon_pio3_3_Get::new(self).od()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_PIO3_3` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_pio3_3_Update {
        IOCON_iocon_pio3_3_Update::new_ignoring_state(self)
    }

    
    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'a>(&'a mut self, new_value: IOCON_iocon_pio3_3_func) -> IOCON_iocon_pio3_3_Update<'a> {
        let mut setter: IOCON_iocon_pio3_3_Update = IOCON_iocon_pio3_3_Update::new(self);
        setter.set_func(new_value);
        setter
    }
    
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'a>(&'a mut self, new_value: IOCON_iocon_pio3_3_mode) -> IOCON_iocon_pio3_3_Update<'a> {
        let mut setter: IOCON_iocon_pio3_3_Update = IOCON_iocon_pio3_3_Update::new(self);
        setter.set_mode(new_value);
        setter
    }
    
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'a>(&'a mut self, new_value: IOCON_iocon_pio3_3_hys) -> IOCON_iocon_pio3_3_Update<'a> {
        let mut setter: IOCON_iocon_pio3_3_Update = IOCON_iocon_pio3_3_Update::new(self);
        setter.set_hys(new_value);
        setter
    }
    
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'a>(&'a mut self, new_value: IOCON_iocon_pio3_3_od) -> IOCON_iocon_pio3_3_Update<'a> {
        let mut setter: IOCON_iocon_pio3_3_Update = IOCON_iocon_pio3_3_Update::new(self);
        setter.set_od(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_pio3_3
/// `IOCON_PIO3_3`: I/O configuration for pin PIO3_3/RI/ CT16B0_CAP0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_3_Get {
    value: u32,
}

impl IOCON_iocon_pio3_3_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_pio3_3) -> IOCON_iocon_pio3_3_Get {
        IOCON_iocon_pio3_3_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `FUNC` field: Selects pin function. All other values are reserved.
    #[inline(always)]
    pub fn func(&self) -> IOCON_iocon_pio3_3_func {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_3_func::GPIO),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_3_func::RI),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_3_func::CT16B1_CAP0),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MODE` field: Selects function mode (on-chip pull-up/pull-down resistor control).
    #[inline(always)]
    pub fn mode(&self) -> IOCON_iocon_pio3_3_mode {
        match (self.value >> 3) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_3_mode::Inactive),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_3_mode::PullDownEnabled),
            2 => ::core::option::Option::Some(IOCON_iocon_pio3_3_mode::PullUpEnabled),
            3 => ::core::option::Option::Some(IOCON_iocon_pio3_3_mode::RepeaterMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `HYS` field: Hysteresis.
    #[inline(always)]
    pub fn hys(&self) -> IOCON_iocon_pio3_3_hys {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_3_hys::Disabled),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_3_hys::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `OD` field: Selects pseudo open-drain mode.
    #[inline(always)]
    pub fn od(&self) -> IOCON_iocon_pio3_3_od {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(IOCON_iocon_pio3_3_od::Standard),
            1 => ::core::option::Option::Some(IOCON_iocon_pio3_3_od::OpenDrain),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_pio3_3_Get { }


// Updater for IOCON_iocon_pio3_3
/// Updater for `IOCON_PIO3_3` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_pio3_3_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_pio3_3,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_pio3_3_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_pio3_3_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_pio3_3) -> IOCON_iocon_pio3_3_Update<'a> {
        IOCON_iocon_pio3_3_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_pio3_3) -> IOCON_iocon_pio3_3_Update<'a> {
        IOCON_iocon_pio3_3_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `FUNC` field.
    #[inline(always)]
    pub fn set_func<'b>(&'b mut self, new_value: IOCON_iocon_pio3_3_func) -> &'b mut IOCON_iocon_pio3_3_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `MODE` field.
    #[inline(always)]
    pub fn set_mode<'b>(&'b mut self, new_value: IOCON_iocon_pio3_3_mode) -> &'b mut IOCON_iocon_pio3_3_Update<'a> {
        self.value = (self.value & !(3 << 3))
                   | ((new_value as u32) & 3) << 3;
        self.mask |= 3 << 3;
        self
    }
    /// Set value of `HYS` field.
    #[inline(always)]
    pub fn set_hys<'b>(&'b mut self, new_value: IOCON_iocon_pio3_3_hys) -> &'b mut IOCON_iocon_pio3_3_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `OD` field.
    #[inline(always)]
    pub fn set_od<'b>(&'b mut self, new_value: IOCON_iocon_pio3_3_od) -> &'b mut IOCON_iocon_pio3_3_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_3_func {
    /// Selects function PIO3_3.
    GPIO = 0,
    /// Selects function RI.
    RI = 1,
    /// Selects function CT16B0_CAP0.
    CT16B1_CAP0 = 2,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_3_mode {
    /// Inactive (no pull-down/pull-up resistor enabled).
    Inactive = 0,
    /// Pull-down resistor enabled.
    PullDownEnabled = 1,
    /// Pull-up resistor enabled.
    PullUpEnabled = 2,
    /// Repeater mode.
    RepeaterMode = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_3_hys {
    /// Disable.
    Disabled = 0,
    /// Enable.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_pio3_3_od {
    /// Standard GPIO output
    Standard = 0,
    /// Open-drain output
    OpenDrain = 1,
    }







// Register IOCON_SCK0_LOC implementation


/// Register `IOCON_SCK0_LOC`: SCK0 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_sck0_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_sck0_loc { }

impl IOCON_iocon_sck0_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_SCK0_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_sck0_loc_Get {
        IOCON_iocon_sck0_loc_Get::new(self)
    }

    
    /// Get value of `SCKLOC` field.
    #[inline(always)]
    pub fn sckloc(&self) -> IOCON_iocon_sck0_loc_sckloc {
        IOCON_iocon_sck0_loc_Get::new(self).sckloc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_SCK0_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_sck0_loc_Update {
        IOCON_iocon_sck0_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SCKLOC` field.
    #[inline(always)]
    pub fn set_sckloc<'a>(&'a mut self, new_value: IOCON_iocon_sck0_loc_sckloc) -> IOCON_iocon_sck0_loc_Update<'a> {
        let mut setter: IOCON_iocon_sck0_loc_Update = IOCON_iocon_sck0_loc_Update::new(self);
        setter.set_sckloc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_sck0_loc
/// `IOCON_SCK0_LOC`: SCK0 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_sck0_loc_Get {
    value: u32,
}

impl IOCON_iocon_sck0_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_sck0_loc) -> IOCON_iocon_sck0_loc_Get {
        IOCON_iocon_sck0_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SCKLOC` field: Selects pin location for SCK0 function.
    #[inline(always)]
    pub fn sckloc(&self) -> IOCON_iocon_sck0_loc_sckloc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_sck0_loc_sckloc::Port0Pin10),
            1 => ::core::option::Option::Some(IOCON_iocon_sck0_loc_sckloc::Port2Pin11),
            2 => ::core::option::Option::Some(IOCON_iocon_sck0_loc_sckloc::Port0Pin6),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_sck0_loc_Get { }


// Updater for IOCON_iocon_sck0_loc
/// Updater for `IOCON_SCK0_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_sck0_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_sck0_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_sck0_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_sck0_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_sck0_loc) -> IOCON_iocon_sck0_loc_Update<'a> {
        IOCON_iocon_sck0_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_sck0_loc) -> IOCON_iocon_sck0_loc_Update<'a> {
        IOCON_iocon_sck0_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SCKLOC` field.
    #[inline(always)]
    pub fn set_sckloc<'b>(&'b mut self, new_value: IOCON_iocon_sck0_loc_sckloc) -> &'b mut IOCON_iocon_sck0_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_sck0_loc_sckloc {
    /// Selects SCK0 function in pin location SWCLK/PIO0_10/SCK0/CT16B0_MAT2 (see Table 129).
    Port0Pin10 = 0,
    /// Selects SCK0 function in pin location PIO2_11/SCK0 (see Table 131).
    Port2Pin11 = 1,
    /// Selects SCK0 function in pin location PIO0_6/SCK0 (see Table 122).
    Port0Pin6 = 2,
    }







// Register IOCON_DSR_LOC implementation


/// Register `IOCON_DSR_LOC`: DSR pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_dsr_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_dsr_loc { }

impl IOCON_iocon_dsr_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_DSR_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_dsr_loc_Get {
        IOCON_iocon_dsr_loc_Get::new(self)
    }

    
    /// Get value of `DSRLOC` field.
    #[inline(always)]
    pub fn dsrloc(&self) -> IOCON_iocon_dsr_loc_dsrloc {
        IOCON_iocon_dsr_loc_Get::new(self).dsrloc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_DSR_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_dsr_loc_Update {
        IOCON_iocon_dsr_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DSRLOC` field.
    #[inline(always)]
    pub fn set_dsrloc<'a>(&'a mut self, new_value: IOCON_iocon_dsr_loc_dsrloc) -> IOCON_iocon_dsr_loc_Update<'a> {
        let mut setter: IOCON_iocon_dsr_loc_Update = IOCON_iocon_dsr_loc_Update::new(self);
        setter.set_dsrloc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_dsr_loc
/// `IOCON_DSR_LOC`: DSR pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_dsr_loc_Get {
    value: u32,
}

impl IOCON_iocon_dsr_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_dsr_loc) -> IOCON_iocon_dsr_loc_Get {
        IOCON_iocon_dsr_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DSRLOC` field: Selects pin location for DSR function.
    #[inline(always)]
    pub fn dsrloc(&self) -> IOCON_iocon_dsr_loc_dsrloc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_dsr_loc_dsrloc::Port2Pin1),
            1 => ::core::option::Option::Some(IOCON_iocon_dsr_loc_dsrloc::Port3Pin1),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_dsr_loc_Get { }


// Updater for IOCON_iocon_dsr_loc
/// Updater for `IOCON_DSR_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_dsr_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_dsr_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_dsr_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_dsr_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_dsr_loc) -> IOCON_iocon_dsr_loc_Update<'a> {
        IOCON_iocon_dsr_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_dsr_loc) -> IOCON_iocon_dsr_loc_Update<'a> {
        IOCON_iocon_dsr_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DSRLOC` field.
    #[inline(always)]
    pub fn set_dsrloc<'b>(&'b mut self, new_value: IOCON_iocon_dsr_loc_dsrloc) -> &'b mut IOCON_iocon_dsr_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_dsr_loc_dsrloc {
    /// Selects  DSR function in pin location PIO2_1/DSR/SCK1 (see Table 113).
    Port2Pin1 = 0,
    /// Selects DSR function in pin location PIO3_1/DSR (see Table 137).
    Port3Pin1 = 1,
    }







// Register IOCON_DCD_LOC implementation


/// Register `IOCON_DCD_LOC`: DCD pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_dcd_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_dcd_loc { }

impl IOCON_iocon_dcd_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_DCD_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_dcd_loc_Get {
        IOCON_iocon_dcd_loc_Get::new(self)
    }

    
    /// Get value of `DCDLOC` field.
    #[inline(always)]
    pub fn dcdloc(&self) -> IOCON_iocon_dcd_loc_dcdloc {
        IOCON_iocon_dcd_loc_Get::new(self).dcdloc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_DCD_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_dcd_loc_Update {
        IOCON_iocon_dcd_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DCDLOC` field.
    #[inline(always)]
    pub fn set_dcdloc<'a>(&'a mut self, new_value: IOCON_iocon_dcd_loc_dcdloc) -> IOCON_iocon_dcd_loc_Update<'a> {
        let mut setter: IOCON_iocon_dcd_loc_Update = IOCON_iocon_dcd_loc_Update::new(self);
        setter.set_dcdloc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_dcd_loc
/// `IOCON_DCD_LOC`: DCD pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_dcd_loc_Get {
    value: u32,
}

impl IOCON_iocon_dcd_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_dcd_loc) -> IOCON_iocon_dcd_loc_Get {
        IOCON_iocon_dcd_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DCDLOC` field: Selects pin location for DCD function.
    #[inline(always)]
    pub fn dcdloc(&self) -> IOCON_iocon_dcd_loc_dcdloc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_dcd_loc_dcdloc::Port2pin2),
            1 => ::core::option::Option::Some(IOCON_iocon_dcd_loc_dcdloc::Port3pin2),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_dcd_loc_Get { }


// Updater for IOCON_iocon_dcd_loc
/// Updater for `IOCON_DCD_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_dcd_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_dcd_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_dcd_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_dcd_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_dcd_loc) -> IOCON_iocon_dcd_loc_Update<'a> {
        IOCON_iocon_dcd_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_dcd_loc) -> IOCON_iocon_dcd_loc_Update<'a> {
        IOCON_iocon_dcd_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DCDLOC` field.
    #[inline(always)]
    pub fn set_dcdloc<'b>(&'b mut self, new_value: IOCON_iocon_dcd_loc_dcdloc) -> &'b mut IOCON_iocon_dcd_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_dcd_loc_dcdloc {
    /// Selects  DCD function in pin location PIO2_2/DCD/MISO1 (see  Table 126).
    Port2pin2 = 0,
    /// Selects DCD function in pin location PIO3_2/DCD (see  Table 142).
    Port3pin2 = 1,
    }







// Register IOCON_RI_LOC implementation


/// Register `IOCON_RI_LOC`: RI pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_ri_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_ri_loc { }

impl IOCON_iocon_ri_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_RI_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_ri_loc_Get {
        IOCON_iocon_ri_loc_Get::new(self)
    }

    
    /// Get value of `RILOC` field.
    #[inline(always)]
    pub fn riloc(&self) -> IOCON_iocon_ri_loc_riloc {
        IOCON_iocon_ri_loc_Get::new(self).riloc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_RI_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_ri_loc_Update {
        IOCON_iocon_ri_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `RILOC` field.
    #[inline(always)]
    pub fn set_riloc<'a>(&'a mut self, new_value: IOCON_iocon_ri_loc_riloc) -> IOCON_iocon_ri_loc_Update<'a> {
        let mut setter: IOCON_iocon_ri_loc_Update = IOCON_iocon_ri_loc_Update::new(self);
        setter.set_riloc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_ri_loc
/// `IOCON_RI_LOC`: RI pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ri_loc_Get {
    value: u32,
}

impl IOCON_iocon_ri_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_ri_loc) -> IOCON_iocon_ri_loc_Get {
        IOCON_iocon_ri_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RILOC` field: Selects pin location for RI function.
    #[inline(always)]
    pub fn riloc(&self) -> IOCON_iocon_ri_loc_riloc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_ri_loc_riloc::Port2pin3),
            1 => ::core::option::Option::Some(IOCON_iocon_ri_loc_riloc::Port3pin3),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_ri_loc_Get { }


// Updater for IOCON_iocon_ri_loc
/// Updater for `IOCON_RI_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ri_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_ri_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_ri_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_ri_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_ri_loc) -> IOCON_iocon_ri_loc_Update<'a> {
        IOCON_iocon_ri_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_ri_loc) -> IOCON_iocon_ri_loc_Update<'a> {
        IOCON_iocon_ri_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `RILOC` field.
    #[inline(always)]
    pub fn set_riloc<'b>(&'b mut self, new_value: IOCON_iocon_ri_loc_riloc) -> &'b mut IOCON_iocon_ri_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_ri_loc_riloc {
    /// Selects  RI function in pin location PIO2_3/RI/MOSI1 (see Table 138).
    Port2pin3 = 0,
    /// Selects RI function in pin location PIO3_3/RI (see Table 146).
    Port3pin3 = 1,
    }







// Register IOCON_SSEL1_LOC implementation


/// Register `IOCON_SSEL1_LOC`: SSEL1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_ssel1_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_ssel1_loc { }

impl IOCON_iocon_ssel1_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_SSEL1_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_ssel1_loc_Get {
        IOCON_iocon_ssel1_loc_Get::new(self)
    }

    
    /// Get value of `SSEL1LOC` field.
    #[inline(always)]
    pub fn ssel1loc(&self) -> IOCON_iocon_ssel1_loc_ssel1loc {
        IOCON_iocon_ssel1_loc_Get::new(self).ssel1loc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_SSEL1_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_ssel1_loc_Update {
        IOCON_iocon_ssel1_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SSEL1LOC` field.
    #[inline(always)]
    pub fn set_ssel1loc<'a>(&'a mut self, new_value: IOCON_iocon_ssel1_loc_ssel1loc) -> IOCON_iocon_ssel1_loc_Update<'a> {
        let mut setter: IOCON_iocon_ssel1_loc_Update = IOCON_iocon_ssel1_loc_Update::new(self);
        setter.set_ssel1loc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_ssel1_loc
/// `IOCON_SSEL1_LOC`: SSEL1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ssel1_loc_Get {
    value: u32,
}

impl IOCON_iocon_ssel1_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_ssel1_loc) -> IOCON_iocon_ssel1_loc_Get {
        IOCON_iocon_ssel1_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SSEL1LOC` field: Selects pin location for SSEL1 function.
    #[inline(always)]
    pub fn ssel1loc(&self) -> IOCON_iocon_ssel1_loc_ssel1loc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_ssel1_loc_ssel1loc::Port2Pin2),
            1 => ::core::option::Option::Some(IOCON_iocon_ssel1_loc_ssel1loc::Port2Pin4),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_ssel1_loc_Get { }


// Updater for IOCON_iocon_ssel1_loc
/// Updater for `IOCON_SSEL1_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ssel1_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_ssel1_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_ssel1_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_ssel1_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_ssel1_loc) -> IOCON_iocon_ssel1_loc_Update<'a> {
        IOCON_iocon_ssel1_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_ssel1_loc) -> IOCON_iocon_ssel1_loc_Update<'a> {
        IOCON_iocon_ssel1_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SSEL1LOC` field.
    #[inline(always)]
    pub fn set_ssel1loc<'b>(&'b mut self, new_value: IOCON_iocon_ssel1_loc_ssel1loc) -> &'b mut IOCON_iocon_ssel1_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_ssel1_loc_ssel1loc {
    /// Selects SSEL1 function in pin location PIO2_2/DCD/MISO1 (see Table 126).
    Port2Pin2 = 0,
    /// Selects SSEL1 function in pin location  PIO2_4/CT16B1_MAT1/SSEL1 (see Table 119).
    Port2Pin4 = 1,
    }







// Register IOCON_CT16B0_CAP0_LOC implementation


/// Register `IOCON_CT16B0_CAP0_LOC`: CT16B0_CAP0 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_ct16b0_cap0_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_ct16b0_cap0_loc { }

impl IOCON_iocon_ct16b0_cap0_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_CT16B0_CAP0_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_ct16b0_cap0_loc_Get {
        IOCON_iocon_ct16b0_cap0_loc_Get::new(self)
    }

    
    /// Get value of `CT16B0_CAP0LOC` field.
    #[inline(always)]
    pub fn ct16b0_cap0loc(&self) -> IOCON_iocon_ct16b0_cap0_loc_ct16b0_cap0loc {
        IOCON_iocon_ct16b0_cap0_loc_Get::new(self).ct16b0_cap0loc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_CT16B0_CAP0_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_ct16b0_cap0_loc_Update {
        IOCON_iocon_ct16b0_cap0_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CT16B0_CAP0LOC` field.
    #[inline(always)]
    pub fn set_ct16b0_cap0loc<'a>(&'a mut self, new_value: IOCON_iocon_ct16b0_cap0_loc_ct16b0_cap0loc) -> IOCON_iocon_ct16b0_cap0_loc_Update<'a> {
        let mut setter: IOCON_iocon_ct16b0_cap0_loc_Update = IOCON_iocon_ct16b0_cap0_loc_Update::new(self);
        setter.set_ct16b0_cap0loc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_ct16b0_cap0_loc
/// `IOCON_CT16B0_CAP0_LOC`: CT16B0_CAP0 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ct16b0_cap0_loc_Get {
    value: u32,
}

impl IOCON_iocon_ct16b0_cap0_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_ct16b0_cap0_loc) -> IOCON_iocon_ct16b0_cap0_loc_Get {
        IOCON_iocon_ct16b0_cap0_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CT16B0_CAP0LOC` field: Selects pin location for CT16B0_CAP0 function.
    #[inline(always)]
    pub fn ct16b0_cap0loc(&self) -> IOCON_iocon_ct16b0_cap0_loc_ct16b0_cap0loc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_ct16b0_cap0_loc_ct16b0_cap0loc::Port0Pin2),
            1 => ::core::option::Option::Some(IOCON_iocon_ct16b0_cap0_loc_ct16b0_cap0loc::Port3Pin3),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_ct16b0_cap0_loc_Get { }


// Updater for IOCON_iocon_ct16b0_cap0_loc
/// Updater for `IOCON_CT16B0_CAP0_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ct16b0_cap0_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_ct16b0_cap0_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_ct16b0_cap0_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_ct16b0_cap0_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_ct16b0_cap0_loc) -> IOCON_iocon_ct16b0_cap0_loc_Update<'a> {
        IOCON_iocon_ct16b0_cap0_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_ct16b0_cap0_loc) -> IOCON_iocon_ct16b0_cap0_loc_Update<'a> {
        IOCON_iocon_ct16b0_cap0_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CT16B0_CAP0LOC` field.
    #[inline(always)]
    pub fn set_ct16b0_cap0loc<'b>(&'b mut self, new_value: IOCON_iocon_ct16b0_cap0_loc_ct16b0_cap0loc) -> &'b mut IOCON_iocon_ct16b0_cap0_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_ct16b0_cap0_loc_ct16b0_cap0loc {
    /// Selects CT16B0_CAP0 function in pin location PIO0_2/SSEL0/CT16B0_CAP0 (see  Table 110).
    Port0Pin2 = 0,
    /// Selects CT16B0_CAP0 function in pin location PIO3_3/RI/CT16B0 (see Table 146).
    Port3Pin3 = 1,
    }







// Register IOCON_SCK1_LOC implementation


/// Register `IOCON_SCK1_LOC`: SCK1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_sck1_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_sck1_loc { }

impl IOCON_iocon_sck1_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_SCK1_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_sck1_loc_Get {
        IOCON_iocon_sck1_loc_Get::new(self)
    }

    
    /// Get value of `SCK1LOC` field.
    #[inline(always)]
    pub fn sck1loc(&self) -> IOCON_iocon_sck1_loc_sck1loc {
        IOCON_iocon_sck1_loc_Get::new(self).sck1loc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_SCK1_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_sck1_loc_Update {
        IOCON_iocon_sck1_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SCK1LOC` field.
    #[inline(always)]
    pub fn set_sck1loc<'a>(&'a mut self, new_value: IOCON_iocon_sck1_loc_sck1loc) -> IOCON_iocon_sck1_loc_Update<'a> {
        let mut setter: IOCON_iocon_sck1_loc_Update = IOCON_iocon_sck1_loc_Update::new(self);
        setter.set_sck1loc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_sck1_loc
/// `IOCON_SCK1_LOC`: SCK1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_sck1_loc_Get {
    value: u32,
}

impl IOCON_iocon_sck1_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_sck1_loc) -> IOCON_iocon_sck1_loc_Get {
        IOCON_iocon_sck1_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SCK1LOC` field: Selects pin location for SCK1 function.
    #[inline(always)]
    pub fn sck1loc(&self) -> IOCON_iocon_sck1_loc_sck1loc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_sck1_loc_sck1loc::Port2Pin1),
            1 => ::core::option::Option::Some(IOCON_iocon_sck1_loc_sck1loc::Port3Pin2),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_sck1_loc_Get { }


// Updater for IOCON_iocon_sck1_loc
/// Updater for `IOCON_SCK1_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_sck1_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_sck1_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_sck1_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_sck1_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_sck1_loc) -> IOCON_iocon_sck1_loc_Update<'a> {
        IOCON_iocon_sck1_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_sck1_loc) -> IOCON_iocon_sck1_loc_Update<'a> {
        IOCON_iocon_sck1_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SCK1LOC` field.
    #[inline(always)]
    pub fn set_sck1loc<'b>(&'b mut self, new_value: IOCON_iocon_sck1_loc_sck1loc) -> &'b mut IOCON_iocon_sck1_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_sck1_loc_sck1loc {
    /// Selects SCK1 function in pin location PIO2_1/DSR/SCK1 (see Table 113).
    Port2Pin1 = 0,
    /// Selects SCK1 function in pin location PIO3_2/DCD/CT16B0_MAT2/SCK1 (see Table 142).
    Port3Pin2 = 1,
    }







// Register IOCON_MISO1_LOC implementation


/// Register `IOCON_MISO1_LOC`: MISO1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_miso1_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_miso1_loc { }

impl IOCON_iocon_miso1_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_MISO1_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_miso1_loc_Get {
        IOCON_iocon_miso1_loc_Get::new(self)
    }

    
    /// Get value of `MISO1LOC` field.
    #[inline(always)]
    pub fn miso1loc(&self) -> IOCON_iocon_miso1_loc_miso1loc {
        IOCON_iocon_miso1_loc_Get::new(self).miso1loc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_MISO1_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_miso1_loc_Update {
        IOCON_iocon_miso1_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MISO1LOC` field.
    #[inline(always)]
    pub fn set_miso1loc<'a>(&'a mut self, new_value: IOCON_iocon_miso1_loc_miso1loc) -> IOCON_iocon_miso1_loc_Update<'a> {
        let mut setter: IOCON_iocon_miso1_loc_Update = IOCON_iocon_miso1_loc_Update::new(self);
        setter.set_miso1loc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_miso1_loc
/// `IOCON_MISO1_LOC`: MISO1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_miso1_loc_Get {
    value: u32,
}

impl IOCON_iocon_miso1_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_miso1_loc) -> IOCON_iocon_miso1_loc_Get {
        IOCON_iocon_miso1_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MISO1LOC` field: Selects pin location for the MISO1 function.
    #[inline(always)]
    pub fn miso1loc(&self) -> IOCON_iocon_miso1_loc_miso1loc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_miso1_loc_miso1loc::Port2Pin2),
            1 => ::core::option::Option::Some(IOCON_iocon_miso1_loc_miso1loc::Port1Pin10),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_miso1_loc_Get { }


// Updater for IOCON_iocon_miso1_loc
/// Updater for `IOCON_MISO1_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_miso1_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_miso1_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_miso1_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_miso1_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_miso1_loc) -> IOCON_iocon_miso1_loc_Update<'a> {
        IOCON_iocon_miso1_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_miso1_loc) -> IOCON_iocon_miso1_loc_Update<'a> {
        IOCON_iocon_miso1_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MISO1LOC` field.
    #[inline(always)]
    pub fn set_miso1loc<'b>(&'b mut self, new_value: IOCON_iocon_miso1_loc_miso1loc) -> &'b mut IOCON_iocon_miso1_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_miso1_loc_miso1loc {
    /// Selects MISO1 function in pin location PIO2_2/DCD/MISO1 (see Table 126).
    Port2Pin2 = 0,
    /// Selects MISO1 function in pin location PIO1_10/AD6/CT16B1_MAT1/MISO1 (see  Table 130).
    Port1Pin10 = 1,
    }







// Register IOCON_MOSI1_LOC implementation


/// Register `IOCON_MOSI1_LOC`: MOSI1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_mosi1_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_mosi1_loc { }

impl IOCON_iocon_mosi1_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_MOSI1_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_mosi1_loc_Get {
        IOCON_iocon_mosi1_loc_Get::new(self)
    }

    
    /// Get value of `MOSI1LOC` field.
    #[inline(always)]
    pub fn mosi1loc(&self) -> IOCON_iocon_mosi1_loc_mosi1loc {
        IOCON_iocon_mosi1_loc_Get::new(self).mosi1loc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_MOSI1_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_mosi1_loc_Update {
        IOCON_iocon_mosi1_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MOSI1LOC` field.
    #[inline(always)]
    pub fn set_mosi1loc<'a>(&'a mut self, new_value: IOCON_iocon_mosi1_loc_mosi1loc) -> IOCON_iocon_mosi1_loc_Update<'a> {
        let mut setter: IOCON_iocon_mosi1_loc_Update = IOCON_iocon_mosi1_loc_Update::new(self);
        setter.set_mosi1loc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_mosi1_loc
/// `IOCON_MOSI1_LOC`: MOSI1 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_mosi1_loc_Get {
    value: u32,
}

impl IOCON_iocon_mosi1_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_mosi1_loc) -> IOCON_iocon_mosi1_loc_Get {
        IOCON_iocon_mosi1_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MOSI1LOC` field: Selects pin location for the MOSI1 function.
    #[inline(always)]
    pub fn mosi1loc(&self) -> IOCON_iocon_mosi1_loc_mosi1loc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_mosi1_loc_mosi1loc::Port2Pin3),
            1 => ::core::option::Option::Some(IOCON_iocon_mosi1_loc_mosi1loc::Port1Pin9),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_mosi1_loc_Get { }


// Updater for IOCON_iocon_mosi1_loc
/// Updater for `IOCON_MOSI1_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_mosi1_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_mosi1_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_mosi1_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_mosi1_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_mosi1_loc) -> IOCON_iocon_mosi1_loc_Update<'a> {
        IOCON_iocon_mosi1_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_mosi1_loc) -> IOCON_iocon_mosi1_loc_Update<'a> {
        IOCON_iocon_mosi1_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MOSI1LOC` field.
    #[inline(always)]
    pub fn set_mosi1loc<'b>(&'b mut self, new_value: IOCON_iocon_mosi1_loc_mosi1loc) -> &'b mut IOCON_iocon_mosi1_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_mosi1_loc_mosi1loc {
    /// Selects MOSI1 function in pin location PIO2_3/RI/MOSI1 (see Table 138).
    Port2Pin3 = 0,
    /// Selects MOSI1 function in pin location PIO1_9/CT16B1_MAT0/MOSI1 (see Table 117).
    Port1Pin9 = 1,
    }







// Register IOCON_CT32B0_CAP0_LOC implementation


/// Register `IOCON_CT32B0_CAP0_LOC`: CT32B0_CAP0 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_ct32b0_cap0_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_ct32b0_cap0_loc { }

impl IOCON_iocon_ct32b0_cap0_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_CT32B0_CAP0_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_ct32b0_cap0_loc_Get {
        IOCON_iocon_ct32b0_cap0_loc_Get::new(self)
    }

    
    /// Get value of `CT32B0_CAP0LOC` field.
    #[inline(always)]
    pub fn ct32b0_cap0loc(&self) -> IOCON_iocon_ct32b0_cap0_loc_ct32b0_cap0loc {
        IOCON_iocon_ct32b0_cap0_loc_Get::new(self).ct32b0_cap0loc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_CT32B0_CAP0_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_ct32b0_cap0_loc_Update {
        IOCON_iocon_ct32b0_cap0_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CT32B0_CAP0LOC` field.
    #[inline(always)]
    pub fn set_ct32b0_cap0loc<'a>(&'a mut self, new_value: IOCON_iocon_ct32b0_cap0_loc_ct32b0_cap0loc) -> IOCON_iocon_ct32b0_cap0_loc_Update<'a> {
        let mut setter: IOCON_iocon_ct32b0_cap0_loc_Update = IOCON_iocon_ct32b0_cap0_loc_Update::new(self);
        setter.set_ct32b0_cap0loc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_ct32b0_cap0_loc
/// `IOCON_CT32B0_CAP0_LOC`: CT32B0_CAP0 pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ct32b0_cap0_loc_Get {
    value: u32,
}

impl IOCON_iocon_ct32b0_cap0_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_ct32b0_cap0_loc) -> IOCON_iocon_ct32b0_cap0_loc_Get {
        IOCON_iocon_ct32b0_cap0_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CT32B0_CAP0LOC` field: Selects pin location for the CT32B0_CAP0 function.
    #[inline(always)]
    pub fn ct32b0_cap0loc(&self) -> IOCON_iocon_ct32b0_cap0_loc_ct32b0_cap0loc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_ct32b0_cap0_loc_ct32b0_cap0loc::Port1Pin5),
            1 => ::core::option::Option::Some(IOCON_iocon_ct32b0_cap0_loc_ct32b0_cap0loc::Port2Pin9),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_ct32b0_cap0_loc_Get { }


// Updater for IOCON_iocon_ct32b0_cap0_loc
/// Updater for `IOCON_CT32B0_CAP0_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_ct32b0_cap0_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_ct32b0_cap0_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_ct32b0_cap0_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_ct32b0_cap0_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_ct32b0_cap0_loc) -> IOCON_iocon_ct32b0_cap0_loc_Update<'a> {
        IOCON_iocon_ct32b0_cap0_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_ct32b0_cap0_loc) -> IOCON_iocon_ct32b0_cap0_loc_Update<'a> {
        IOCON_iocon_ct32b0_cap0_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CT32B0_CAP0LOC` field.
    #[inline(always)]
    pub fn set_ct32b0_cap0loc<'b>(&'b mut self, new_value: IOCON_iocon_ct32b0_cap0_loc_ct32b0_cap0loc) -> &'b mut IOCON_iocon_ct32b0_cap0_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_ct32b0_cap0_loc_ct32b0_cap0loc {
    /// Selects CT32B0_CAP0 function in pin location PIO1_5/RTS/CT32B0_CAP0 (see Table 143).
    Port1Pin5 = 0,
    /// Selects CT32B0_CAP0 function in pin location PIO2_9/CT32B0_CAP0 (Table 124).
    Port2Pin9 = 1,
    }







// Register IOCON_RXD_LOC implementation


/// Register `IOCON_RXD_LOC`: RXD pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct IOCON_iocon_rxd_loc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for IOCON_iocon_rxd_loc { }

impl IOCON_iocon_rxd_loc {
    
    // Getters
    /// Fetch the value of the `IOCON_RXD_LOC` register.
    #[inline(always)]
    pub fn get(&self) -> IOCON_iocon_rxd_loc_Get {
        IOCON_iocon_rxd_loc_Get::new(self)
    }

    
    /// Get value of `RXDLOC` field.
    #[inline(always)]
    pub fn rxdloc(&self) -> IOCON_iocon_rxd_loc_rxdloc {
        IOCON_iocon_rxd_loc_Get::new(self).rxdloc()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IOCON_RXD_LOC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> IOCON_iocon_rxd_loc_Update {
        IOCON_iocon_rxd_loc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `RXDLOC` field.
    #[inline(always)]
    pub fn set_rxdloc<'a>(&'a mut self, new_value: IOCON_iocon_rxd_loc_rxdloc) -> IOCON_iocon_rxd_loc_Update<'a> {
        let mut setter: IOCON_iocon_rxd_loc_Update = IOCON_iocon_rxd_loc_Update::new(self);
        setter.set_rxdloc(new_value);
        setter
    }
    

    }


// Getter for IOCON_iocon_rxd_loc
/// `IOCON_RXD_LOC`: RXD pin location select register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_rxd_loc_Get {
    value: u32,
}

impl IOCON_iocon_rxd_loc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &IOCON_iocon_rxd_loc) -> IOCON_iocon_rxd_loc_Get {
        IOCON_iocon_rxd_loc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RXDLOC` field: Selects pin location for the RXD function.
    #[inline(always)]
    pub fn rxdloc(&self) -> IOCON_iocon_rxd_loc_rxdloc {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(IOCON_iocon_rxd_loc_rxdloc::Port1Pin6),
            1 => ::core::option::Option::Some(IOCON_iocon_rxd_loc_rxdloc::Port2Pin7),
            2 => ::core::option::Option::Some(IOCON_iocon_rxd_loc_rxdloc::Port3Pin1),
            3 => ::core::option::Option::Some(IOCON_iocon_rxd_loc_rxdloc::Port3Pin4),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for IOCON_iocon_rxd_loc_Get { }


// Updater for IOCON_iocon_rxd_loc
/// Updater for `IOCON_RXD_LOC` register.
#[allow(non_camel_case_types)]
pub struct IOCON_iocon_rxd_loc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a IOCON_iocon_rxd_loc,
}

/// This performs the register update.
impl <'a> Drop for IOCON_iocon_rxd_loc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> IOCON_iocon_rxd_loc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a IOCON_iocon_rxd_loc) -> IOCON_iocon_rxd_loc_Update<'a> {
        IOCON_iocon_rxd_loc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a IOCON_iocon_rxd_loc) -> IOCON_iocon_rxd_loc_Update<'a> {
        IOCON_iocon_rxd_loc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `RXDLOC` field.
    #[inline(always)]
    pub fn set_rxdloc<'b>(&'b mut self, new_value: IOCON_iocon_rxd_loc_rxdloc) -> &'b mut IOCON_iocon_rxd_loc_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum IOCON_iocon_rxd_loc_rxdloc {
    /// Selects RXD function in pin location PIO1_6/RXD/CT32B0_MAT0 (see Table 144).
    Port1Pin6 = 0,
    /// Selects RXD function in pin location PIO2_7/CT32B0_MAT2/RXD (see Table 111).
    Port2Pin7 = 1,
    /// Selects RXD function in pin location PIO3_1/DSR/CT16B0_MAT1/RXD (see Table 137).
    Port3Pin1 = 2,
    /// Selects RXD function in pin location PIO3_4/CT16B0_CAP1/RXD (see Table 118).
    Port3Pin4 = 3,
    }





// Peripheral IOCON implementation

/// Product name title=UM10398 Chapter title=LPC1100XL series: I/O configuration (IOCONFIG) Modification date=2/22/2012 Major revision=8 Minor revision=not available 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct IOCON;

impl IOCON {
    /// I/O configuration for pin PIO2_6/ CT32B0_MAT1
    #[inline(always)]
    pub fn iocon_pio2_6() -> &'static mut IOCON_iocon_pio2_6 {
        unsafe { ::core::intrinsics::transmute(0x40044000 as usize) }
    }
    /// I/O configuration for pin PIO2_0/DTR/SSEL1
    #[inline(always)]
    pub fn iocon_pio2_0() -> &'static mut IOCON_iocon_pio2_0 {
        unsafe { ::core::intrinsics::transmute(0x40044008 as usize) }
    }
    /// I/O configuration for pin RESET/PIO0_0
    #[inline(always)]
    pub fn iocon_reset_pio0_0() -> &'static mut IOCON_iocon_reset_pio0_0 {
        unsafe { ::core::intrinsics::transmute(0x4004400c as usize) }
    }
    /// I/O configuration for pin PIO0_1/CLKOUT/CT32B0_MAT2
    #[inline(always)]
    pub fn iocon_pio0_1() -> &'static mut IOCON_iocon_pio0_1 {
        unsafe { ::core::intrinsics::transmute(0x40044010 as usize) }
    }
    /// I/O configuration for pin PIO1_8/CT16B1_CAP0
    #[inline(always)]
    pub fn iocon_pio1_8() -> &'static mut IOCON_iocon_pio1_8 {
        unsafe { ::core::intrinsics::transmute(0x40044014 as usize) }
    }
    /// I/O configuration for pin PIO0_2/SSEL0/CT16B0_CAP0
    #[inline(always)]
    pub fn iocon_pio0_2() -> &'static mut IOCON_iocon_pio0_2 {
        unsafe { ::core::intrinsics::transmute(0x4004401c as usize) }
    }
    /// I/O configuration for pin PIO2_7/ CT32B0_MAT2/RXD
    #[inline(always)]
    pub fn iocon_pio2_7() -> &'static mut IOCON_iocon_pio2_7 {
        unsafe { ::core::intrinsics::transmute(0x40044020 as usize) }
    }
    /// I/O configuration for pin PIO2_8/ CT32B0_MAT3/TXD
    #[inline(always)]
    pub fn iocon_pio2_8() -> &'static mut IOCON_iocon_pio2_8 {
        unsafe { ::core::intrinsics::transmute(0x40044024 as usize) }
    }
    /// I/O configuration for pin PIO2_1/DSR/SCK1
    #[inline(always)]
    pub fn iocon_pio2_1() -> &'static mut IOCON_iocon_pio2_1 {
        unsafe { ::core::intrinsics::transmute(0x40044028 as usize) }
    }
    /// I/O configuration for pin PIO0_3
    #[inline(always)]
    pub fn iocon_pio0_3() -> &'static mut IOCON_iocon_pio0_3 {
        unsafe { ::core::intrinsics::transmute(0x4004402c as usize) }
    }
    /// I/O configuration for pin PIO0_4/SCL
    #[inline(always)]
    pub fn iocon_pio0_4() -> &'static mut IOCON_iocon_pio0_4 {
        unsafe { ::core::intrinsics::transmute(0x40044030 as usize) }
    }
    /// I/O configuration for pin PIO0_5/SDA
    #[inline(always)]
    pub fn iocon_pio0_5() -> &'static mut IOCON_iocon_pio0_5 {
        unsafe { ::core::intrinsics::transmute(0x40044034 as usize) }
    }
    /// I/O configuration for pin PIO1_9/CT16B1_MAT0/ MOSI1
    #[inline(always)]
    pub fn iocon_pio1_9() -> &'static mut IOCON_iocon_pio1_9 {
        unsafe { ::core::intrinsics::transmute(0x40044038 as usize) }
    }
    /// I/O configuration for pin PIO3_4/ CT16B0_CAP1/RXD
    #[inline(always)]
    pub fn iocon_pio3_4() -> &'static mut IOCON_iocon_pio3_4 {
        unsafe { ::core::intrinsics::transmute(0x4004403c as usize) }
    }
    /// I/O configuration for pin PIO2_4/ CT16B1_MAT1/ SSEL1
    #[inline(always)]
    pub fn iocon_pio2_4() -> &'static mut IOCON_iocon_pio2_4 {
        unsafe { ::core::intrinsics::transmute(0x40044040 as usize) }
    }
    /// I/O configuration for pin PIO2_5/ CT32B0_MAT0
    #[inline(always)]
    pub fn iocon_pio2_5() -> &'static mut IOCON_iocon_pio2_5 {
        unsafe { ::core::intrinsics::transmute(0x40044044 as usize) }
    }
    /// I/O configuration for pin PIO3_5/ CT16B1_CAP1/TXD
    #[inline(always)]
    pub fn iocon_pio3_5() -> &'static mut IOCON_iocon_pio3_5 {
        unsafe { ::core::intrinsics::transmute(0x40044048 as usize) }
    }
    /// I/O configuration for pin PIO0_6/SCK0
    #[inline(always)]
    pub fn iocon_pio0_6() -> &'static mut IOCON_iocon_pio0_6 {
        unsafe { ::core::intrinsics::transmute(0x4004404c as usize) }
    }
    /// I/O configuration for pin PIO0_7/CTS
    #[inline(always)]
    pub fn iocon_pio0_7() -> &'static mut IOCON_iocon_pio0_7 {
        unsafe { ::core::intrinsics::transmute(0x40044050 as usize) }
    }
    /// I/O configuration for pin PIO2_9/ CT32B0_CAP0
    #[inline(always)]
    pub fn iocon_pio2_9() -> &'static mut IOCON_iocon_pio2_9 {
        unsafe { ::core::intrinsics::transmute(0x40044054 as usize) }
    }
    /// I/O configuration for pin PIO2_10
    #[inline(always)]
    pub fn iocon_pio2_10() -> &'static mut IOCON_iocon_pio2_10 {
        unsafe { ::core::intrinsics::transmute(0x40044058 as usize) }
    }
    /// I/O configuration for pin PIO2_2/DCD/MISO1
    #[inline(always)]
    pub fn iocon_pio2_2() -> &'static mut IOCON_iocon_pio2_2 {
        unsafe { ::core::intrinsics::transmute(0x4004405c as usize) }
    }
    /// I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0
    #[inline(always)]
    pub fn iocon_pio0_8() -> &'static mut IOCON_iocon_pio0_8 {
        unsafe { ::core::intrinsics::transmute(0x40044060 as usize) }
    }
    /// I/O configuration for pin PIO0_9/MOSI0/CT16B0_MAT1
    #[inline(always)]
    pub fn iocon_pio0_9() -> &'static mut IOCON_iocon_pio0_9 {
        unsafe { ::core::intrinsics::transmute(0x40044064 as usize) }
    }
    /// I/O configuration for pin SWCLK/PIO0_10/ SCK0/CT16B0_MAT2
    #[inline(always)]
    pub fn iocon_swclk_pio0_10() -> &'static mut IOCON_iocon_swclk_pio0_10 {
        unsafe { ::core::intrinsics::transmute(0x40044068 as usize) }
    }
    /// I/O configuration for pin PIO1_10/AD6/CT16B1_MAT1/ MISO1
    #[inline(always)]
    pub fn iocon_pio1_10() -> &'static mut IOCON_iocon_pio1_10 {
        unsafe { ::core::intrinsics::transmute(0x4004406c as usize) }
    }
    /// I/O configuration for pin PIO2_11/SCK0/ CT32B0_CAP1
    #[inline(always)]
    pub fn iocon_pio2_11() -> &'static mut IOCON_iocon_pio2_11 {
        unsafe { ::core::intrinsics::transmute(0x40044070 as usize) }
    }
    /// I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3
    #[inline(always)]
    pub fn iocon_r_pio0_11() -> &'static mut IOCON_iocon_r_pio0_11 {
        unsafe { ::core::intrinsics::transmute(0x40044074 as usize) }
    }
    /// I/O configuration for pin R/PIO1_0/AD1/CT32B1_CAP0
    #[inline(always)]
    pub fn iocon_r_pio1_0() -> &'static mut IOCON_iocon_r_pio1_0 {
        unsafe { ::core::intrinsics::transmute(0x40044078 as usize) }
    }
    /// I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0
    #[inline(always)]
    pub fn iocon_r_pio1_1() -> &'static mut IOCON_iocon_r_pio1_1 {
        unsafe { ::core::intrinsics::transmute(0x4004407c as usize) }
    }
    /// I/O configuration for pin R/PIO1_2/AD3/CT32B1_MAT1
    #[inline(always)]
    pub fn iocon_r_pio1_2() -> &'static mut IOCON_iocon_r_pio1_2 {
        unsafe { ::core::intrinsics::transmute(0x40044080 as usize) }
    }
    /// I/O configuration for pin PIO3_0/DTR/CT16B0_MAT0/TXD
    #[inline(always)]
    pub fn iocon_pio3_0() -> &'static mut IOCON_iocon_pio3_0 {
        unsafe { ::core::intrinsics::transmute(0x40044084 as usize) }
    }
    /// I/O configuration for pin PIO3_1/DSR/CT16B0_MAT1/RXD
    #[inline(always)]
    pub fn iocon_pio3_1() -> &'static mut IOCON_iocon_pio3_1 {
        unsafe { ::core::intrinsics::transmute(0x40044088 as usize) }
    }
    /// I/O configuration for pin PIO2_3/RI/MOSI1
    #[inline(always)]
    pub fn iocon_pio2_3() -> &'static mut IOCON_iocon_pio2_3 {
        unsafe { ::core::intrinsics::transmute(0x4004408c as usize) }
    }
    /// I/O configuration for pin SWDIO/PIO1_3/AD4/CT32B1_MAT2
    #[inline(always)]
    pub fn iocon_swdio_pio1_3() -> &'static mut IOCON_iocon_swdio_pio1_3 {
        unsafe { ::core::intrinsics::transmute(0x40044090 as usize) }
    }
    /// I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3
    #[inline(always)]
    pub fn iocon_pio1_4() -> &'static mut IOCON_iocon_pio1_4 {
        unsafe { ::core::intrinsics::transmute(0x40044094 as usize) }
    }
    /// I/O configuration for pin PIO1_11/AD7/CT32B1_CAP1
    #[inline(always)]
    pub fn iocon_pio1_11() -> &'static mut IOCON_iocon_pio1_11 {
        unsafe { ::core::intrinsics::transmute(0x40044098 as usize) }
    }
    /// I/O configuration for pin PIO3_2/DCD/ CT16B0_MAT2/SCK1
    #[inline(always)]
    pub fn iocon_pio3_2() -> &'static mut IOCON_iocon_pio3_2 {
        unsafe { ::core::intrinsics::transmute(0x4004409c as usize) }
    }
    /// I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0
    #[inline(always)]
    pub fn iocon_pio1_5() -> &'static mut IOCON_iocon_pio1_5 {
        unsafe { ::core::intrinsics::transmute(0x400440a0 as usize) }
    }
    /// I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0
    #[inline(always)]
    pub fn iocon_pio1_6() -> &'static mut IOCON_iocon_pio1_6 {
        unsafe { ::core::intrinsics::transmute(0x400440a4 as usize) }
    }
    /// I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1
    #[inline(always)]
    pub fn iocon_pio1_7() -> &'static mut IOCON_iocon_pio1_7 {
        unsafe { ::core::intrinsics::transmute(0x400440a8 as usize) }
    }
    /// I/O configuration for pin PIO3_3/RI/ CT16B0_CAP0
    #[inline(always)]
    pub fn iocon_pio3_3() -> &'static mut IOCON_iocon_pio3_3 {
        unsafe { ::core::intrinsics::transmute(0x400440ac as usize) }
    }
    /// SCK0 pin location select register
    #[inline(always)]
    pub fn iocon_sck0_loc() -> &'static mut IOCON_iocon_sck0_loc {
        unsafe { ::core::intrinsics::transmute(0x400440b0 as usize) }
    }
    /// DSR pin location select register
    #[inline(always)]
    pub fn iocon_dsr_loc() -> &'static mut IOCON_iocon_dsr_loc {
        unsafe { ::core::intrinsics::transmute(0x400440b4 as usize) }
    }
    /// DCD pin location select register
    #[inline(always)]
    pub fn iocon_dcd_loc() -> &'static mut IOCON_iocon_dcd_loc {
        unsafe { ::core::intrinsics::transmute(0x400440b8 as usize) }
    }
    /// RI pin location select register
    #[inline(always)]
    pub fn iocon_ri_loc() -> &'static mut IOCON_iocon_ri_loc {
        unsafe { ::core::intrinsics::transmute(0x400440bc as usize) }
    }
    /// SSEL1 pin location select register
    #[inline(always)]
    pub fn iocon_ssel1_loc() -> &'static mut IOCON_iocon_ssel1_loc {
        unsafe { ::core::intrinsics::transmute(0x40044018 as usize) }
    }
    /// CT16B0_CAP0 pin location select register
    #[inline(always)]
    pub fn iocon_ct16b0_cap0_loc() -> &'static mut IOCON_iocon_ct16b0_cap0_loc {
        unsafe { ::core::intrinsics::transmute(0x400440c0 as usize) }
    }
    /// SCK1 pin location select register
    #[inline(always)]
    pub fn iocon_sck1_loc() -> &'static mut IOCON_iocon_sck1_loc {
        unsafe { ::core::intrinsics::transmute(0x400440c4 as usize) }
    }
    /// MISO1 pin location select register
    #[inline(always)]
    pub fn iocon_miso1_loc() -> &'static mut IOCON_iocon_miso1_loc {
        unsafe { ::core::intrinsics::transmute(0x400440c8 as usize) }
    }
    /// MOSI1 pin location select register
    #[inline(always)]
    pub fn iocon_mosi1_loc() -> &'static mut IOCON_iocon_mosi1_loc {
        unsafe { ::core::intrinsics::transmute(0x400440cc as usize) }
    }
    /// CT32B0_CAP0 pin location select register
    #[inline(always)]
    pub fn iocon_ct32b0_cap0_loc() -> &'static mut IOCON_iocon_ct32b0_cap0_loc {
        unsafe { ::core::intrinsics::transmute(0x400440d0 as usize) }
    }
    /// RXD pin location select register
    #[inline(always)]
    pub fn iocon_rxd_loc() -> &'static mut IOCON_iocon_rxd_loc {
        unsafe { ::core::intrinsics::transmute(0x400440d4 as usize) }
    }
    }



// Registers for SYSCON





// Register SYSMEMREMAP implementation


/// Register `SYSMEMREMAP`: System memory remap
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_sysmemremap {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_sysmemremap { }

impl SYSCON_sysmemremap {
    
    // Getters
    /// Fetch the value of the `SYSMEMREMAP` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_sysmemremap_Get {
        SYSCON_sysmemremap_Get::new(self)
    }

    
    /// Get value of `MAP` field.
    #[inline(always)]
    pub fn map(&self) -> SYSCON_sysmemremap_map {
        SYSCON_sysmemremap_Get::new(self).map()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSMEMREMAP` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_sysmemremap_Update {
        SYSCON_sysmemremap_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MAP` field.
    #[inline(always)]
    pub fn set_map<'a>(&'a mut self, new_value: SYSCON_sysmemremap_map) -> SYSCON_sysmemremap_Update<'a> {
        let mut setter: SYSCON_sysmemremap_Update = SYSCON_sysmemremap_Update::new(self);
        setter.set_map(new_value);
        setter
    }
    

    }


// Getter for SYSCON_sysmemremap
/// `SYSMEMREMAP`: System memory remap
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_sysmemremap_Get {
    value: u32,
}

impl SYSCON_sysmemremap_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_sysmemremap) -> SYSCON_sysmemremap_Get {
        SYSCON_sysmemremap_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MAP` field: System memory remap
    #[inline(always)]
    pub fn map(&self) -> SYSCON_sysmemremap_map {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(SYSCON_sysmemremap_map::Bootloader),
            1 => ::core::option::Option::Some(SYSCON_sysmemremap_map::UserRAM),
            2 => ::core::option::Option::Some(SYSCON_sysmemremap_map::UserFlash),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_sysmemremap_Get { }


// Updater for SYSCON_sysmemremap
/// Updater for `SYSMEMREMAP` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_sysmemremap_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_sysmemremap,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_sysmemremap_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_sysmemremap_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_sysmemremap) -> SYSCON_sysmemremap_Update<'a> {
        SYSCON_sysmemremap_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_sysmemremap) -> SYSCON_sysmemremap_Update<'a> {
        SYSCON_sysmemremap_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MAP` field.
    #[inline(always)]
    pub fn set_map<'b>(&'b mut self, new_value: SYSCON_sysmemremap_map) -> &'b mut SYSCON_sysmemremap_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysmemremap_map {
    /// Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM.
    Bootloader = 0,
    /// User RAM Mode. Interrupt vectors are re-mapped to Static RAM.
    UserRAM = 1,
    /// User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash.
    UserFlash = 2,
    }







// Register PRESETCTRL implementation


/// Register `PRESETCTRL`: Peripheral reset control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_presetctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_presetctrl { }

impl SYSCON_presetctrl {
    
    // Getters
    /// Fetch the value of the `PRESETCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_presetctrl_Get {
        SYSCON_presetctrl_Get::new(self)
    }

    
    /// Get value of `SSP0_RST_N` field.
    #[inline(always)]
    pub fn ssp0_rst_n(&self) -> SYSCON_presetctrl_ssp0_rst_n {
        SYSCON_presetctrl_Get::new(self).ssp0_rst_n()
    }
    
    /// Get value of `I2C_RST_N` field.
    #[inline(always)]
    pub fn i2c_rst_n(&self) -> SYSCON_presetctrl_i2c_rst_n {
        SYSCON_presetctrl_Get::new(self).i2c_rst_n()
    }
    
    /// Get value of `SSP1_RST_N` field.
    #[inline(always)]
    pub fn ssp1_rst_n(&self) -> SYSCON_presetctrl_ssp1_rst_n {
        SYSCON_presetctrl_Get::new(self).ssp1_rst_n()
    }
    
    /// Get value of `CAN_RST_N` field.
    #[inline(always)]
    pub fn can_rst_n(&self) -> SYSCON_presetctrl_can_rst_n {
        SYSCON_presetctrl_Get::new(self).can_rst_n()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PRESETCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_presetctrl_Update {
        SYSCON_presetctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SSP0_RST_N` field.
    #[inline(always)]
    pub fn set_ssp0_rst_n<'a>(&'a mut self, new_value: SYSCON_presetctrl_ssp0_rst_n) -> SYSCON_presetctrl_Update<'a> {
        let mut setter: SYSCON_presetctrl_Update = SYSCON_presetctrl_Update::new(self);
        setter.set_ssp0_rst_n(new_value);
        setter
    }
    
    /// Set value of `I2C_RST_N` field.
    #[inline(always)]
    pub fn set_i2c_rst_n<'a>(&'a mut self, new_value: SYSCON_presetctrl_i2c_rst_n) -> SYSCON_presetctrl_Update<'a> {
        let mut setter: SYSCON_presetctrl_Update = SYSCON_presetctrl_Update::new(self);
        setter.set_i2c_rst_n(new_value);
        setter
    }
    
    /// Set value of `SSP1_RST_N` field.
    #[inline(always)]
    pub fn set_ssp1_rst_n<'a>(&'a mut self, new_value: SYSCON_presetctrl_ssp1_rst_n) -> SYSCON_presetctrl_Update<'a> {
        let mut setter: SYSCON_presetctrl_Update = SYSCON_presetctrl_Update::new(self);
        setter.set_ssp1_rst_n(new_value);
        setter
    }
    
    /// Set value of `CAN_RST_N` field.
    #[inline(always)]
    pub fn set_can_rst_n<'a>(&'a mut self, new_value: SYSCON_presetctrl_can_rst_n) -> SYSCON_presetctrl_Update<'a> {
        let mut setter: SYSCON_presetctrl_Update = SYSCON_presetctrl_Update::new(self);
        setter.set_can_rst_n(new_value);
        setter
    }
    

    }


// Getter for SYSCON_presetctrl
/// `PRESETCTRL`: Peripheral reset control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_presetctrl_Get {
    value: u32,
}

impl SYSCON_presetctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_presetctrl) -> SYSCON_presetctrl_Get {
        SYSCON_presetctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SSP0_RST_N` field: SPI0 reset control
    #[inline(always)]
    pub fn ssp0_rst_n(&self) -> SYSCON_presetctrl_ssp0_rst_n {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_presetctrl_ssp0_rst_n::SPI0Reset),
            1 => ::core::option::Option::Some(SYSCON_presetctrl_ssp0_rst_n::SPI0NoReset),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `I2C_RST_N` field: I2C reset control
    #[inline(always)]
    pub fn i2c_rst_n(&self) -> SYSCON_presetctrl_i2c_rst_n {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(SYSCON_presetctrl_i2c_rst_n::I2CReset),
            1 => ::core::option::Option::Some(SYSCON_presetctrl_i2c_rst_n::I2CNoReset),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SSP1_RST_N` field: SPI1 reset control
    #[inline(always)]
    pub fn ssp1_rst_n(&self) -> SYSCON_presetctrl_ssp1_rst_n {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(SYSCON_presetctrl_ssp1_rst_n::SPI1Reset),
            1 => ::core::option::Option::Some(SYSCON_presetctrl_ssp1_rst_n::SPI2NoReset),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAN_RST_N` field: C_CAN reset control. See Section 3.1 for part specific details.
    #[inline(always)]
    pub fn can_rst_n(&self) -> SYSCON_presetctrl_can_rst_n {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(SYSCON_presetctrl_can_rst_n::CANReset),
            1 => ::core::option::Option::Some(SYSCON_presetctrl_can_rst_n::CANNoReset),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_presetctrl_Get { }


// Updater for SYSCON_presetctrl
/// Updater for `PRESETCTRL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_presetctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_presetctrl,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_presetctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_presetctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_presetctrl) -> SYSCON_presetctrl_Update<'a> {
        SYSCON_presetctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_presetctrl) -> SYSCON_presetctrl_Update<'a> {
        SYSCON_presetctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SSP0_RST_N` field.
    #[inline(always)]
    pub fn set_ssp0_rst_n<'b>(&'b mut self, new_value: SYSCON_presetctrl_ssp0_rst_n) -> &'b mut SYSCON_presetctrl_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `I2C_RST_N` field.
    #[inline(always)]
    pub fn set_i2c_rst_n<'b>(&'b mut self, new_value: SYSCON_presetctrl_i2c_rst_n) -> &'b mut SYSCON_presetctrl_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `SSP1_RST_N` field.
    #[inline(always)]
    pub fn set_ssp1_rst_n<'b>(&'b mut self, new_value: SYSCON_presetctrl_ssp1_rst_n) -> &'b mut SYSCON_presetctrl_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CAN_RST_N` field.
    #[inline(always)]
    pub fn set_can_rst_n<'b>(&'b mut self, new_value: SYSCON_presetctrl_can_rst_n) -> &'b mut SYSCON_presetctrl_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_presetctrl_ssp0_rst_n {
    /// Resets the SPI0 peripheral.
    SPI0Reset = 0,
    /// SPI0 reset de-asserted.
    SPI0NoReset = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_presetctrl_i2c_rst_n {
    /// Resets the I2C peripheral.
    I2CReset = 0,
    /// I2C reset de-asserted.
    I2CNoReset = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_presetctrl_ssp1_rst_n {
    /// Resets the SPI1 peripheral.
    SPI1Reset = 0,
    /// SPI1 reset de-asserted.
    SPI2NoReset = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_presetctrl_can_rst_n {
    /// Resets the C_CAN peripheral.
    CANReset = 0,
    /// C_CAN reset de-asserted.
    CANNoReset = 1,
    }







// Register SYSPLLCTRL implementation


/// Register `SYSPLLCTRL`: System PLL control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_syspllctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_syspllctrl { }

impl SYSCON_syspllctrl {
    
    // Getters
    /// Fetch the value of the `SYSPLLCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_syspllctrl_Get {
        SYSCON_syspllctrl_Get::new(self)
    }

    
    /// Get value of `MSEL` field.
    #[inline(always)]
    pub fn msel(&self) -> u32 {
        SYSCON_syspllctrl_Get::new(self).msel()
    }
    
    /// Get value of `PSEL` field.
    #[inline(always)]
    pub fn psel(&self) -> SYSCON_syspllctrl_psel {
        SYSCON_syspllctrl_Get::new(self).psel()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSPLLCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_syspllctrl_Update {
        SYSCON_syspllctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MSEL` field.
    #[inline(always)]
    pub fn set_msel<'a>(&'a mut self, new_value: u32) -> SYSCON_syspllctrl_Update<'a> {
        let mut setter: SYSCON_syspllctrl_Update = SYSCON_syspllctrl_Update::new(self);
        setter.set_msel(new_value);
        setter
    }
    
    /// Set value of `PSEL` field.
    #[inline(always)]
    pub fn set_psel<'a>(&'a mut self, new_value: SYSCON_syspllctrl_psel) -> SYSCON_syspllctrl_Update<'a> {
        let mut setter: SYSCON_syspllctrl_Update = SYSCON_syspllctrl_Update::new(self);
        setter.set_psel(new_value);
        setter
    }
    

    }


// Getter for SYSCON_syspllctrl
/// `SYSPLLCTRL`: System PLL control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_syspllctrl_Get {
    value: u32,
}

impl SYSCON_syspllctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_syspllctrl) -> SYSCON_syspllctrl_Get {
        SYSCON_syspllctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MSEL` field: Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32.
    #[inline(always)]
    pub fn msel(&self) -> u32 {
        (self.value >> 0) & 31
        }
    /// Get value of `PSEL` field: Post divider ratio P. The division ratio is 2 x P.
    #[inline(always)]
    pub fn psel(&self) -> SYSCON_syspllctrl_psel {
        match (self.value >> 5) & 3 {
            0 => ::core::option::Option::Some(SYSCON_syspllctrl_psel::P1),
            1 => ::core::option::Option::Some(SYSCON_syspllctrl_psel::P2),
            2 => ::core::option::Option::Some(SYSCON_syspllctrl_psel::P4),
            3 => ::core::option::Option::Some(SYSCON_syspllctrl_psel::P8),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_syspllctrl_Get { }


// Updater for SYSCON_syspllctrl
/// Updater for `SYSPLLCTRL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_syspllctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_syspllctrl,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_syspllctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_syspllctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_syspllctrl) -> SYSCON_syspllctrl_Update<'a> {
        SYSCON_syspllctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_syspllctrl) -> SYSCON_syspllctrl_Update<'a> {
        SYSCON_syspllctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MSEL` field.
    #[inline(always)]
    pub fn set_msel<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_syspllctrl_Update<'a> {
        self.value = (self.value & !(31 << 0))
                   | ((new_value as u32) & 31) << 0;
        self.mask |= 31 << 0;
        self
    }
    /// Set value of `PSEL` field.
    #[inline(always)]
    pub fn set_psel<'b>(&'b mut self, new_value: SYSCON_syspllctrl_psel) -> &'b mut SYSCON_syspllctrl_Update<'a> {
        self.value = (self.value & !(3 << 5))
                   | ((new_value as u32) & 3) << 5;
        self.mask |= 3 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_syspllctrl_psel {
    /// P = 1
    P1 = 0,
    /// P = 2
    P2 = 1,
    /// P = 4
    P4 = 2,
    /// P = 8
    P8 = 3,
    }







// Register SYSPLLSTAT implementation


/// Register `SYSPLLSTAT`: System PLL status
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_syspllstat {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_syspllstat { }

impl SYSCON_syspllstat {
    
    // Getters
    /// Fetch the value of the `SYSPLLSTAT` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_syspllstat_Get {
        SYSCON_syspllstat_Get::new(self)
    }

    
    /// Get value of `LOCK` field.
    #[inline(always)]
    pub fn lock(&self) -> SYSCON_syspllstat_lock {
        SYSCON_syspllstat_Get::new(self).lock()
    }
    

    }


// Getter for SYSCON_syspllstat
/// `SYSPLLSTAT`: System PLL status
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_syspllstat_Get {
    value: u32,
}

impl SYSCON_syspllstat_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_syspllstat) -> SYSCON_syspllstat_Get {
        SYSCON_syspllstat_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `LOCK` field: PLL lock status
    #[inline(always)]
    pub fn lock(&self) -> SYSCON_syspllstat_lock {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_syspllstat_lock::PLLNotLocked),
            1 => ::core::option::Option::Some(SYSCON_syspllstat_lock::PLLLocked),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_syspllstat_Get { }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_syspllstat_lock {
    /// PLL not locked
    PLLNotLocked = 0,
    /// PLL locked
    PLLLocked = 1,
    }







// Register SYSOSCCTRL implementation


/// Register `SYSOSCCTRL`: System oscillator control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_sysoscctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_sysoscctrl { }

impl SYSCON_sysoscctrl {
    
    // Getters
    /// Fetch the value of the `SYSOSCCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_sysoscctrl_Get {
        SYSCON_sysoscctrl_Get::new(self)
    }

    
    /// Get value of `BYPASS` field.
    #[inline(always)]
    pub fn bypass(&self) -> SYSCON_sysoscctrl_bypass {
        SYSCON_sysoscctrl_Get::new(self).bypass()
    }
    
    /// Get value of `FREQRANGE` field.
    #[inline(always)]
    pub fn freqrange(&self) -> SYSCON_sysoscctrl_freqrange {
        SYSCON_sysoscctrl_Get::new(self).freqrange()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSOSCCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_sysoscctrl_Update {
        SYSCON_sysoscctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `BYPASS` field.
    #[inline(always)]
    pub fn set_bypass<'a>(&'a mut self, new_value: SYSCON_sysoscctrl_bypass) -> SYSCON_sysoscctrl_Update<'a> {
        let mut setter: SYSCON_sysoscctrl_Update = SYSCON_sysoscctrl_Update::new(self);
        setter.set_bypass(new_value);
        setter
    }
    
    /// Set value of `FREQRANGE` field.
    #[inline(always)]
    pub fn set_freqrange<'a>(&'a mut self, new_value: SYSCON_sysoscctrl_freqrange) -> SYSCON_sysoscctrl_Update<'a> {
        let mut setter: SYSCON_sysoscctrl_Update = SYSCON_sysoscctrl_Update::new(self);
        setter.set_freqrange(new_value);
        setter
    }
    

    }


// Getter for SYSCON_sysoscctrl
/// `SYSOSCCTRL`: System oscillator control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_sysoscctrl_Get {
    value: u32,
}

impl SYSCON_sysoscctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_sysoscctrl) -> SYSCON_sysoscctrl_Get {
        SYSCON_sysoscctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `BYPASS` field: Bypass system oscillator
    #[inline(always)]
    pub fn bypass(&self) -> SYSCON_sysoscctrl_bypass {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysoscctrl_bypass::NoBypass),
            1 => ::core::option::Option::Some(SYSCON_sysoscctrl_bypass::BypassEnabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FREQRANGE` field: Determines frequency range for Low-power oscillator.
    #[inline(always)]
    pub fn freqrange(&self) -> SYSCON_sysoscctrl_freqrange {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysoscctrl_freqrange::Low),
            1 => ::core::option::Option::Some(SYSCON_sysoscctrl_freqrange::High),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_sysoscctrl_Get { }


// Updater for SYSCON_sysoscctrl
/// Updater for `SYSOSCCTRL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_sysoscctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_sysoscctrl,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_sysoscctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_sysoscctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_sysoscctrl) -> SYSCON_sysoscctrl_Update<'a> {
        SYSCON_sysoscctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_sysoscctrl) -> SYSCON_sysoscctrl_Update<'a> {
        SYSCON_sysoscctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `BYPASS` field.
    #[inline(always)]
    pub fn set_bypass<'b>(&'b mut self, new_value: SYSCON_sysoscctrl_bypass) -> &'b mut SYSCON_sysoscctrl_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `FREQRANGE` field.
    #[inline(always)]
    pub fn set_freqrange<'b>(&'b mut self, new_value: SYSCON_sysoscctrl_freqrange) -> &'b mut SYSCON_sysoscctrl_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysoscctrl_bypass {
    /// Oscillator is not bypassed.
    NoBypass = 0,
    /// Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN and XTALOUT pins.
    BypassEnabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysoscctrl_freqrange {
    /// 1 - 20 MHz frequency range.
    Low = 0,
    /// 15 - 25 MHz frequency range
    High = 1,
    }







// Register WDTOSCCTRL implementation


/// Register `WDTOSCCTRL`: Watchdog oscillator control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_wdtoscctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_wdtoscctrl { }

impl SYSCON_wdtoscctrl {
    
    // Getters
    /// Fetch the value of the `WDTOSCCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_wdtoscctrl_Get {
        SYSCON_wdtoscctrl_Get::new(self)
    }

    
    /// Get value of `DIVSEL` field.
    #[inline(always)]
    pub fn divsel(&self) -> u32 {
        SYSCON_wdtoscctrl_Get::new(self).divsel()
    }
    
    /// Get value of `FREQSEL` field.
    #[inline(always)]
    pub fn freqsel(&self) -> SYSCON_wdtoscctrl_freqsel {
        SYSCON_wdtoscctrl_Get::new(self).freqsel()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDTOSCCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_wdtoscctrl_Update {
        SYSCON_wdtoscctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIVSEL` field.
    #[inline(always)]
    pub fn set_divsel<'a>(&'a mut self, new_value: u32) -> SYSCON_wdtoscctrl_Update<'a> {
        let mut setter: SYSCON_wdtoscctrl_Update = SYSCON_wdtoscctrl_Update::new(self);
        setter.set_divsel(new_value);
        setter
    }
    
    /// Set value of `FREQSEL` field.
    #[inline(always)]
    pub fn set_freqsel<'a>(&'a mut self, new_value: SYSCON_wdtoscctrl_freqsel) -> SYSCON_wdtoscctrl_Update<'a> {
        let mut setter: SYSCON_wdtoscctrl_Update = SYSCON_wdtoscctrl_Update::new(self);
        setter.set_freqsel(new_value);
        setter
    }
    

    }


// Getter for SYSCON_wdtoscctrl
/// `WDTOSCCTRL`: Watchdog oscillator control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtoscctrl_Get {
    value: u32,
}

impl SYSCON_wdtoscctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_wdtoscctrl) -> SYSCON_wdtoscctrl_Get {
        SYSCON_wdtoscctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIVSEL` field: Select divider for Fclkana.  wdt_osc_clk = Fclkana/ (2 x (1 + DIVSEL)) 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64
    #[inline(always)]
    pub fn divsel(&self) -> u32 {
        (self.value >> 0) & 31
        }
    /// Get value of `FREQSEL` field: Select watchdog oscillator analog output frequency (Fclkana).
    #[inline(always)]
    pub fn freqsel(&self) -> SYSCON_wdtoscctrl_freqsel {
        match (self.value >> 5) & 15 {
            1 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq0_5MHz),
            2 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq0_8MHz),
            3 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq1_1MHz),
            4 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq1_4MHz),
            5 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq1_6MHz),
            6 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq1_8MHz),
            7 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq2_0MHz),
            8 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq2_2MHz),
            9 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq2_4MHz),
            10 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq2_6MHz),
            11 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq2_7MHz),
            12 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq2_9MHz),
            13 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq3_1MHz),
            14 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq3_2MHz),
            15 => ::core::option::Option::Some(SYSCON_wdtoscctrl_freqsel::Freq3_4MHz),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_wdtoscctrl_Get { }


// Updater for SYSCON_wdtoscctrl
/// Updater for `WDTOSCCTRL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtoscctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_wdtoscctrl,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_wdtoscctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_wdtoscctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_wdtoscctrl) -> SYSCON_wdtoscctrl_Update<'a> {
        SYSCON_wdtoscctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_wdtoscctrl) -> SYSCON_wdtoscctrl_Update<'a> {
        SYSCON_wdtoscctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIVSEL` field.
    #[inline(always)]
    pub fn set_divsel<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_wdtoscctrl_Update<'a> {
        self.value = (self.value & !(31 << 0))
                   | ((new_value as u32) & 31) << 0;
        self.mask |= 31 << 0;
        self
    }
    /// Set value of `FREQSEL` field.
    #[inline(always)]
    pub fn set_freqsel<'b>(&'b mut self, new_value: SYSCON_wdtoscctrl_freqsel) -> &'b mut SYSCON_wdtoscctrl_Update<'a> {
        self.value = (self.value & !(15 << 5))
                   | ((new_value as u32) & 15) << 5;
        self.mask |= 15 << 5;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_wdtoscctrl_freqsel {
    /// 0.5 MHz
    Freq0_5MHz = 1,
    /// 0.8 MHz
    Freq0_8MHz = 2,
    /// 1.1 MHz
    Freq1_1MHz = 3,
    /// 1.4 MHz
    Freq1_4MHz = 4,
    /// 1.6 MHz
    Freq1_6MHz = 5,
    /// 1.8 MHz
    Freq1_8MHz = 6,
    /// 2.0 MHz
    Freq2_0MHz = 7,
    /// 2.2 MHz
    Freq2_2MHz = 8,
    /// 2.4 MHz
    Freq2_4MHz = 9,
    /// 2.6 MHz
    Freq2_6MHz = 10,
    /// 2.7 MHz
    Freq2_7MHz = 11,
    /// 2.9 MHz
    Freq2_9MHz = 12,
    /// 3.1 MHz
    Freq3_1MHz = 13,
    /// 3.2 MHz
    Freq3_2MHz = 14,
    /// 3.4 MHz
    Freq3_4MHz = 15,
    }







// Register IRCCTRL implementation


/// Register `IRCCTRL`: IRC control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_ircctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_ircctrl { }

impl SYSCON_ircctrl {
    
    // Getters
    /// Fetch the value of the `IRCCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_ircctrl_Get {
        SYSCON_ircctrl_Get::new(self)
    }

    
    /// Get value of `TRIM` field.
    #[inline(always)]
    pub fn trim(&self) -> u32 {
        SYSCON_ircctrl_Get::new(self).trim()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IRCCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_ircctrl_Update {
        SYSCON_ircctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `TRIM` field.
    #[inline(always)]
    pub fn set_trim<'a>(&'a mut self, new_value: u32) -> SYSCON_ircctrl_Update<'a> {
        let mut setter: SYSCON_ircctrl_Update = SYSCON_ircctrl_Update::new(self);
        setter.set_trim(new_value);
        setter
    }
    

    }


// Getter for SYSCON_ircctrl
/// `IRCCTRL`: IRC control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_ircctrl_Get {
    value: u32,
}

impl SYSCON_ircctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_ircctrl) -> SYSCON_ircctrl_Get {
        SYSCON_ircctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TRIM` field: Trim value
    #[inline(always)]
    pub fn trim(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_ircctrl_Get { }


// Updater for SYSCON_ircctrl
/// Updater for `IRCCTRL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_ircctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_ircctrl,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_ircctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_ircctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_ircctrl) -> SYSCON_ircctrl_Update<'a> {
        SYSCON_ircctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_ircctrl) -> SYSCON_ircctrl_Update<'a> {
        SYSCON_ircctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `TRIM` field.
    #[inline(always)]
    pub fn set_trim<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_ircctrl_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register SYSRSTSTAT implementation


/// Register `SYSRSTSTAT`: System reset status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_sysrststat {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_sysrststat { }

impl SYSCON_sysrststat {
    
    // Getters
    /// Fetch the value of the `SYSRSTSTAT` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_sysrststat_Get {
        SYSCON_sysrststat_Get::new(self)
    }

    
    /// Get value of `POR` field.
    #[inline(always)]
    pub fn por(&self) -> SYSCON_sysrststat_por {
        SYSCON_sysrststat_Get::new(self).por()
    }
    
    /// Get value of `EXTRST` field.
    #[inline(always)]
    pub fn extrst(&self) -> SYSCON_sysrststat_extrst {
        SYSCON_sysrststat_Get::new(self).extrst()
    }
    
    /// Get value of `WDT` field.
    #[inline(always)]
    pub fn wdt(&self) -> SYSCON_sysrststat_wdt {
        SYSCON_sysrststat_Get::new(self).wdt()
    }
    
    /// Get value of `BOD` field.
    #[inline(always)]
    pub fn bod(&self) -> SYSCON_sysrststat_bod {
        SYSCON_sysrststat_Get::new(self).bod()
    }
    
    /// Get value of `SYSRST` field.
    #[inline(always)]
    pub fn sysrst(&self) -> SYSCON_sysrststat_sysrst {
        SYSCON_sysrststat_Get::new(self).sysrst()
    }
    

    }


// Getter for SYSCON_sysrststat
/// `SYSRSTSTAT`: System reset status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_sysrststat_Get {
    value: u32,
}

impl SYSCON_sysrststat_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_sysrststat) -> SYSCON_sysrststat_Get {
        SYSCON_sysrststat_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `POR` field: POR reset status
    #[inline(always)]
    pub fn por(&self) -> SYSCON_sysrststat_por {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysrststat_por::NoPORDetected),
            1 => ::core::option::Option::Some(SYSCON_sysrststat_por::PORDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EXTRST` field: Status of the external RESET pin.
    #[inline(always)]
    pub fn extrst(&self) -> SYSCON_sysrststat_extrst {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysrststat_extrst::NoResetDetected),
            1 => ::core::option::Option::Some(SYSCON_sysrststat_extrst::ResetDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WDT` field: Status of the Watchdog reset
    #[inline(always)]
    pub fn wdt(&self) -> SYSCON_sysrststat_wdt {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysrststat_wdt::NoWDTResetDetected),
            1 => ::core::option::Option::Some(SYSCON_sysrststat_wdt::WDTResetDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BOD` field: Status of the Brown-out detect reset
    #[inline(always)]
    pub fn bod(&self) -> SYSCON_sysrststat_bod {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysrststat_bod::NoBODResetDetected),
            1 => ::core::option::Option::Some(SYSCON_sysrststat_bod::BODResetDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SYSRST` field: Status of the software system reset
    #[inline(always)]
    pub fn sysrst(&self) -> SYSCON_sysrststat_sysrst {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysrststat_sysrst::NoSystemResetDetected),
            1 => ::core::option::Option::Some(SYSCON_sysrststat_sysrst::SystemResetDetected),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_sysrststat_Get { }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysrststat_por {
    /// No POR detected.
    NoPORDetected = 0,
    /// POR detected. Writing a one clears this reset.
    PORDetected = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysrststat_extrst {
    /// No RESET event detected.
    NoResetDetected = 0,
    /// RESET detected. Writing a one clears this reset.
    ResetDetected = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysrststat_wdt {
    /// No WDT reset detected.
    NoWDTResetDetected = 0,
    /// WDT reset detected. Writing a one clears this reset.
    WDTResetDetected = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysrststat_bod {
    /// No BOD reset detected.
    NoBODResetDetected = 0,
    /// BOD reset detected. Writing a one clears this reset.
    BODResetDetected = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysrststat_sysrst {
    /// No System reset detected.
    NoSystemResetDetected = 0,
    /// System reset detected. Writing a one clears this reset.
    SystemResetDetected = 1,
    }







// Register SYSPLLCLKSEL implementation


/// Register `SYSPLLCLKSEL`: System PLL clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_syspllclksel {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_syspllclksel { }

impl SYSCON_syspllclksel {
    
    // Getters
    /// Fetch the value of the `SYSPLLCLKSEL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_syspllclksel_Get {
        SYSCON_syspllclksel_Get::new(self)
    }

    
    /// Get value of `SEL` field.
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_syspllclksel_sel {
        SYSCON_syspllclksel_Get::new(self).sel()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSPLLCLKSEL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_syspllclksel_Update {
        SYSCON_syspllclksel_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'a>(&'a mut self, new_value: SYSCON_syspllclksel_sel) -> SYSCON_syspllclksel_Update<'a> {
        let mut setter: SYSCON_syspllclksel_Update = SYSCON_syspllclksel_Update::new(self);
        setter.set_sel(new_value);
        setter
    }
    

    }


// Getter for SYSCON_syspllclksel
/// `SYSPLLCLKSEL`: System PLL clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_syspllclksel_Get {
    value: u32,
}

impl SYSCON_syspllclksel_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_syspllclksel) -> SYSCON_syspllclksel_Get {
        SYSCON_syspllclksel_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SEL` field: System PLL clock source
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_syspllclksel_sel {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(SYSCON_syspllclksel_sel::IRCOscillator),
            1 => ::core::option::Option::Some(SYSCON_syspllclksel_sel::SystemOscillator),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_syspllclksel_Get { }


// Updater for SYSCON_syspllclksel
/// Updater for `SYSPLLCLKSEL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_syspllclksel_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_syspllclksel,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_syspllclksel_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_syspllclksel_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_syspllclksel) -> SYSCON_syspllclksel_Update<'a> {
        SYSCON_syspllclksel_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_syspllclksel) -> SYSCON_syspllclksel_Update<'a> {
        SYSCON_syspllclksel_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'b>(&'b mut self, new_value: SYSCON_syspllclksel_sel) -> &'b mut SYSCON_syspllclksel_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_syspllclksel_sel {
    /// IRC oscillator
    IRCOscillator = 0,
    /// System oscillator
    SystemOscillator = 1,
    }







// Register SYSPLLCLKUEN implementation


/// Register `SYSPLLCLKUEN`: System PLL clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_syspllclkuen {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_syspllclkuen { }

impl SYSCON_syspllclkuen {
    
    // Getters
    /// Fetch the value of the `SYSPLLCLKUEN` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_syspllclkuen_Get {
        SYSCON_syspllclkuen_Get::new(self)
    }

    
    /// Get value of `ENA` field.
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_syspllclkuen_ena {
        SYSCON_syspllclkuen_Get::new(self).ena()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSPLLCLKUEN` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_syspllclkuen_Update {
        SYSCON_syspllclkuen_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'a>(&'a mut self, new_value: SYSCON_syspllclkuen_ena) -> SYSCON_syspllclkuen_Update<'a> {
        let mut setter: SYSCON_syspllclkuen_Update = SYSCON_syspllclkuen_Update::new(self);
        setter.set_ena(new_value);
        setter
    }
    

    }


// Getter for SYSCON_syspllclkuen
/// `SYSPLLCLKUEN`: System PLL clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_syspllclkuen_Get {
    value: u32,
}

impl SYSCON_syspllclkuen_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_syspllclkuen) -> SYSCON_syspllclkuen_Get {
        SYSCON_syspllclkuen_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ENA` field: Enable system PLL clock source update
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_syspllclkuen_ena {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_syspllclkuen_ena::NoChange),
            1 => ::core::option::Option::Some(SYSCON_syspllclkuen_ena::UpdateClockSource),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_syspllclkuen_Get { }


// Updater for SYSCON_syspllclkuen
/// Updater for `SYSPLLCLKUEN` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_syspllclkuen_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_syspllclkuen,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_syspllclkuen_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_syspllclkuen_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_syspllclkuen) -> SYSCON_syspllclkuen_Update<'a> {
        SYSCON_syspllclkuen_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_syspllclkuen) -> SYSCON_syspllclkuen_Update<'a> {
        SYSCON_syspllclkuen_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'b>(&'b mut self, new_value: SYSCON_syspllclkuen_ena) -> &'b mut SYSCON_syspllclkuen_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_syspllclkuen_ena {
    /// No change
    NoChange = 0,
    /// Update clock source
    UpdateClockSource = 1,
    }







// Register MAINCLKSEL implementation


/// Register `MAINCLKSEL`: Main clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_mainclksel {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_mainclksel { }

impl SYSCON_mainclksel {
    
    // Getters
    /// Fetch the value of the `MAINCLKSEL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_mainclksel_Get {
        SYSCON_mainclksel_Get::new(self)
    }

    
    /// Get value of `SEL` field.
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_mainclksel_sel {
        SYSCON_mainclksel_Get::new(self).sel()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MAINCLKSEL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_mainclksel_Update {
        SYSCON_mainclksel_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'a>(&'a mut self, new_value: SYSCON_mainclksel_sel) -> SYSCON_mainclksel_Update<'a> {
        let mut setter: SYSCON_mainclksel_Update = SYSCON_mainclksel_Update::new(self);
        setter.set_sel(new_value);
        setter
    }
    

    }


// Getter for SYSCON_mainclksel
/// `MAINCLKSEL`: Main clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_mainclksel_Get {
    value: u32,
}

impl SYSCON_mainclksel_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_mainclksel) -> SYSCON_mainclksel_Get {
        SYSCON_mainclksel_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SEL` field: Clock source for main clock
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_mainclksel_sel {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(SYSCON_mainclksel_sel::IRCOscillator),
            1 => ::core::option::Option::Some(SYSCON_mainclksel_sel::InputClockToSystemPLL),
            2 => ::core::option::Option::Some(SYSCON_mainclksel_sel::WatchdogOscillator),
            3 => ::core::option::Option::Some(SYSCON_mainclksel_sel::SystemPllClockOut),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_mainclksel_Get { }


// Updater for SYSCON_mainclksel
/// Updater for `MAINCLKSEL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_mainclksel_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_mainclksel,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_mainclksel_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_mainclksel_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_mainclksel) -> SYSCON_mainclksel_Update<'a> {
        SYSCON_mainclksel_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_mainclksel) -> SYSCON_mainclksel_Update<'a> {
        SYSCON_mainclksel_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'b>(&'b mut self, new_value: SYSCON_mainclksel_sel) -> &'b mut SYSCON_mainclksel_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_mainclksel_sel {
    /// IRC oscillator
    IRCOscillator = 0,
    /// Input clock to system PLL
    InputClockToSystemPLL = 1,
    /// WDT oscillator
    WatchdogOscillator = 2,
    /// System PLL clock out
    SystemPllClockOut = 3,
    }







// Register MAINCLKUEN implementation


/// Register `MAINCLKUEN`: Main clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_mainclkuen {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_mainclkuen { }

impl SYSCON_mainclkuen {
    
    // Getters
    /// Fetch the value of the `MAINCLKUEN` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_mainclkuen_Get {
        SYSCON_mainclkuen_Get::new(self)
    }

    
    /// Get value of `ENA` field.
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_mainclkuen_ena {
        SYSCON_mainclkuen_Get::new(self).ena()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `MAINCLKUEN` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_mainclkuen_Update {
        SYSCON_mainclkuen_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'a>(&'a mut self, new_value: SYSCON_mainclkuen_ena) -> SYSCON_mainclkuen_Update<'a> {
        let mut setter: SYSCON_mainclkuen_Update = SYSCON_mainclkuen_Update::new(self);
        setter.set_ena(new_value);
        setter
    }
    

    }


// Getter for SYSCON_mainclkuen
/// `MAINCLKUEN`: Main clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_mainclkuen_Get {
    value: u32,
}

impl SYSCON_mainclkuen_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_mainclkuen) -> SYSCON_mainclkuen_Get {
        SYSCON_mainclkuen_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ENA` field: Enable main clock source update
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_mainclkuen_ena {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_mainclkuen_ena::NoChange),
            1 => ::core::option::Option::Some(SYSCON_mainclkuen_ena::UpdateClockSource),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_mainclkuen_Get { }


// Updater for SYSCON_mainclkuen
/// Updater for `MAINCLKUEN` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_mainclkuen_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_mainclkuen,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_mainclkuen_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_mainclkuen_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_mainclkuen) -> SYSCON_mainclkuen_Update<'a> {
        SYSCON_mainclkuen_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_mainclkuen) -> SYSCON_mainclkuen_Update<'a> {
        SYSCON_mainclkuen_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'b>(&'b mut self, new_value: SYSCON_mainclkuen_ena) -> &'b mut SYSCON_mainclkuen_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_mainclkuen_ena {
    /// No change
    NoChange = 0,
    /// Update clock source
    UpdateClockSource = 1,
    }







// Register SYSAHBCLKDIV implementation


/// Register `SYSAHBCLKDIV`: System AHB clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_sysahbclkdiv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_sysahbclkdiv { }

impl SYSCON_sysahbclkdiv {
    
    // Getters
    /// Fetch the value of the `SYSAHBCLKDIV` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_sysahbclkdiv_Get {
        SYSCON_sysahbclkdiv_Get::new(self)
    }

    
    /// Get value of `DIV` field.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        SYSCON_sysahbclkdiv_Get::new(self).div()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSAHBCLKDIV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_sysahbclkdiv_Update {
        SYSCON_sysahbclkdiv_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'a>(&'a mut self, new_value: u32) -> SYSCON_sysahbclkdiv_Update<'a> {
        let mut setter: SYSCON_sysahbclkdiv_Update = SYSCON_sysahbclkdiv_Update::new(self);
        setter.set_div(new_value);
        setter
    }
    

    }


// Getter for SYSCON_sysahbclkdiv
/// `SYSAHBCLKDIV`: System AHB clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_sysahbclkdiv_Get {
    value: u32,
}

impl SYSCON_sysahbclkdiv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_sysahbclkdiv) -> SYSCON_sysahbclkdiv_Get {
        SYSCON_sysahbclkdiv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIV` field: System AHB clock divider values 0: System clock disabled.  1: Divide by 1. to 255: Divide by 255.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_sysahbclkdiv_Get { }


// Updater for SYSCON_sysahbclkdiv
/// Updater for `SYSAHBCLKDIV` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_sysahbclkdiv_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_sysahbclkdiv,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_sysahbclkdiv_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_sysahbclkdiv_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_sysahbclkdiv) -> SYSCON_sysahbclkdiv_Update<'a> {
        SYSCON_sysahbclkdiv_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_sysahbclkdiv) -> SYSCON_sysahbclkdiv_Update<'a> {
        SYSCON_sysahbclkdiv_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_sysahbclkdiv_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register SYSAHBCLKCTRL implementation


/// Register `SYSAHBCLKCTRL`: System AHB clock control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_sysahbclkctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_sysahbclkctrl { }

impl SYSCON_sysahbclkctrl {
    
    // Getters
    /// Fetch the value of the `SYSAHBCLKCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_sysahbclkctrl_Get {
        SYSCON_sysahbclkctrl_Get::new(self)
    }

    
    /// Get value of `ROM` field.
    #[inline(always)]
    pub fn rom(&self) -> SYSCON_sysahbclkctrl_rom {
        SYSCON_sysahbclkctrl_Get::new(self).rom()
    }
    
    /// Get value of `RAM` field.
    #[inline(always)]
    pub fn ram(&self) -> SYSCON_sysahbclkctrl_ram {
        SYSCON_sysahbclkctrl_Get::new(self).ram()
    }
    
    /// Get value of `FLASHREG` field.
    #[inline(always)]
    pub fn flashreg(&self) -> SYSCON_sysahbclkctrl_flashreg {
        SYSCON_sysahbclkctrl_Get::new(self).flashreg()
    }
    
    /// Get value of `FLASHARRAY` field.
    #[inline(always)]
    pub fn flasharray(&self) -> SYSCON_sysahbclkctrl_flasharray {
        SYSCON_sysahbclkctrl_Get::new(self).flasharray()
    }
    
    /// Get value of `I2C` field.
    #[inline(always)]
    pub fn i2c(&self) -> SYSCON_sysahbclkctrl_i2c {
        SYSCON_sysahbclkctrl_Get::new(self).i2c()
    }
    
    /// Get value of `GPIO` field.
    #[inline(always)]
    pub fn gpio(&self) -> SYSCON_sysahbclkctrl_gpio {
        SYSCON_sysahbclkctrl_Get::new(self).gpio()
    }
    
    /// Get value of `CT16B0` field.
    #[inline(always)]
    pub fn ct16b0(&self) -> SYSCON_sysahbclkctrl_ct16b0 {
        SYSCON_sysahbclkctrl_Get::new(self).ct16b0()
    }
    
    /// Get value of `CT16B1` field.
    #[inline(always)]
    pub fn ct16b1(&self) -> SYSCON_sysahbclkctrl_ct16b1 {
        SYSCON_sysahbclkctrl_Get::new(self).ct16b1()
    }
    
    /// Get value of `CT32B0` field.
    #[inline(always)]
    pub fn ct32b0(&self) -> SYSCON_sysahbclkctrl_ct32b0 {
        SYSCON_sysahbclkctrl_Get::new(self).ct32b0()
    }
    
    /// Get value of `CT32B1` field.
    #[inline(always)]
    pub fn ct32b1(&self) -> SYSCON_sysahbclkctrl_ct32b1 {
        SYSCON_sysahbclkctrl_Get::new(self).ct32b1()
    }
    
    /// Get value of `SSP0` field.
    #[inline(always)]
    pub fn ssp0(&self) -> SYSCON_sysahbclkctrl_ssp0 {
        SYSCON_sysahbclkctrl_Get::new(self).ssp0()
    }
    
    /// Get value of `UART` field.
    #[inline(always)]
    pub fn uart(&self) -> SYSCON_sysahbclkctrl_uart {
        SYSCON_sysahbclkctrl_Get::new(self).uart()
    }
    
    /// Get value of `ADC` field.
    #[inline(always)]
    pub fn adc(&self) -> SYSCON_sysahbclkctrl_adc {
        SYSCON_sysahbclkctrl_Get::new(self).adc()
    }
    
    /// Get value of `WDT` field.
    #[inline(always)]
    pub fn wdt(&self) -> SYSCON_sysahbclkctrl_wdt {
        SYSCON_sysahbclkctrl_Get::new(self).wdt()
    }
    
    /// Get value of `IOCON` field.
    #[inline(always)]
    pub fn iocon(&self) -> SYSCON_sysahbclkctrl_iocon {
        SYSCON_sysahbclkctrl_Get::new(self).iocon()
    }
    
    /// Get value of `CAN` field.
    #[inline(always)]
    pub fn can(&self) -> SYSCON_sysahbclkctrl_can {
        SYSCON_sysahbclkctrl_Get::new(self).can()
    }
    
    /// Get value of `SSP1` field.
    #[inline(always)]
    pub fn ssp1(&self) -> SYSCON_sysahbclkctrl_ssp1 {
        SYSCON_sysahbclkctrl_Get::new(self).ssp1()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSAHBCLKCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_sysahbclkctrl_Update {
        SYSCON_sysahbclkctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ROM` field.
    #[inline(always)]
    pub fn set_rom<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_rom) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_rom(new_value);
        setter
    }
    
    /// Set value of `RAM` field.
    #[inline(always)]
    pub fn set_ram<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_ram) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_ram(new_value);
        setter
    }
    
    /// Set value of `FLASHREG` field.
    #[inline(always)]
    pub fn set_flashreg<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_flashreg) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_flashreg(new_value);
        setter
    }
    
    /// Set value of `FLASHARRAY` field.
    #[inline(always)]
    pub fn set_flasharray<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_flasharray) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_flasharray(new_value);
        setter
    }
    
    /// Set value of `I2C` field.
    #[inline(always)]
    pub fn set_i2c<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_i2c) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_i2c(new_value);
        setter
    }
    
    /// Set value of `GPIO` field.
    #[inline(always)]
    pub fn set_gpio<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_gpio) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_gpio(new_value);
        setter
    }
    
    /// Set value of `CT16B0` field.
    #[inline(always)]
    pub fn set_ct16b0<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_ct16b0) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_ct16b0(new_value);
        setter
    }
    
    /// Set value of `CT16B1` field.
    #[inline(always)]
    pub fn set_ct16b1<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_ct16b1) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_ct16b1(new_value);
        setter
    }
    
    /// Set value of `CT32B0` field.
    #[inline(always)]
    pub fn set_ct32b0<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_ct32b0) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_ct32b0(new_value);
        setter
    }
    
    /// Set value of `CT32B1` field.
    #[inline(always)]
    pub fn set_ct32b1<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_ct32b1) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_ct32b1(new_value);
        setter
    }
    
    /// Set value of `SSP0` field.
    #[inline(always)]
    pub fn set_ssp0<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_ssp0) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_ssp0(new_value);
        setter
    }
    
    /// Set value of `UART` field.
    #[inline(always)]
    pub fn set_uart<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_uart) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_uart(new_value);
        setter
    }
    
    /// Set value of `ADC` field.
    #[inline(always)]
    pub fn set_adc<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_adc) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_adc(new_value);
        setter
    }
    
    /// Set value of `WDT` field.
    #[inline(always)]
    pub fn set_wdt<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_wdt) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_wdt(new_value);
        setter
    }
    
    /// Set value of `IOCON` field.
    #[inline(always)]
    pub fn set_iocon<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_iocon) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_iocon(new_value);
        setter
    }
    
    /// Set value of `CAN` field.
    #[inline(always)]
    pub fn set_can<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_can) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_can(new_value);
        setter
    }
    
    /// Set value of `SSP1` field.
    #[inline(always)]
    pub fn set_ssp1<'a>(&'a mut self, new_value: SYSCON_sysahbclkctrl_ssp1) -> SYSCON_sysahbclkctrl_Update<'a> {
        let mut setter: SYSCON_sysahbclkctrl_Update = SYSCON_sysahbclkctrl_Update::new(self);
        setter.set_ssp1(new_value);
        setter
    }
    

    }


// Getter for SYSCON_sysahbclkctrl
/// `SYSAHBCLKCTRL`: System AHB clock control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_sysahbclkctrl_Get {
    value: u32,
}

impl SYSCON_sysahbclkctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_sysahbclkctrl) -> SYSCON_sysahbclkctrl_Get {
        SYSCON_sysahbclkctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ROM` field: Enables clock for ROM.
    #[inline(always)]
    pub fn rom(&self) -> SYSCON_sysahbclkctrl_rom {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_rom::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_rom::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RAM` field: Enables clock for RAM.
    #[inline(always)]
    pub fn ram(&self) -> SYSCON_sysahbclkctrl_ram {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ram::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ram::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FLASHREG` field: Enables clock for flash register interface.
    #[inline(always)]
    pub fn flashreg(&self) -> SYSCON_sysahbclkctrl_flashreg {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_flashreg::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_flashreg::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FLASHARRAY` field: Enables clock for flash array access.
    #[inline(always)]
    pub fn flasharray(&self) -> SYSCON_sysahbclkctrl_flasharray {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_flasharray::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_flasharray::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `I2C` field: Enables clock for I2C.
    #[inline(always)]
    pub fn i2c(&self) -> SYSCON_sysahbclkctrl_i2c {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_i2c::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_i2c::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `GPIO` field: Enables clock for GPIO.
    #[inline(always)]
    pub fn gpio(&self) -> SYSCON_sysahbclkctrl_gpio {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_gpio::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_gpio::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CT16B0` field: Enables clock for 16-bit counter/timer 0.
    #[inline(always)]
    pub fn ct16b0(&self) -> SYSCON_sysahbclkctrl_ct16b0 {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct16b0::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct16b0::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CT16B1` field: Enables clock for 16-bit counter/timer 1.
    #[inline(always)]
    pub fn ct16b1(&self) -> SYSCON_sysahbclkctrl_ct16b1 {
        match (self.value >> 8) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct16b1::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct16b1::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CT32B0` field: Enables clock for 32-bit counter/timer 0.
    #[inline(always)]
    pub fn ct32b0(&self) -> SYSCON_sysahbclkctrl_ct32b0 {
        match (self.value >> 9) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct32b0::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct32b0::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CT32B1` field: Enables clock for 32-bit counter/timer 1.
    #[inline(always)]
    pub fn ct32b1(&self) -> SYSCON_sysahbclkctrl_ct32b1 {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct32b1::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ct32b1::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SSP0` field: Enables clock for SPI0.
    #[inline(always)]
    pub fn ssp0(&self) -> SYSCON_sysahbclkctrl_ssp0 {
        match (self.value >> 11) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ssp0::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ssp0::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `UART` field: Enables clock for UART. See Section 3.1 for part specific details.
    #[inline(always)]
    pub fn uart(&self) -> SYSCON_sysahbclkctrl_uart {
        match (self.value >> 12) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_uart::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_uart::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADC` field: Enables clock for ADC.
    #[inline(always)]
    pub fn adc(&self) -> SYSCON_sysahbclkctrl_adc {
        match (self.value >> 13) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_adc::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_adc::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WDT` field: Enables clock for WDT.
    #[inline(always)]
    pub fn wdt(&self) -> SYSCON_sysahbclkctrl_wdt {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_wdt::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_wdt::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `IOCON` field: Enables clock for I/O configuration block.
    #[inline(always)]
    pub fn iocon(&self) -> SYSCON_sysahbclkctrl_iocon {
        match (self.value >> 16) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_iocon::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_iocon::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CAN` field: Enables clock for C_CAN. See Section 3.1 for part specific details.
    #[inline(always)]
    pub fn can(&self) -> SYSCON_sysahbclkctrl_can {
        match (self.value >> 17) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_can::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_can::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SSP1` field: Enables clock for SPI1.
    #[inline(always)]
    pub fn ssp1(&self) -> SYSCON_sysahbclkctrl_ssp1 {
        match (self.value >> 18) & 1 {
            0 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ssp1::Disabled),
            1 => ::core::option::Option::Some(SYSCON_sysahbclkctrl_ssp1::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_sysahbclkctrl_Get { }


// Updater for SYSCON_sysahbclkctrl
/// Updater for `SYSAHBCLKCTRL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_sysahbclkctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_sysahbclkctrl,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_sysahbclkctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_sysahbclkctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_sysahbclkctrl) -> SYSCON_sysahbclkctrl_Update<'a> {
        SYSCON_sysahbclkctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_sysahbclkctrl) -> SYSCON_sysahbclkctrl_Update<'a> {
        SYSCON_sysahbclkctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ROM` field.
    #[inline(always)]
    pub fn set_rom<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_rom) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `RAM` field.
    #[inline(always)]
    pub fn set_ram<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_ram) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `FLASHREG` field.
    #[inline(always)]
    pub fn set_flashreg<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_flashreg) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `FLASHARRAY` field.
    #[inline(always)]
    pub fn set_flasharray<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_flasharray) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `I2C` field.
    #[inline(always)]
    pub fn set_i2c<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_i2c) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `GPIO` field.
    #[inline(always)]
    pub fn set_gpio<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_gpio) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `CT16B0` field.
    #[inline(always)]
    pub fn set_ct16b0<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_ct16b0) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `CT16B1` field.
    #[inline(always)]
    pub fn set_ct16b1<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_ct16b1) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `CT32B0` field.
    #[inline(always)]
    pub fn set_ct32b0<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_ct32b0) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `CT32B1` field.
    #[inline(always)]
    pub fn set_ct32b1<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_ct32b1) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `SSP0` field.
    #[inline(always)]
    pub fn set_ssp0<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_ssp0) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `UART` field.
    #[inline(always)]
    pub fn set_uart<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_uart) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Set value of `ADC` field.
    #[inline(always)]
    pub fn set_adc<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_adc) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 13))
                   | ((new_value as u32) & 1) << 13;
        self.mask |= 1 << 13;
        self
    }
    /// Set value of `WDT` field.
    #[inline(always)]
    pub fn set_wdt<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_wdt) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Set value of `IOCON` field.
    #[inline(always)]
    pub fn set_iocon<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_iocon) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 16))
                   | ((new_value as u32) & 1) << 16;
        self.mask |= 1 << 16;
        self
    }
    /// Set value of `CAN` field.
    #[inline(always)]
    pub fn set_can<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_can) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 17))
                   | ((new_value as u32) & 1) << 17;
        self.mask |= 1 << 17;
        self
    }
    /// Set value of `SSP1` field.
    #[inline(always)]
    pub fn set_ssp1<'b>(&'b mut self, new_value: SYSCON_sysahbclkctrl_ssp1) -> &'b mut SYSCON_sysahbclkctrl_Update<'a> {
        self.value = (self.value & !(1 << 18))
                   | ((new_value as u32) & 1) << 18;
        self.mask |= 1 << 18;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_rom {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_ram {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_flashreg {
    /// Disabled
    Disabled = 0,
    /// Enabled
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_flasharray {
    /// Disabled
    Disabled = 0,
    /// Enabled
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_i2c {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_gpio {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_ct16b0 {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_ct16b1 {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_ct32b0 {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_ct32b1 {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_ssp0 {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_uart {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_adc {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_wdt {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_iocon {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_can {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_sysahbclkctrl_ssp1 {
    /// Disable
    Disabled = 0,
    /// Enable
    Enabled = 1,
    }







// Register SSP0CLKDIV implementation


/// Register `SSP0CLKDIV`: SPI0 clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_ssp0clkdiv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_ssp0clkdiv { }

impl SYSCON_ssp0clkdiv {
    
    // Getters
    /// Fetch the value of the `SSP0CLKDIV` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_ssp0clkdiv_Get {
        SYSCON_ssp0clkdiv_Get::new(self)
    }

    
    /// Get value of `DIV` field.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        SYSCON_ssp0clkdiv_Get::new(self).div()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SSP0CLKDIV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_ssp0clkdiv_Update {
        SYSCON_ssp0clkdiv_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'a>(&'a mut self, new_value: u32) -> SYSCON_ssp0clkdiv_Update<'a> {
        let mut setter: SYSCON_ssp0clkdiv_Update = SYSCON_ssp0clkdiv_Update::new(self);
        setter.set_div(new_value);
        setter
    }
    

    }


// Getter for SYSCON_ssp0clkdiv
/// `SSP0CLKDIV`: SPI0 clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_ssp0clkdiv_Get {
    value: u32,
}

impl SYSCON_ssp0clkdiv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_ssp0clkdiv) -> SYSCON_ssp0clkdiv_Get {
        SYSCON_ssp0clkdiv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIV` field: SPI0_PCLK clock divider values 0: Disable SPI0_PCLK.  1: Divide by 1. to 255: Divide by 255.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_ssp0clkdiv_Get { }


// Updater for SYSCON_ssp0clkdiv
/// Updater for `SSP0CLKDIV` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_ssp0clkdiv_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_ssp0clkdiv,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_ssp0clkdiv_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_ssp0clkdiv_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_ssp0clkdiv) -> SYSCON_ssp0clkdiv_Update<'a> {
        SYSCON_ssp0clkdiv_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_ssp0clkdiv) -> SYSCON_ssp0clkdiv_Update<'a> {
        SYSCON_ssp0clkdiv_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_ssp0clkdiv_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register UARTCLKDIV implementation


/// Register `UARTCLKDIV`: UART clock divder
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_uartclkdiv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_uartclkdiv { }

impl SYSCON_uartclkdiv {
    
    // Getters
    /// Fetch the value of the `UARTCLKDIV` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_uartclkdiv_Get {
        SYSCON_uartclkdiv_Get::new(self)
    }

    
    /// Get value of `DIV` field.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        SYSCON_uartclkdiv_Get::new(self).div()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `UARTCLKDIV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_uartclkdiv_Update {
        SYSCON_uartclkdiv_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'a>(&'a mut self, new_value: u32) -> SYSCON_uartclkdiv_Update<'a> {
        let mut setter: SYSCON_uartclkdiv_Update = SYSCON_uartclkdiv_Update::new(self);
        setter.set_div(new_value);
        setter
    }
    

    }


// Getter for SYSCON_uartclkdiv
/// `UARTCLKDIV`: UART clock divder
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_uartclkdiv_Get {
    value: u32,
}

impl SYSCON_uartclkdiv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_uartclkdiv) -> SYSCON_uartclkdiv_Get {
        SYSCON_uartclkdiv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIV` field: UART_PCLK clock divider values 0: Disable UART_PCLK.  1: Divide by 1. to 255: Divide by 255.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_uartclkdiv_Get { }


// Updater for SYSCON_uartclkdiv
/// Updater for `UARTCLKDIV` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_uartclkdiv_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_uartclkdiv,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_uartclkdiv_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_uartclkdiv_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_uartclkdiv) -> SYSCON_uartclkdiv_Update<'a> {
        SYSCON_uartclkdiv_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_uartclkdiv) -> SYSCON_uartclkdiv_Update<'a> {
        SYSCON_uartclkdiv_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_uartclkdiv_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register SSP1CLKDIV implementation


/// Register `SSP1CLKDIV`: SPI1 clock divder
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_ssp1clkdiv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_ssp1clkdiv { }

impl SYSCON_ssp1clkdiv {
    
    // Getters
    /// Fetch the value of the `SSP1CLKDIV` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_ssp1clkdiv_Get {
        SYSCON_ssp1clkdiv_Get::new(self)
    }

    
    /// Get value of `DIV` field.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        SYSCON_ssp1clkdiv_Get::new(self).div()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SSP1CLKDIV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_ssp1clkdiv_Update {
        SYSCON_ssp1clkdiv_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'a>(&'a mut self, new_value: u32) -> SYSCON_ssp1clkdiv_Update<'a> {
        let mut setter: SYSCON_ssp1clkdiv_Update = SYSCON_ssp1clkdiv_Update::new(self);
        setter.set_div(new_value);
        setter
    }
    

    }


// Getter for SYSCON_ssp1clkdiv
/// `SSP1CLKDIV`: SPI1 clock divder
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_ssp1clkdiv_Get {
    value: u32,
}

impl SYSCON_ssp1clkdiv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_ssp1clkdiv) -> SYSCON_ssp1clkdiv_Get {
        SYSCON_ssp1clkdiv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIV` field: SPI1_PCLK clock divider values 0: Disable SPI1_PCLK.  1: Divide by 1. to 255: Divide by 255.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_ssp1clkdiv_Get { }


// Updater for SYSCON_ssp1clkdiv
/// Updater for `SSP1CLKDIV` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_ssp1clkdiv_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_ssp1clkdiv,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_ssp1clkdiv_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_ssp1clkdiv_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_ssp1clkdiv) -> SYSCON_ssp1clkdiv_Update<'a> {
        SYSCON_ssp1clkdiv_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_ssp1clkdiv) -> SYSCON_ssp1clkdiv_Update<'a> {
        SYSCON_ssp1clkdiv_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_ssp1clkdiv_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register WDTCLKSEL implementation


/// Register `WDTCLKSEL`: WDT clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_wdtclksel {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_wdtclksel { }

impl SYSCON_wdtclksel {
    
    // Getters
    /// Fetch the value of the `WDTCLKSEL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_wdtclksel_Get {
        SYSCON_wdtclksel_Get::new(self)
    }

    
    /// Get value of `SEL` field.
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_wdtclksel_sel {
        SYSCON_wdtclksel_Get::new(self).sel()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDTCLKSEL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_wdtclksel_Update {
        SYSCON_wdtclksel_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'a>(&'a mut self, new_value: SYSCON_wdtclksel_sel) -> SYSCON_wdtclksel_Update<'a> {
        let mut setter: SYSCON_wdtclksel_Update = SYSCON_wdtclksel_Update::new(self);
        setter.set_sel(new_value);
        setter
    }
    

    }


// Getter for SYSCON_wdtclksel
/// `WDTCLKSEL`: WDT clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtclksel_Get {
    value: u32,
}

impl SYSCON_wdtclksel_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_wdtclksel) -> SYSCON_wdtclksel_Get {
        SYSCON_wdtclksel_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SEL` field: WDT clock source
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_wdtclksel_sel {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(SYSCON_wdtclksel_sel::IRCOscillator),
            1 => ::core::option::Option::Some(SYSCON_wdtclksel_sel::MainClock),
            2 => ::core::option::Option::Some(SYSCON_wdtclksel_sel::WatchdogOscillator),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_wdtclksel_Get { }


// Updater for SYSCON_wdtclksel
/// Updater for `WDTCLKSEL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtclksel_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_wdtclksel,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_wdtclksel_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_wdtclksel_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_wdtclksel) -> SYSCON_wdtclksel_Update<'a> {
        SYSCON_wdtclksel_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_wdtclksel) -> SYSCON_wdtclksel_Update<'a> {
        SYSCON_wdtclksel_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'b>(&'b mut self, new_value: SYSCON_wdtclksel_sel) -> &'b mut SYSCON_wdtclksel_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_wdtclksel_sel {
    /// IRC oscillator
    IRCOscillator = 0,
    /// Main clock
    MainClock = 1,
    /// Watchdog oscillator
    WatchdogOscillator = 2,
    }







// Register WDTCLKUEN implementation


/// Register `WDTCLKUEN`: WDT clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_wdtclkuen {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_wdtclkuen { }

impl SYSCON_wdtclkuen {
    
    // Getters
    /// Fetch the value of the `WDTCLKUEN` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_wdtclkuen_Get {
        SYSCON_wdtclkuen_Get::new(self)
    }

    
    /// Get value of `ENA` field.
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_wdtclkuen_ena {
        SYSCON_wdtclkuen_Get::new(self).ena()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDTCLKUEN` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_wdtclkuen_Update {
        SYSCON_wdtclkuen_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'a>(&'a mut self, new_value: SYSCON_wdtclkuen_ena) -> SYSCON_wdtclkuen_Update<'a> {
        let mut setter: SYSCON_wdtclkuen_Update = SYSCON_wdtclkuen_Update::new(self);
        setter.set_ena(new_value);
        setter
    }
    

    }


// Getter for SYSCON_wdtclkuen
/// `WDTCLKUEN`: WDT clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtclkuen_Get {
    value: u32,
}

impl SYSCON_wdtclkuen_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_wdtclkuen) -> SYSCON_wdtclkuen_Get {
        SYSCON_wdtclkuen_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ENA` field: Enable WDT clock source update
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_wdtclkuen_ena {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_wdtclkuen_ena::NoChange),
            1 => ::core::option::Option::Some(SYSCON_wdtclkuen_ena::UpdateClockSource),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_wdtclkuen_Get { }


// Updater for SYSCON_wdtclkuen
/// Updater for `WDTCLKUEN` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtclkuen_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_wdtclkuen,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_wdtclkuen_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_wdtclkuen_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_wdtclkuen) -> SYSCON_wdtclkuen_Update<'a> {
        SYSCON_wdtclkuen_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_wdtclkuen) -> SYSCON_wdtclkuen_Update<'a> {
        SYSCON_wdtclkuen_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'b>(&'b mut self, new_value: SYSCON_wdtclkuen_ena) -> &'b mut SYSCON_wdtclkuen_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_wdtclkuen_ena {
    /// No change
    NoChange = 0,
    /// Update clock source
    UpdateClockSource = 1,
    }







// Register WDTCLKDIV implementation


/// Register `WDTCLKDIV`: WDT clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_wdtclkdiv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_wdtclkdiv { }

impl SYSCON_wdtclkdiv {
    
    // Getters
    /// Fetch the value of the `WDTCLKDIV` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_wdtclkdiv_Get {
        SYSCON_wdtclkdiv_Get::new(self)
    }

    
    /// Get value of `DIV` field.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        SYSCON_wdtclkdiv_Get::new(self).div()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `WDTCLKDIV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_wdtclkdiv_Update {
        SYSCON_wdtclkdiv_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'a>(&'a mut self, new_value: u32) -> SYSCON_wdtclkdiv_Update<'a> {
        let mut setter: SYSCON_wdtclkdiv_Update = SYSCON_wdtclkdiv_Update::new(self);
        setter.set_div(new_value);
        setter
    }
    

    }


// Getter for SYSCON_wdtclkdiv
/// `WDTCLKDIV`: WDT clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtclkdiv_Get {
    value: u32,
}

impl SYSCON_wdtclkdiv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_wdtclkdiv) -> SYSCON_wdtclkdiv_Get {
        SYSCON_wdtclkdiv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIV` field: WDT clock divider values 0: Disable WDCLK.  1: Divide by 1. to 255: Divide by 255.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_wdtclkdiv_Get { }


// Updater for SYSCON_wdtclkdiv
/// Updater for `WDTCLKDIV` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_wdtclkdiv_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_wdtclkdiv,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_wdtclkdiv_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_wdtclkdiv_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_wdtclkdiv) -> SYSCON_wdtclkdiv_Update<'a> {
        SYSCON_wdtclkdiv_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_wdtclkdiv) -> SYSCON_wdtclkdiv_Update<'a> {
        SYSCON_wdtclkdiv_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_wdtclkdiv_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CLKOUTCLKSEL implementation


/// Register `CLKOUTCLKSEL`: CLKOUT clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_clkoutclksel {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_clkoutclksel { }

impl SYSCON_clkoutclksel {
    
    // Getters
    /// Fetch the value of the `CLKOUTCLKSEL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_clkoutclksel_Get {
        SYSCON_clkoutclksel_Get::new(self)
    }

    
    /// Get value of `SEL` field.
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_clkoutclksel_sel {
        SYSCON_clkoutclksel_Get::new(self).sel()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CLKOUTCLKSEL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_clkoutclksel_Update {
        SYSCON_clkoutclksel_Update::new_ignoring_state(self)
    }

    
    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'a>(&'a mut self, new_value: SYSCON_clkoutclksel_sel) -> SYSCON_clkoutclksel_Update<'a> {
        let mut setter: SYSCON_clkoutclksel_Update = SYSCON_clkoutclksel_Update::new(self);
        setter.set_sel(new_value);
        setter
    }
    

    }


// Getter for SYSCON_clkoutclksel
/// `CLKOUTCLKSEL`: CLKOUT clock source select
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_clkoutclksel_Get {
    value: u32,
}

impl SYSCON_clkoutclksel_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_clkoutclksel) -> SYSCON_clkoutclksel_Get {
        SYSCON_clkoutclksel_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SEL` field: CLKOUT clock source
    #[inline(always)]
    pub fn sel(&self) -> SYSCON_clkoutclksel_sel {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(SYSCON_clkoutclksel_sel::IRCOscillator),
            1 => ::core::option::Option::Some(SYSCON_clkoutclksel_sel::SystemOscillator),
            2 => ::core::option::Option::Some(SYSCON_clkoutclksel_sel::WatchdogOscillator),
            3 => ::core::option::Option::Some(SYSCON_clkoutclksel_sel::MainClock),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_clkoutclksel_Get { }


// Updater for SYSCON_clkoutclksel
/// Updater for `CLKOUTCLKSEL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_clkoutclksel_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_clkoutclksel,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_clkoutclksel_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_clkoutclksel_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_clkoutclksel) -> SYSCON_clkoutclksel_Update<'a> {
        SYSCON_clkoutclksel_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_clkoutclksel) -> SYSCON_clkoutclksel_Update<'a> {
        SYSCON_clkoutclksel_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `SEL` field.
    #[inline(always)]
    pub fn set_sel<'b>(&'b mut self, new_value: SYSCON_clkoutclksel_sel) -> &'b mut SYSCON_clkoutclksel_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_clkoutclksel_sel {
    /// IRC oscillator
    IRCOscillator = 0,
    /// System oscillator
    SystemOscillator = 1,
    /// Watchdog oscillator
    WatchdogOscillator = 2,
    /// Main clock
    MainClock = 3,
    }







// Register CLKOUTUEN implementation


/// Register `CLKOUTUEN`: CLKOUT clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_clkoutuen {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_clkoutuen { }

impl SYSCON_clkoutuen {
    
    // Getters
    /// Fetch the value of the `CLKOUTUEN` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_clkoutuen_Get {
        SYSCON_clkoutuen_Get::new(self)
    }

    
    /// Get value of `ENA` field.
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_clkoutuen_ena {
        SYSCON_clkoutuen_Get::new(self).ena()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CLKOUTUEN` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_clkoutuen_Update {
        SYSCON_clkoutuen_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'a>(&'a mut self, new_value: SYSCON_clkoutuen_ena) -> SYSCON_clkoutuen_Update<'a> {
        let mut setter: SYSCON_clkoutuen_Update = SYSCON_clkoutuen_Update::new(self);
        setter.set_ena(new_value);
        setter
    }
    

    }


// Getter for SYSCON_clkoutuen
/// `CLKOUTUEN`: CLKOUT clock source update enable
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_clkoutuen_Get {
    value: u32,
}

impl SYSCON_clkoutuen_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_clkoutuen) -> SYSCON_clkoutuen_Get {
        SYSCON_clkoutuen_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ENA` field: Enable CLKOUT clock source update
    #[inline(always)]
    pub fn ena(&self) -> SYSCON_clkoutuen_ena {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_clkoutuen_ena::NoChange),
            1 => ::core::option::Option::Some(SYSCON_clkoutuen_ena::UpdateClockSource),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_clkoutuen_Get { }


// Updater for SYSCON_clkoutuen
/// Updater for `CLKOUTUEN` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_clkoutuen_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_clkoutuen,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_clkoutuen_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_clkoutuen_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_clkoutuen) -> SYSCON_clkoutuen_Update<'a> {
        SYSCON_clkoutuen_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_clkoutuen) -> SYSCON_clkoutuen_Update<'a> {
        SYSCON_clkoutuen_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ENA` field.
    #[inline(always)]
    pub fn set_ena<'b>(&'b mut self, new_value: SYSCON_clkoutuen_ena) -> &'b mut SYSCON_clkoutuen_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_clkoutuen_ena {
    /// No change
    NoChange = 0,
    /// Update clock source
    UpdateClockSource = 1,
    }







// Register CLKOUTCLKDIV implementation


/// Register `CLKOUTCLKDIV`: CLKOUT clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_clkoutclkdiv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_clkoutclkdiv { }

impl SYSCON_clkoutclkdiv {
    
    // Getters
    /// Fetch the value of the `CLKOUTCLKDIV` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_clkoutclkdiv_Get {
        SYSCON_clkoutclkdiv_Get::new(self)
    }

    
    /// Get value of `DIV` field.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        SYSCON_clkoutclkdiv_Get::new(self).div()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CLKOUTCLKDIV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_clkoutclkdiv_Update {
        SYSCON_clkoutclkdiv_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'a>(&'a mut self, new_value: u32) -> SYSCON_clkoutclkdiv_Update<'a> {
        let mut setter: SYSCON_clkoutclkdiv_Update = SYSCON_clkoutclkdiv_Update::new(self);
        setter.set_div(new_value);
        setter
    }
    

    }


// Getter for SYSCON_clkoutclkdiv
/// `CLKOUTCLKDIV`: CLKOUT clock divider
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_clkoutclkdiv_Get {
    value: u32,
}

impl SYSCON_clkoutclkdiv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_clkoutclkdiv) -> SYSCON_clkoutclkdiv_Get {
        SYSCON_clkoutclkdiv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DIV` field: Clock output divider values 0: Disable CLKOUT.  1: Divide by 1. to 255: Divide by 255.
    #[inline(always)]
    pub fn div(&self) -> u32 {
        (self.value >> 0) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_clkoutclkdiv_Get { }


// Updater for SYSCON_clkoutclkdiv
/// Updater for `CLKOUTCLKDIV` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_clkoutclkdiv_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_clkoutclkdiv,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_clkoutclkdiv_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_clkoutclkdiv_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_clkoutclkdiv) -> SYSCON_clkoutclkdiv_Update<'a> {
        SYSCON_clkoutclkdiv_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_clkoutclkdiv) -> SYSCON_clkoutclkdiv_Update<'a> {
        SYSCON_clkoutclkdiv_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DIV` field.
    #[inline(always)]
    pub fn set_div<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_clkoutclkdiv_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register PIOPORCAP0 implementation


/// Register `PIOPORCAP0`: POR captured PIO status 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_pioporcap0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_pioporcap0 { }

impl SYSCON_pioporcap0 {
    
    // Getters
    /// Fetch the value of the `PIOPORCAP0` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_pioporcap0_Get {
        SYSCON_pioporcap0_Get::new(self)
    }

    
    /// Get value of `CAPPIO0_n` field.
    #[inline(always)]
    pub fn cappio0_n(&self) -> u32 {
        SYSCON_pioporcap0_Get::new(self).cappio0_n()
    }
    
    /// Get value of `CAPPIO1_n` field.
    #[inline(always)]
    pub fn cappio1_n(&self) -> u32 {
        SYSCON_pioporcap0_Get::new(self).cappio1_n()
    }
    
    /// Get value of `CAPPIO2_n` field.
    #[inline(always)]
    pub fn cappio2_n(&self) -> u32 {
        SYSCON_pioporcap0_Get::new(self).cappio2_n()
    }
    

    }


// Getter for SYSCON_pioporcap0
/// `PIOPORCAP0`: POR captured PIO status 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_pioporcap0_Get {
    value: u32,
}

impl SYSCON_pioporcap0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_pioporcap0) -> SYSCON_pioporcap0_Get {
        SYSCON_pioporcap0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAPPIO0_n` field: Raw reset status input PIO0_n: PIO0_11 to PIO0_0
    #[inline(always)]
    pub fn cappio0_n(&self) -> u32 {
        (self.value >> 0) & 4095
        }
    /// Get value of `CAPPIO1_n` field: Raw reset status input PIO1_n: PIO1_11 to PIO1_0
    #[inline(always)]
    pub fn cappio1_n(&self) -> u32 {
        (self.value >> 12) & 4095
        }
    /// Get value of `CAPPIO2_n` field: Raw reset status input PIO2_n: PIO2_7 to PIO2_0
    #[inline(always)]
    pub fn cappio2_n(&self) -> u32 {
        (self.value >> 24) & 255
        }
    }

impl ::core::marker::Copy for SYSCON_pioporcap0_Get { }







// Register PIOPORCAP1 implementation


/// Register `PIOPORCAP1`: POR captured PIO status 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_pioporcap1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_pioporcap1 { }

impl SYSCON_pioporcap1 {
    
    // Getters
    /// Fetch the value of the `PIOPORCAP1` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_pioporcap1_Get {
        SYSCON_pioporcap1_Get::new(self)
    }

    
    /// Get value of `CAPPIO2_8` field.
    #[inline(always)]
    pub fn cappio2_8(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio2_8()
    }
    
    /// Get value of `CAPPIO2_9` field.
    #[inline(always)]
    pub fn cappio2_9(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio2_9()
    }
    
    /// Get value of `CAPPIO2_10` field.
    #[inline(always)]
    pub fn cappio2_10(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio2_10()
    }
    
    /// Get value of `CAPPIO2_11` field.
    #[inline(always)]
    pub fn cappio2_11(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio2_11()
    }
    
    /// Get value of `CAPPIO3_0` field.
    #[inline(always)]
    pub fn cappio3_0(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio3_0()
    }
    
    /// Get value of `CAPPIO3_1` field.
    #[inline(always)]
    pub fn cappio3_1(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio3_1()
    }
    
    /// Get value of `CAPPIO3_2` field.
    #[inline(always)]
    pub fn cappio3_2(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio3_2()
    }
    
    /// Get value of `CAPPIO3_3` field.
    #[inline(always)]
    pub fn cappio3_3(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio3_3()
    }
    
    /// Get value of `CAPPIO3_4` field.
    #[inline(always)]
    pub fn cappio3_4(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio3_4()
    }
    
    /// Get value of `CAPPIO3_5` field.
    #[inline(always)]
    pub fn cappio3_5(&self) -> bool {
        SYSCON_pioporcap1_Get::new(self).cappio3_5()
    }
    

    }


// Getter for SYSCON_pioporcap1
/// `PIOPORCAP1`: POR captured PIO status 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_pioporcap1_Get {
    value: u32,
}

impl SYSCON_pioporcap1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_pioporcap1) -> SYSCON_pioporcap1_Get {
        SYSCON_pioporcap1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAPPIO2_8` field: Raw reset status input PIO2_8
    #[inline(always)]
    pub fn cappio2_8(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `CAPPIO2_9` field: Raw reset status input PIO2_9
    #[inline(always)]
    pub fn cappio2_9(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `CAPPIO2_10` field: Raw reset status input PIO2_10
    #[inline(always)]
    pub fn cappio2_10(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `CAPPIO2_11` field: Raw reset status input PIO2_11
    #[inline(always)]
    pub fn cappio2_11(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `CAPPIO3_0` field: Raw reset status input PIO3_0
    #[inline(always)]
    pub fn cappio3_0(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `CAPPIO3_1` field: Raw reset status input PIO3_1
    #[inline(always)]
    pub fn cappio3_1(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `CAPPIO3_2` field: Raw reset status input PIO3_2
    #[inline(always)]
    pub fn cappio3_2(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `CAPPIO3_3` field: Raw reset status input PIO3_3
    #[inline(always)]
    pub fn cappio3_3(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `CAPPIO3_4` field: Raw reset status input PIO3_4
    #[inline(always)]
    pub fn cappio3_4(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `CAPPIO3_5` field: Raw reset status input PIO3_5
    #[inline(always)]
    pub fn cappio3_5(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    }

impl ::core::marker::Copy for SYSCON_pioporcap1_Get { }







// Register BODCTRL implementation


/// Register `BODCTRL`: BOD control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_bodctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_bodctrl { }

impl SYSCON_bodctrl {
    
    // Getters
    /// Fetch the value of the `BODCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_bodctrl_Get {
        SYSCON_bodctrl_Get::new(self)
    }

    
    /// Get value of `BODRSTLEV` field.
    #[inline(always)]
    pub fn bodrstlev(&self) -> SYSCON_bodctrl_bodrstlev {
        SYSCON_bodctrl_Get::new(self).bodrstlev()
    }
    
    /// Get value of `BODINTVAL` field.
    #[inline(always)]
    pub fn bodintval(&self) -> SYSCON_bodctrl_bodintval {
        SYSCON_bodctrl_Get::new(self).bodintval()
    }
    
    /// Get value of `BODRSTENA` field.
    #[inline(always)]
    pub fn bodrstena(&self) -> SYSCON_bodctrl_bodrstena {
        SYSCON_bodctrl_Get::new(self).bodrstena()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `BODCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_bodctrl_Update {
        SYSCON_bodctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `BODRSTLEV` field.
    #[inline(always)]
    pub fn set_bodrstlev<'a>(&'a mut self, new_value: SYSCON_bodctrl_bodrstlev) -> SYSCON_bodctrl_Update<'a> {
        let mut setter: SYSCON_bodctrl_Update = SYSCON_bodctrl_Update::new(self);
        setter.set_bodrstlev(new_value);
        setter
    }
    
    /// Set value of `BODINTVAL` field.
    #[inline(always)]
    pub fn set_bodintval<'a>(&'a mut self, new_value: SYSCON_bodctrl_bodintval) -> SYSCON_bodctrl_Update<'a> {
        let mut setter: SYSCON_bodctrl_Update = SYSCON_bodctrl_Update::new(self);
        setter.set_bodintval(new_value);
        setter
    }
    
    /// Set value of `BODRSTENA` field.
    #[inline(always)]
    pub fn set_bodrstena<'a>(&'a mut self, new_value: SYSCON_bodctrl_bodrstena) -> SYSCON_bodctrl_Update<'a> {
        let mut setter: SYSCON_bodctrl_Update = SYSCON_bodctrl_Update::new(self);
        setter.set_bodrstena(new_value);
        setter
    }
    

    }


// Getter for SYSCON_bodctrl
/// `BODCTRL`: BOD control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_bodctrl_Get {
    value: u32,
}

impl SYSCON_bodctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_bodctrl) -> SYSCON_bodctrl_Get {
        SYSCON_bodctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `BODRSTLEV` field: BOD reset level
    #[inline(always)]
    pub fn bodrstlev(&self) -> SYSCON_bodctrl_bodrstlev {
        match (self.value >> 0) & 3 {
            0 => ::core::option::Option::Some(SYSCON_bodctrl_bodrstlev::Level0),
            1 => ::core::option::Option::Some(SYSCON_bodctrl_bodrstlev::Level1),
            2 => ::core::option::Option::Some(SYSCON_bodctrl_bodrstlev::Level2),
            3 => ::core::option::Option::Some(SYSCON_bodctrl_bodrstlev::Level3),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BODINTVAL` field: BOD interrupt level
    #[inline(always)]
    pub fn bodintval(&self) -> SYSCON_bodctrl_bodintval {
        match (self.value >> 2) & 3 {
            0 => ::core::option::Option::Some(SYSCON_bodctrl_bodintval::Level0),
            1 => ::core::option::Option::Some(SYSCON_bodctrl_bodintval::Level1),
            2 => ::core::option::Option::Some(SYSCON_bodctrl_bodintval::Level2),
            3 => ::core::option::Option::Some(SYSCON_bodctrl_bodintval::Level3),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BODRSTENA` field: BOD reset enable
    #[inline(always)]
    pub fn bodrstena(&self) -> SYSCON_bodctrl_bodrstena {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(SYSCON_bodctrl_bodrstena::Disabled),
            1 => ::core::option::Option::Some(SYSCON_bodctrl_bodrstena::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for SYSCON_bodctrl_Get { }


// Updater for SYSCON_bodctrl
/// Updater for `BODCTRL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_bodctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_bodctrl,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_bodctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_bodctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_bodctrl) -> SYSCON_bodctrl_Update<'a> {
        SYSCON_bodctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_bodctrl) -> SYSCON_bodctrl_Update<'a> {
        SYSCON_bodctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `BODRSTLEV` field.
    #[inline(always)]
    pub fn set_bodrstlev<'b>(&'b mut self, new_value: SYSCON_bodctrl_bodrstlev) -> &'b mut SYSCON_bodctrl_Update<'a> {
        self.value = (self.value & !(3 << 0))
                   | ((new_value as u32) & 3) << 0;
        self.mask |= 3 << 0;
        self
    }
    /// Set value of `BODINTVAL` field.
    #[inline(always)]
    pub fn set_bodintval<'b>(&'b mut self, new_value: SYSCON_bodctrl_bodintval) -> &'b mut SYSCON_bodctrl_Update<'a> {
        self.value = (self.value & !(3 << 2))
                   | ((new_value as u32) & 3) << 2;
        self.mask |= 3 << 2;
        self
    }
    /// Set value of `BODRSTENA` field.
    #[inline(always)]
    pub fn set_bodrstena<'b>(&'b mut self, new_value: SYSCON_bodctrl_bodrstena) -> &'b mut SYSCON_bodctrl_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_bodctrl_bodrstlev {
    /// Level 0: The reset assertion threshold voltage is 1.46 V; the reset de-assertion threshold voltage is 1.63 V.
    Level0 = 0,
    /// Level 1: The reset assertion threshold voltage is 2.06 V; the reset de-assertion threshold voltage is 2.15 V.
    Level1 = 1,
    /// Level 2: The reset assertion threshold voltage is 2.35 V; the reset de-assertion threshold voltage is 2.43 V.
    Level2 = 2,
    /// Level 3: The reset assertion threshold voltage is 2.63 V; the reset de-assertion threshold voltage is 2.71 V.
    Level3 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_bodctrl_bodintval {
    /// Level 0: The interrupt assertion threshold voltage is 1.65 V; the interrupt de-assertion threshold voltage is 1.80 V.
    Level0 = 0,
    /// Level 1:The interrupt assertion threshold voltage is 2.22 V; the interrupt de-assertion threshold voltage is 2.35 V.
    Level1 = 1,
    /// Level 2: The interrupt assertion threshold voltage is 2.52 V; the interrupt de-assertion threshold voltage is 2.66 V.
    Level2 = 2,
    /// Level 3: The interrupt assertion threshold voltage is 2.80 V; the interrupt de-assertion threshold voltage is 2.90 V.
    Level3 = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_bodctrl_bodrstena {
    /// Disable reset function.
    Disabled = 0,
    /// Enable reset function.
    Enabled = 1,
    }







// Register SYSTCKCAL implementation


/// Register `SYSTCKCAL`: System tick counter calibration
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_systckcal {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_systckcal { }

impl SYSCON_systckcal {
    
    // Getters
    /// Fetch the value of the `SYSTCKCAL` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_systckcal_Get {
        SYSCON_systckcal_Get::new(self)
    }

    
    /// Get value of `CAL` field.
    #[inline(always)]
    pub fn cal(&self) -> u32 {
        SYSCON_systckcal_Get::new(self).cal()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `SYSTCKCAL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_systckcal_Update {
        SYSCON_systckcal_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CAL` field.
    #[inline(always)]
    pub fn set_cal<'a>(&'a mut self, new_value: u32) -> SYSCON_systckcal_Update<'a> {
        let mut setter: SYSCON_systckcal_Update = SYSCON_systckcal_Update::new(self);
        setter.set_cal(new_value);
        setter
    }
    

    }


// Getter for SYSCON_systckcal
/// `SYSTCKCAL`: System tick counter calibration
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_systckcal_Get {
    value: u32,
}

impl SYSCON_systckcal_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_systckcal) -> SYSCON_systckcal_Get {
        SYSCON_systckcal_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CAL` field: System tick timer calibration value
    #[inline(always)]
    pub fn cal(&self) -> u32 {
        (self.value >> 0) & 67108863
        }
    }

impl ::core::marker::Copy for SYSCON_systckcal_Get { }


// Updater for SYSCON_systckcal
/// Updater for `SYSTCKCAL` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_systckcal_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_systckcal,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_systckcal_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_systckcal_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_systckcal) -> SYSCON_systckcal_Update<'a> {
        SYSCON_systckcal_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_systckcal) -> SYSCON_systckcal_Update<'a> {
        SYSCON_systckcal_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CAL` field.
    #[inline(always)]
    pub fn set_cal<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_systckcal_Update<'a> {
        self.value = (self.value & !(67108863 << 0))
                   | ((new_value as u32) & 67108863) << 0;
        self.mask |= 67108863 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register NMISRC implementation


/// Register `NMISRC`: NMI source selection
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_nmisrc {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_nmisrc { }

impl SYSCON_nmisrc {
    
    // Getters
    /// Fetch the value of the `NMISRC` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_nmisrc_Get {
        SYSCON_nmisrc_Get::new(self)
    }

    
    /// Get value of `IRQNO` field.
    #[inline(always)]
    pub fn irqno(&self) -> u32 {
        SYSCON_nmisrc_Get::new(self).irqno()
    }
    
    /// Get value of `NMIEN` field.
    #[inline(always)]
    pub fn nmien(&self) -> bool {
        SYSCON_nmisrc_Get::new(self).nmien()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `NMISRC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_nmisrc_Update {
        SYSCON_nmisrc_Update::new_ignoring_state(self)
    }

    
    /// Set value of `IRQNO` field.
    #[inline(always)]
    pub fn set_irqno<'a>(&'a mut self, new_value: u32) -> SYSCON_nmisrc_Update<'a> {
        let mut setter: SYSCON_nmisrc_Update = SYSCON_nmisrc_Update::new(self);
        setter.set_irqno(new_value);
        setter
    }
    
    /// Set value of `NMIEN` field.
    #[inline(always)]
    pub fn set_nmien<'a>(&'a mut self, new_value: bool) -> SYSCON_nmisrc_Update<'a> {
        let mut setter: SYSCON_nmisrc_Update = SYSCON_nmisrc_Update::new(self);
        setter.set_nmien(new_value);
        setter
    }
    

    }


// Getter for SYSCON_nmisrc
/// `NMISRC`: NMI source selection
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_nmisrc_Get {
    value: u32,
}

impl SYSCON_nmisrc_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_nmisrc) -> SYSCON_nmisrc_Get {
        SYSCON_nmisrc_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `IRQNO` field: The IRQ number of the interrupt that acts as the Non-Maskable Interrupt (NMI) if bit 31 in this register is 1. See Table 54 for the list of interrupt sources and their IRQ numbers.
    #[inline(always)]
    pub fn irqno(&self) -> u32 {
        (self.value >> 0) & 31
        }
    /// Get value of `NMIEN` field: Write a 1 to this bit to enable the Non-Maskable Interrupt (NMI) source selected by bits 4:0.
    #[inline(always)]
    pub fn nmien(&self) -> bool {
        (self.value >> 31) & 1 != 0
        }
    }

impl ::core::marker::Copy for SYSCON_nmisrc_Get { }


// Updater for SYSCON_nmisrc
/// Updater for `NMISRC` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_nmisrc_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_nmisrc,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_nmisrc_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_nmisrc_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_nmisrc) -> SYSCON_nmisrc_Update<'a> {
        SYSCON_nmisrc_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_nmisrc) -> SYSCON_nmisrc_Update<'a> {
        SYSCON_nmisrc_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `IRQNO` field.
    #[inline(always)]
    pub fn set_irqno<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_nmisrc_Update<'a> {
        self.value = (self.value & !(31 << 0))
                   | ((new_value as u32) & 31) << 0;
        self.mask |= 31 << 0;
        self
    }
    /// Set value of `NMIEN` field.
    #[inline(always)]
    pub fn set_nmien<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_nmisrc_Update<'a> {
        self.value = (self.value & !(1 << 31))
                   | ((new_value as u32) & 1) << 31;
        self.mask |= 1 << 31;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register STARTAPRP0 implementation


/// Register `STARTAPRP0`: Start logic edge control register 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_startaprp0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_startaprp0 { }

impl SYSCON_startaprp0 {
    
    // Getters
    /// Fetch the value of the `STARTAPRP0` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_startaprp0_Get {
        SYSCON_startaprp0_Get::new(self)
    }

    
    /// Get value of `APRPIO0_0` field.
    #[inline(always)]
    pub fn aprpio0_0(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_0()
    }
    
    /// Get value of `APRPIO0_1` field.
    #[inline(always)]
    pub fn aprpio0_1(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_1()
    }
    
    /// Get value of `APRPIO0_2` field.
    #[inline(always)]
    pub fn aprpio0_2(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_2()
    }
    
    /// Get value of `APRPIO0_3` field.
    #[inline(always)]
    pub fn aprpio0_3(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_3()
    }
    
    /// Get value of `APRPIO0_4` field.
    #[inline(always)]
    pub fn aprpio0_4(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_4()
    }
    
    /// Get value of `APRPIO0_5` field.
    #[inline(always)]
    pub fn aprpio0_5(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_5()
    }
    
    /// Get value of `APRPIO0_6` field.
    #[inline(always)]
    pub fn aprpio0_6(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_6()
    }
    
    /// Get value of `APRPIO0_7` field.
    #[inline(always)]
    pub fn aprpio0_7(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_7()
    }
    
    /// Get value of `APRPIO0_8` field.
    #[inline(always)]
    pub fn aprpio0_8(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_8()
    }
    
    /// Get value of `APRPIO0_9` field.
    #[inline(always)]
    pub fn aprpio0_9(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_9()
    }
    
    /// Get value of `APRPIO0_10` field.
    #[inline(always)]
    pub fn aprpio0_10(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_10()
    }
    
    /// Get value of `APRPIO0_11` field.
    #[inline(always)]
    pub fn aprpio0_11(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio0_11()
    }
    
    /// Get value of `APRPIO1_0` field.
    #[inline(always)]
    pub fn aprpio1_0(&self) -> bool {
        SYSCON_startaprp0_Get::new(self).aprpio1_0()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `STARTAPRP0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_startaprp0_Update {
        SYSCON_startaprp0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `APRPIO0_0` field.
    #[inline(always)]
    pub fn set_aprpio0_0<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_0(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_1` field.
    #[inline(always)]
    pub fn set_aprpio0_1<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_1(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_2` field.
    #[inline(always)]
    pub fn set_aprpio0_2<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_2(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_3` field.
    #[inline(always)]
    pub fn set_aprpio0_3<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_3(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_4` field.
    #[inline(always)]
    pub fn set_aprpio0_4<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_4(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_5` field.
    #[inline(always)]
    pub fn set_aprpio0_5<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_5(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_6` field.
    #[inline(always)]
    pub fn set_aprpio0_6<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_6(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_7` field.
    #[inline(always)]
    pub fn set_aprpio0_7<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_7(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_8` field.
    #[inline(always)]
    pub fn set_aprpio0_8<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_8(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_9` field.
    #[inline(always)]
    pub fn set_aprpio0_9<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_9(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_10` field.
    #[inline(always)]
    pub fn set_aprpio0_10<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_10(new_value);
        setter
    }
    
    /// Set value of `APRPIO0_11` field.
    #[inline(always)]
    pub fn set_aprpio0_11<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio0_11(new_value);
        setter
    }
    
    /// Set value of `APRPIO1_0` field.
    #[inline(always)]
    pub fn set_aprpio1_0<'a>(&'a mut self, new_value: bool) -> SYSCON_startaprp0_Update<'a> {
        let mut setter: SYSCON_startaprp0_Update = SYSCON_startaprp0_Update::new(self);
        setter.set_aprpio1_0(new_value);
        setter
    }
    

    }


// Getter for SYSCON_startaprp0
/// `STARTAPRP0`: Start logic edge control register 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_startaprp0_Get {
    value: u32,
}

impl SYSCON_startaprp0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_startaprp0) -> SYSCON_startaprp0_Get {
        SYSCON_startaprp0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `APRPIO0_0` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `APRPIO0_1` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `APRPIO0_2` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `APRPIO0_3` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `APRPIO0_4` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `APRPIO0_5` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `APRPIO0_6` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `APRPIO0_7` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `APRPIO0_8` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `APRPIO0_9` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `APRPIO0_10` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `APRPIO0_11` field: Edge select for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio0_11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    /// Get value of `APRPIO1_0` field: Edge select for start logic input PIO1_0 0 = Falling edge 1 = Rising edge
    #[inline(always)]
    pub fn aprpio1_0(&self) -> bool {
        (self.value >> 12) & 1 != 0
        }
    }

impl ::core::marker::Copy for SYSCON_startaprp0_Get { }


// Updater for SYSCON_startaprp0
/// Updater for `STARTAPRP0` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_startaprp0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_startaprp0,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_startaprp0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_startaprp0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_startaprp0) -> SYSCON_startaprp0_Update<'a> {
        SYSCON_startaprp0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_startaprp0) -> SYSCON_startaprp0_Update<'a> {
        SYSCON_startaprp0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `APRPIO0_0` field.
    #[inline(always)]
    pub fn set_aprpio0_0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `APRPIO0_1` field.
    #[inline(always)]
    pub fn set_aprpio0_1<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `APRPIO0_2` field.
    #[inline(always)]
    pub fn set_aprpio0_2<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `APRPIO0_3` field.
    #[inline(always)]
    pub fn set_aprpio0_3<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `APRPIO0_4` field.
    #[inline(always)]
    pub fn set_aprpio0_4<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `APRPIO0_5` field.
    #[inline(always)]
    pub fn set_aprpio0_5<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `APRPIO0_6` field.
    #[inline(always)]
    pub fn set_aprpio0_6<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `APRPIO0_7` field.
    #[inline(always)]
    pub fn set_aprpio0_7<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `APRPIO0_8` field.
    #[inline(always)]
    pub fn set_aprpio0_8<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `APRPIO0_9` field.
    #[inline(always)]
    pub fn set_aprpio0_9<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `APRPIO0_10` field.
    #[inline(always)]
    pub fn set_aprpio0_10<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `APRPIO0_11` field.
    #[inline(always)]
    pub fn set_aprpio0_11<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `APRPIO1_0` field.
    #[inline(always)]
    pub fn set_aprpio1_0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startaprp0_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register STARTERP0 implementation


/// Register `STARTERP0`: Start logic signal enable register 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_starterp0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_starterp0 { }

impl SYSCON_starterp0 {
    
    // Getters
    /// Fetch the value of the `STARTERP0` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_starterp0_Get {
        SYSCON_starterp0_Get::new(self)
    }

    
    /// Get value of `ERPIO0_0` field.
    #[inline(always)]
    pub fn erpio0_0(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_0()
    }
    
    /// Get value of `ERPIO0_1` field.
    #[inline(always)]
    pub fn erpio0_1(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_1()
    }
    
    /// Get value of `ERPIO0_2` field.
    #[inline(always)]
    pub fn erpio0_2(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_2()
    }
    
    /// Get value of `ERPIO0_3` field.
    #[inline(always)]
    pub fn erpio0_3(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_3()
    }
    
    /// Get value of `ERPIO0_4` field.
    #[inline(always)]
    pub fn erpio0_4(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_4()
    }
    
    /// Get value of `ERPIO0_5` field.
    #[inline(always)]
    pub fn erpio0_5(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_5()
    }
    
    /// Get value of `ERPIO0_6` field.
    #[inline(always)]
    pub fn erpio0_6(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_6()
    }
    
    /// Get value of `ERPIO0_7` field.
    #[inline(always)]
    pub fn erpio0_7(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_7()
    }
    
    /// Get value of `ERPIO0_8` field.
    #[inline(always)]
    pub fn erpio0_8(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_8()
    }
    
    /// Get value of `ERPIO0_9` field.
    #[inline(always)]
    pub fn erpio0_9(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_9()
    }
    
    /// Get value of `ERPIO0_10` field.
    #[inline(always)]
    pub fn erpio0_10(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_10()
    }
    
    /// Get value of `ERPIO0_11` field.
    #[inline(always)]
    pub fn erpio0_11(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio0_11()
    }
    
    /// Get value of `ERPIO1_0` field.
    #[inline(always)]
    pub fn erpio1_0(&self) -> bool {
        SYSCON_starterp0_Get::new(self).erpio1_0()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `STARTERP0` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_starterp0_Update {
        SYSCON_starterp0_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ERPIO0_0` field.
    #[inline(always)]
    pub fn set_erpio0_0<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_0(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_1` field.
    #[inline(always)]
    pub fn set_erpio0_1<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_1(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_2` field.
    #[inline(always)]
    pub fn set_erpio0_2<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_2(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_3` field.
    #[inline(always)]
    pub fn set_erpio0_3<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_3(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_4` field.
    #[inline(always)]
    pub fn set_erpio0_4<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_4(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_5` field.
    #[inline(always)]
    pub fn set_erpio0_5<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_5(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_6` field.
    #[inline(always)]
    pub fn set_erpio0_6<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_6(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_7` field.
    #[inline(always)]
    pub fn set_erpio0_7<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_7(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_8` field.
    #[inline(always)]
    pub fn set_erpio0_8<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_8(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_9` field.
    #[inline(always)]
    pub fn set_erpio0_9<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_9(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_10` field.
    #[inline(always)]
    pub fn set_erpio0_10<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_10(new_value);
        setter
    }
    
    /// Set value of `ERPIO0_11` field.
    #[inline(always)]
    pub fn set_erpio0_11<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio0_11(new_value);
        setter
    }
    
    /// Set value of `ERPIO1_0` field.
    #[inline(always)]
    pub fn set_erpio1_0<'a>(&'a mut self, new_value: bool) -> SYSCON_starterp0_Update<'a> {
        let mut setter: SYSCON_starterp0_Update = SYSCON_starterp0_Update::new(self);
        setter.set_erpio1_0(new_value);
        setter
    }
    

    }


// Getter for SYSCON_starterp0
/// `STARTERP0`: Start logic signal enable register 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_starterp0_Get {
    value: u32,
}

impl SYSCON_starterp0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_starterp0) -> SYSCON_starterp0_Get {
        SYSCON_starterp0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ERPIO0_0` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `ERPIO0_1` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `ERPIO0_2` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `ERPIO0_3` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `ERPIO0_4` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `ERPIO0_5` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `ERPIO0_6` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `ERPIO0_7` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `ERPIO0_8` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `ERPIO0_9` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `ERPIO0_10` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `ERPIO0_11` field: Enable start signal for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio0_11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    /// Get value of `ERPIO1_0` field: Enable start signal for start logic input PIO1_0 0 = Disabled 1 = Enabled
    #[inline(always)]
    pub fn erpio1_0(&self) -> bool {
        (self.value >> 12) & 1 != 0
        }
    }

impl ::core::marker::Copy for SYSCON_starterp0_Get { }


// Updater for SYSCON_starterp0
/// Updater for `STARTERP0` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_starterp0_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_starterp0,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_starterp0_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_starterp0_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_starterp0) -> SYSCON_starterp0_Update<'a> {
        SYSCON_starterp0_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_starterp0) -> SYSCON_starterp0_Update<'a> {
        SYSCON_starterp0_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ERPIO0_0` field.
    #[inline(always)]
    pub fn set_erpio0_0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `ERPIO0_1` field.
    #[inline(always)]
    pub fn set_erpio0_1<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `ERPIO0_2` field.
    #[inline(always)]
    pub fn set_erpio0_2<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `ERPIO0_3` field.
    #[inline(always)]
    pub fn set_erpio0_3<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `ERPIO0_4` field.
    #[inline(always)]
    pub fn set_erpio0_4<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `ERPIO0_5` field.
    #[inline(always)]
    pub fn set_erpio0_5<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ERPIO0_6` field.
    #[inline(always)]
    pub fn set_erpio0_6<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `ERPIO0_7` field.
    #[inline(always)]
    pub fn set_erpio0_7<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `ERPIO0_8` field.
    #[inline(always)]
    pub fn set_erpio0_8<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `ERPIO0_9` field.
    #[inline(always)]
    pub fn set_erpio0_9<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `ERPIO0_10` field.
    #[inline(always)]
    pub fn set_erpio0_10<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `ERPIO0_11` field.
    #[inline(always)]
    pub fn set_erpio0_11<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `ERPIO1_0` field.
    #[inline(always)]
    pub fn set_erpio1_0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_starterp0_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register STARTRSRP0CLR implementation


/// Register `STARTRSRP0CLR`: Start logic reset register 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_startrsrp0clr {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_startrsrp0clr { }

impl SYSCON_startrsrp0clr {
    
    // Setters
    /// Create new updater that ignores current value of the `STARTRSRP0CLR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_startrsrp0clr_Update {
        SYSCON_startrsrp0clr_Update::new_ignoring_state(self)
    }

    
    /// Set value of `RSRPIO0_0` field.
    #[inline(always)]
    pub fn set_rsrpio0_0<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_0(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_1` field.
    #[inline(always)]
    pub fn set_rsrpio0_1<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_1(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_2` field.
    #[inline(always)]
    pub fn set_rsrpio0_2<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_2(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_3` field.
    #[inline(always)]
    pub fn set_rsrpio0_3<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_3(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_4` field.
    #[inline(always)]
    pub fn set_rsrpio0_4<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_4(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_5` field.
    #[inline(always)]
    pub fn set_rsrpio0_5<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_5(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_6` field.
    #[inline(always)]
    pub fn set_rsrpio0_6<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_6(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_7` field.
    #[inline(always)]
    pub fn set_rsrpio0_7<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_7(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_8` field.
    #[inline(always)]
    pub fn set_rsrpio0_8<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_8(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_9` field.
    #[inline(always)]
    pub fn set_rsrpio0_9<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_9(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_10` field.
    #[inline(always)]
    pub fn set_rsrpio0_10<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_10(new_value);
        setter
    }
    
    /// Set value of `RSRPIO0_11` field.
    #[inline(always)]
    pub fn set_rsrpio0_11<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio0_11(new_value);
        setter
    }
    
    /// Set value of `RSRPIO1_0` field.
    #[inline(always)]
    pub fn set_rsrpio1_0<'a>(&'a mut self, new_value: bool) -> SYSCON_startrsrp0clr_Update<'a> {
        let mut setter: SYSCON_startrsrp0clr_Update = SYSCON_startrsrp0clr_Update::new(self);
        setter.set_rsrpio1_0(new_value);
        setter
    }
    

    }


// Updater for SYSCON_startrsrp0clr
/// Updater for `STARTRSRP0CLR` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_startrsrp0clr_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_startrsrp0clr,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_startrsrp0clr_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_startrsrp0clr_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_startrsrp0clr) -> SYSCON_startrsrp0clr_Update<'a> {
        SYSCON_startrsrp0clr_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_startrsrp0clr) -> SYSCON_startrsrp0clr_Update<'a> {
        SYSCON_startrsrp0clr_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `RSRPIO0_0` field.
    #[inline(always)]
    pub fn set_rsrpio0_0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `RSRPIO0_1` field.
    #[inline(always)]
    pub fn set_rsrpio0_1<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `RSRPIO0_2` field.
    #[inline(always)]
    pub fn set_rsrpio0_2<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `RSRPIO0_3` field.
    #[inline(always)]
    pub fn set_rsrpio0_3<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `RSRPIO0_4` field.
    #[inline(always)]
    pub fn set_rsrpio0_4<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `RSRPIO0_5` field.
    #[inline(always)]
    pub fn set_rsrpio0_5<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `RSRPIO0_6` field.
    #[inline(always)]
    pub fn set_rsrpio0_6<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `RSRPIO0_7` field.
    #[inline(always)]
    pub fn set_rsrpio0_7<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `RSRPIO0_8` field.
    #[inline(always)]
    pub fn set_rsrpio0_8<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `RSRPIO0_9` field.
    #[inline(always)]
    pub fn set_rsrpio0_9<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `RSRPIO0_10` field.
    #[inline(always)]
    pub fn set_rsrpio0_10<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `RSRPIO0_11` field.
    #[inline(always)]
    pub fn set_rsrpio0_11<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `RSRPIO1_0` field.
    #[inline(always)]
    pub fn set_rsrpio1_0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_startrsrp0clr_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register STARTSRP0 implementation


/// Register `STARTSRP0`: Start logic status register 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_startsrp0 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_startsrp0 { }

impl SYSCON_startsrp0 {
    
    // Getters
    /// Fetch the value of the `STARTSRP0` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_startsrp0_Get {
        SYSCON_startsrp0_Get::new(self)
    }

    
    /// Get value of `SRPIO0_0` field.
    #[inline(always)]
    pub fn srpio0_0(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_0()
    }
    
    /// Get value of `SRPIO0_1` field.
    #[inline(always)]
    pub fn srpio0_1(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_1()
    }
    
    /// Get value of `SRPIO0_2` field.
    #[inline(always)]
    pub fn srpio0_2(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_2()
    }
    
    /// Get value of `SRPIO0_3` field.
    #[inline(always)]
    pub fn srpio0_3(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_3()
    }
    
    /// Get value of `SRPIO0_4` field.
    #[inline(always)]
    pub fn srpio0_4(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_4()
    }
    
    /// Get value of `SRPIO0_5` field.
    #[inline(always)]
    pub fn srpio0_5(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_5()
    }
    
    /// Get value of `SRPIO0_6` field.
    #[inline(always)]
    pub fn srpio0_6(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_6()
    }
    
    /// Get value of `SRPIO0_7` field.
    #[inline(always)]
    pub fn srpio0_7(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_7()
    }
    
    /// Get value of `SRPIO0_8` field.
    #[inline(always)]
    pub fn srpio0_8(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_8()
    }
    
    /// Get value of `SRPIO0_9` field.
    #[inline(always)]
    pub fn srpio0_9(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_9()
    }
    
    /// Get value of `SRPIO0_10` field.
    #[inline(always)]
    pub fn srpio0_10(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_10()
    }
    
    /// Get value of `SRPIO0_11` field.
    #[inline(always)]
    pub fn srpio0_11(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio0_11()
    }
    
    /// Get value of `SRPIO1_0` field.
    #[inline(always)]
    pub fn srpio1_0(&self) -> bool {
        SYSCON_startsrp0_Get::new(self).srpio1_0()
    }
    

    }


// Getter for SYSCON_startsrp0
/// `STARTSRP0`: Start logic status register 0
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_startsrp0_Get {
    value: u32,
}

impl SYSCON_startsrp0_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_startsrp0) -> SYSCON_startsrp0_Get {
        SYSCON_startsrp0_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `SRPIO0_0` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `SRPIO0_1` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `SRPIO0_2` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `SRPIO0_3` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `SRPIO0_4` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `SRPIO0_5` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `SRPIO0_6` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `SRPIO0_7` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `SRPIO0_8` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `SRPIO0_9` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `SRPIO0_10` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `SRPIO0_11` field: Start signal status for start logic input PIO0_n: PIO0_11 to PIO0_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio0_11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    /// Get value of `SRPIO1_0` field: Start signal status for start logic input PIO1_0 0 = No start signal received. 1 = Start signal pending.
    #[inline(always)]
    pub fn srpio1_0(&self) -> bool {
        (self.value >> 12) & 1 != 0
        }
    }

impl ::core::marker::Copy for SYSCON_startsrp0_Get { }







// Register PDSLEEPCFG implementation


/// Register `PDSLEEPCFG`: Power-down states in Deep-sleep mode
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_pdsleepcfg {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_pdsleepcfg { }

impl SYSCON_pdsleepcfg {
    
    // Getters
    /// Fetch the value of the `PDSLEEPCFG` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_pdsleepcfg_Get {
        SYSCON_pdsleepcfg_Get::new(self)
    }

    
    /// Get value of `NOTUSED0` field.
    #[inline(always)]
    pub fn notused0(&self) -> u32 {
        SYSCON_pdsleepcfg_Get::new(self).notused0()
    }
    
    /// Get value of `BOD_PD` field.
    #[inline(always)]
    pub fn bod_pd(&self) -> SYSCON_pdsleepcfg_bod_pd {
        SYSCON_pdsleepcfg_Get::new(self).bod_pd()
    }
    
    /// Get value of `NOTUSED1` field.
    #[inline(always)]
    pub fn notused1(&self) -> u32 {
        SYSCON_pdsleepcfg_Get::new(self).notused1()
    }
    
    /// Get value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn wdtosc_pd(&self) -> SYSCON_pdsleepcfg_wdtosc_pd {
        SYSCON_pdsleepcfg_Get::new(self).wdtosc_pd()
    }
    
    /// Get value of `NOTUSED2` field.
    #[inline(always)]
    pub fn notused2(&self) -> bool {
        SYSCON_pdsleepcfg_Get::new(self).notused2()
    }
    
    /// Get value of `NOTUSED3` field.
    #[inline(always)]
    pub fn notused3(&self) -> u32 {
        SYSCON_pdsleepcfg_Get::new(self).notused3()
    }
    
    /// Get value of `NOTUSED4` field.
    #[inline(always)]
    pub fn notused4(&self) -> u32 {
        SYSCON_pdsleepcfg_Get::new(self).notused4()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PDSLEEPCFG` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_pdsleepcfg_Update {
        SYSCON_pdsleepcfg_Update::new_ignoring_state(self)
    }

    
    /// Set value of `NOTUSED0` field.
    #[inline(always)]
    pub fn set_notused0<'a>(&'a mut self, new_value: u32) -> SYSCON_pdsleepcfg_Update<'a> {
        let mut setter: SYSCON_pdsleepcfg_Update = SYSCON_pdsleepcfg_Update::new(self);
        setter.set_notused0(new_value);
        setter
    }
    
    /// Set value of `BOD_PD` field.
    #[inline(always)]
    pub fn set_bod_pd<'a>(&'a mut self, new_value: SYSCON_pdsleepcfg_bod_pd) -> SYSCON_pdsleepcfg_Update<'a> {
        let mut setter: SYSCON_pdsleepcfg_Update = SYSCON_pdsleepcfg_Update::new(self);
        setter.set_bod_pd(new_value);
        setter
    }
    
    /// Set value of `NOTUSED1` field.
    #[inline(always)]
    pub fn set_notused1<'a>(&'a mut self, new_value: u32) -> SYSCON_pdsleepcfg_Update<'a> {
        let mut setter: SYSCON_pdsleepcfg_Update = SYSCON_pdsleepcfg_Update::new(self);
        setter.set_notused1(new_value);
        setter
    }
    
    /// Set value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn set_wdtosc_pd<'a>(&'a mut self, new_value: SYSCON_pdsleepcfg_wdtosc_pd) -> SYSCON_pdsleepcfg_Update<'a> {
        let mut setter: SYSCON_pdsleepcfg_Update = SYSCON_pdsleepcfg_Update::new(self);
        setter.set_wdtosc_pd(new_value);
        setter
    }
    
    /// Set value of `NOTUSED2` field.
    #[inline(always)]
    pub fn set_notused2<'a>(&'a mut self, new_value: bool) -> SYSCON_pdsleepcfg_Update<'a> {
        let mut setter: SYSCON_pdsleepcfg_Update = SYSCON_pdsleepcfg_Update::new(self);
        setter.set_notused2(new_value);
        setter
    }
    
    /// Set value of `NOTUSED3` field.
    #[inline(always)]
    pub fn set_notused3<'a>(&'a mut self, new_value: u32) -> SYSCON_pdsleepcfg_Update<'a> {
        let mut setter: SYSCON_pdsleepcfg_Update = SYSCON_pdsleepcfg_Update::new(self);
        setter.set_notused3(new_value);
        setter
    }
    
    /// Set value of `NOTUSED4` field.
    #[inline(always)]
    pub fn set_notused4<'a>(&'a mut self, new_value: u32) -> SYSCON_pdsleepcfg_Update<'a> {
        let mut setter: SYSCON_pdsleepcfg_Update = SYSCON_pdsleepcfg_Update::new(self);
        setter.set_notused4(new_value);
        setter
    }
    

    }


// Getter for SYSCON_pdsleepcfg
/// `PDSLEEPCFG`: Power-down states in Deep-sleep mode
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_pdsleepcfg_Get {
    value: u32,
}

impl SYSCON_pdsleepcfg_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_pdsleepcfg) -> SYSCON_pdsleepcfg_Get {
        SYSCON_pdsleepcfg_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `NOTUSED0` field: Reserved. Always write these bits as 111.
    #[inline(always)]
    pub fn notused0(&self) -> u32 {
        (self.value >> 0) & 7
        }
    /// Get value of `BOD_PD` field: BOD power-down control in Deep-sleep mode, see Table 40.
    #[inline(always)]
    pub fn bod_pd(&self) -> SYSCON_pdsleepcfg_bod_pd {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdsleepcfg_bod_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdsleepcfg_bod_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NOTUSED1` field: Reserved. Always write these bits as 11.
    #[inline(always)]
    pub fn notused1(&self) -> u32 {
        (self.value >> 4) & 3
        }
    /// Get value of `WDTOSC_PD` field: Watchdog oscillator power control in Deep-sleep mode, see Table 40.
    #[inline(always)]
    pub fn wdtosc_pd(&self) -> SYSCON_pdsleepcfg_wdtosc_pd {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdsleepcfg_wdtosc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdsleepcfg_wdtosc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NOTUSED2` field: Reserved. Always write this bit as 1.
    #[inline(always)]
    pub fn notused2(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `NOTUSED3` field: Reserved. Always write these bits as 000.
    #[inline(always)]
    pub fn notused3(&self) -> u32 {
        (self.value >> 8) & 7
        }
    /// Get value of `NOTUSED4` field: Reserved. Always write these bits as 11.
    #[inline(always)]
    pub fn notused4(&self) -> u32 {
        (self.value >> 11) & 3
        }
    }

impl ::core::marker::Copy for SYSCON_pdsleepcfg_Get { }


// Updater for SYSCON_pdsleepcfg
/// Updater for `PDSLEEPCFG` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_pdsleepcfg_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_pdsleepcfg,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_pdsleepcfg_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_pdsleepcfg_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_pdsleepcfg) -> SYSCON_pdsleepcfg_Update<'a> {
        SYSCON_pdsleepcfg_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_pdsleepcfg) -> SYSCON_pdsleepcfg_Update<'a> {
        SYSCON_pdsleepcfg_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `NOTUSED0` field.
    #[inline(always)]
    pub fn set_notused0<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_pdsleepcfg_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `BOD_PD` field.
    #[inline(always)]
    pub fn set_bod_pd<'b>(&'b mut self, new_value: SYSCON_pdsleepcfg_bod_pd) -> &'b mut SYSCON_pdsleepcfg_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `NOTUSED1` field.
    #[inline(always)]
    pub fn set_notused1<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_pdsleepcfg_Update<'a> {
        self.value = (self.value & !(3 << 4))
                   | ((new_value as u32) & 3) << 4;
        self.mask |= 3 << 4;
        self
    }
    /// Set value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn set_wdtosc_pd<'b>(&'b mut self, new_value: SYSCON_pdsleepcfg_wdtosc_pd) -> &'b mut SYSCON_pdsleepcfg_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `NOTUSED2` field.
    #[inline(always)]
    pub fn set_notused2<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdsleepcfg_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `NOTUSED3` field.
    #[inline(always)]
    pub fn set_notused3<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_pdsleepcfg_Update<'a> {
        self.value = (self.value & !(7 << 8))
                   | ((new_value as u32) & 7) << 8;
        self.mask |= 7 << 8;
        self
    }
    /// Set value of `NOTUSED4` field.
    #[inline(always)]
    pub fn set_notused4<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_pdsleepcfg_Update<'a> {
        self.value = (self.value & !(3 << 11))
                   | ((new_value as u32) & 3) << 11;
        self.mask |= 3 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdsleepcfg_bod_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdsleepcfg_wdtosc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }







// Register PDAWAKECFG implementation


/// Register `PDAWAKECFG`: Power-down states after wake-up from Deep-sleep mode
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_pdawakecfg {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_pdawakecfg { }

impl SYSCON_pdawakecfg {
    
    // Getters
    /// Fetch the value of the `PDAWAKECFG` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_pdawakecfg_Get {
        SYSCON_pdawakecfg_Get::new(self)
    }

    
    /// Get value of `IRCOUT_PD` field.
    #[inline(always)]
    pub fn ircout_pd(&self) -> SYSCON_pdawakecfg_ircout_pd {
        SYSCON_pdawakecfg_Get::new(self).ircout_pd()
    }
    
    /// Get value of `IRC_PD` field.
    #[inline(always)]
    pub fn irc_pd(&self) -> SYSCON_pdawakecfg_irc_pd {
        SYSCON_pdawakecfg_Get::new(self).irc_pd()
    }
    
    /// Get value of `FLASH_PD` field.
    #[inline(always)]
    pub fn flash_pd(&self) -> SYSCON_pdawakecfg_flash_pd {
        SYSCON_pdawakecfg_Get::new(self).flash_pd()
    }
    
    /// Get value of `BOD_PD` field.
    #[inline(always)]
    pub fn bod_pd(&self) -> SYSCON_pdawakecfg_bod_pd {
        SYSCON_pdawakecfg_Get::new(self).bod_pd()
    }
    
    /// Get value of `ADC_PD` field.
    #[inline(always)]
    pub fn adc_pd(&self) -> SYSCON_pdawakecfg_adc_pd {
        SYSCON_pdawakecfg_Get::new(self).adc_pd()
    }
    
    /// Get value of `SYSOSC_PD` field.
    #[inline(always)]
    pub fn sysosc_pd(&self) -> SYSCON_pdawakecfg_sysosc_pd {
        SYSCON_pdawakecfg_Get::new(self).sysosc_pd()
    }
    
    /// Get value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn wdtosc_pd(&self) -> SYSCON_pdawakecfg_wdtosc_pd {
        SYSCON_pdawakecfg_Get::new(self).wdtosc_pd()
    }
    
    /// Get value of `SYSPLL_PD` field.
    #[inline(always)]
    pub fn syspll_pd(&self) -> SYSCON_pdawakecfg_syspll_pd {
        SYSCON_pdawakecfg_Get::new(self).syspll_pd()
    }
    
    /// Get value of `NOTUSED0` field.
    #[inline(always)]
    pub fn notused0(&self) -> bool {
        SYSCON_pdawakecfg_Get::new(self).notused0()
    }
    
    /// Get value of `NOTUSED1` field.
    #[inline(always)]
    pub fn notused1(&self) -> bool {
        SYSCON_pdawakecfg_Get::new(self).notused1()
    }
    
    /// Get value of `NOTUSED2` field.
    #[inline(always)]
    pub fn notused2(&self) -> bool {
        SYSCON_pdawakecfg_Get::new(self).notused2()
    }
    
    /// Get value of `NOTUSED3` field.
    #[inline(always)]
    pub fn notused3(&self) -> bool {
        SYSCON_pdawakecfg_Get::new(self).notused3()
    }
    
    /// Get value of `NOTUSED4` field.
    #[inline(always)]
    pub fn notused4(&self) -> bool {
        SYSCON_pdawakecfg_Get::new(self).notused4()
    }
    
    /// Get value of `NOTUSED5` field.
    #[inline(always)]
    pub fn notused5(&self) -> u32 {
        SYSCON_pdawakecfg_Get::new(self).notused5()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PDAWAKECFG` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_pdawakecfg_Update {
        SYSCON_pdawakecfg_Update::new_ignoring_state(self)
    }

    
    /// Set value of `IRCOUT_PD` field.
    #[inline(always)]
    pub fn set_ircout_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_ircout_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_ircout_pd(new_value);
        setter
    }
    
    /// Set value of `IRC_PD` field.
    #[inline(always)]
    pub fn set_irc_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_irc_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_irc_pd(new_value);
        setter
    }
    
    /// Set value of `FLASH_PD` field.
    #[inline(always)]
    pub fn set_flash_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_flash_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_flash_pd(new_value);
        setter
    }
    
    /// Set value of `BOD_PD` field.
    #[inline(always)]
    pub fn set_bod_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_bod_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_bod_pd(new_value);
        setter
    }
    
    /// Set value of `ADC_PD` field.
    #[inline(always)]
    pub fn set_adc_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_adc_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_adc_pd(new_value);
        setter
    }
    
    /// Set value of `SYSOSC_PD` field.
    #[inline(always)]
    pub fn set_sysosc_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_sysosc_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_sysosc_pd(new_value);
        setter
    }
    
    /// Set value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn set_wdtosc_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_wdtosc_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_wdtosc_pd(new_value);
        setter
    }
    
    /// Set value of `SYSPLL_PD` field.
    #[inline(always)]
    pub fn set_syspll_pd<'a>(&'a mut self, new_value: SYSCON_pdawakecfg_syspll_pd) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_syspll_pd(new_value);
        setter
    }
    
    /// Set value of `NOTUSED0` field.
    #[inline(always)]
    pub fn set_notused0<'a>(&'a mut self, new_value: bool) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_notused0(new_value);
        setter
    }
    
    /// Set value of `NOTUSED1` field.
    #[inline(always)]
    pub fn set_notused1<'a>(&'a mut self, new_value: bool) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_notused1(new_value);
        setter
    }
    
    /// Set value of `NOTUSED2` field.
    #[inline(always)]
    pub fn set_notused2<'a>(&'a mut self, new_value: bool) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_notused2(new_value);
        setter
    }
    
    /// Set value of `NOTUSED3` field.
    #[inline(always)]
    pub fn set_notused3<'a>(&'a mut self, new_value: bool) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_notused3(new_value);
        setter
    }
    
    /// Set value of `NOTUSED4` field.
    #[inline(always)]
    pub fn set_notused4<'a>(&'a mut self, new_value: bool) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_notused4(new_value);
        setter
    }
    
    /// Set value of `NOTUSED5` field.
    #[inline(always)]
    pub fn set_notused5<'a>(&'a mut self, new_value: u32) -> SYSCON_pdawakecfg_Update<'a> {
        let mut setter: SYSCON_pdawakecfg_Update = SYSCON_pdawakecfg_Update::new(self);
        setter.set_notused5(new_value);
        setter
    }
    

    }


// Getter for SYSCON_pdawakecfg
/// `PDAWAKECFG`: Power-down states after wake-up from Deep-sleep mode
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_pdawakecfg_Get {
    value: u32,
}

impl SYSCON_pdawakecfg_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_pdawakecfg) -> SYSCON_pdawakecfg_Get {
        SYSCON_pdawakecfg_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `IRCOUT_PD` field: IRC oscillator output wake-up configuration
    #[inline(always)]
    pub fn ircout_pd(&self) -> SYSCON_pdawakecfg_ircout_pd {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_ircout_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_ircout_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `IRC_PD` field: IRC oscillator power-down wake-up configuration
    #[inline(always)]
    pub fn irc_pd(&self) -> SYSCON_pdawakecfg_irc_pd {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_irc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_irc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FLASH_PD` field: Flash wake-up configuration
    #[inline(always)]
    pub fn flash_pd(&self) -> SYSCON_pdawakecfg_flash_pd {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_flash_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_flash_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BOD_PD` field: BOD wake-up configuration
    #[inline(always)]
    pub fn bod_pd(&self) -> SYSCON_pdawakecfg_bod_pd {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_bod_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_bod_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADC_PD` field: ADC wake-up configuration
    #[inline(always)]
    pub fn adc_pd(&self) -> SYSCON_pdawakecfg_adc_pd {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_adc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_adc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SYSOSC_PD` field: System oscillator wake-up configuration
    #[inline(always)]
    pub fn sysosc_pd(&self) -> SYSCON_pdawakecfg_sysosc_pd {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_sysosc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_sysosc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WDTOSC_PD` field: Watchdog oscillator wake-up configuration
    #[inline(always)]
    pub fn wdtosc_pd(&self) -> SYSCON_pdawakecfg_wdtosc_pd {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_wdtosc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_wdtosc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SYSPLL_PD` field: System PLL wake-up configuration
    #[inline(always)]
    pub fn syspll_pd(&self) -> SYSCON_pdawakecfg_syspll_pd {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdawakecfg_syspll_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdawakecfg_syspll_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NOTUSED0` field: Reserved. Always write this bit as 1.
    #[inline(always)]
    pub fn notused0(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `NOTUSED1` field: Reserved. Always write this bit as 0.
    #[inline(always)]
    pub fn notused1(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `NOTUSED2` field: Reserved. Always write this bit as 1.
    #[inline(always)]
    pub fn notused2(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `NOTUSED3` field: Reserved. Always write this bit as 1.
    #[inline(always)]
    pub fn notused3(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    /// Get value of `NOTUSED4` field: Reserved. Always write this bit as 0.
    #[inline(always)]
    pub fn notused4(&self) -> bool {
        (self.value >> 12) & 1 != 0
        }
    /// Get value of `NOTUSED5` field: Reserved. Always write these bits as 111.
    #[inline(always)]
    pub fn notused5(&self) -> u32 {
        (self.value >> 13) & 7
        }
    }

impl ::core::marker::Copy for SYSCON_pdawakecfg_Get { }


// Updater for SYSCON_pdawakecfg
/// Updater for `PDAWAKECFG` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_pdawakecfg_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_pdawakecfg,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_pdawakecfg_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_pdawakecfg_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_pdawakecfg) -> SYSCON_pdawakecfg_Update<'a> {
        SYSCON_pdawakecfg_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_pdawakecfg) -> SYSCON_pdawakecfg_Update<'a> {
        SYSCON_pdawakecfg_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `IRCOUT_PD` field.
    #[inline(always)]
    pub fn set_ircout_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_ircout_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `IRC_PD` field.
    #[inline(always)]
    pub fn set_irc_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_irc_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `FLASH_PD` field.
    #[inline(always)]
    pub fn set_flash_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_flash_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `BOD_PD` field.
    #[inline(always)]
    pub fn set_bod_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_bod_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `ADC_PD` field.
    #[inline(always)]
    pub fn set_adc_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_adc_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `SYSOSC_PD` field.
    #[inline(always)]
    pub fn set_sysosc_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_sysosc_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn set_wdtosc_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_wdtosc_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `SYSPLL_PD` field.
    #[inline(always)]
    pub fn set_syspll_pd<'b>(&'b mut self, new_value: SYSCON_pdawakecfg_syspll_pd) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `NOTUSED0` field.
    #[inline(always)]
    pub fn set_notused0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `NOTUSED1` field.
    #[inline(always)]
    pub fn set_notused1<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `NOTUSED2` field.
    #[inline(always)]
    pub fn set_notused2<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `NOTUSED3` field.
    #[inline(always)]
    pub fn set_notused3<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `NOTUSED4` field.
    #[inline(always)]
    pub fn set_notused4<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Set value of `NOTUSED5` field.
    #[inline(always)]
    pub fn set_notused5<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_pdawakecfg_Update<'a> {
        self.value = (self.value & !(7 << 13))
                   | ((new_value as u32) & 7) << 13;
        self.mask |= 7 << 13;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_ircout_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_irc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_flash_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_bod_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_adc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_sysosc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_wdtosc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdawakecfg_syspll_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }







// Register PDRUNCFG implementation


/// Register `PDRUNCFG`: Power-down configuration register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_pdruncfg {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_pdruncfg { }

impl SYSCON_pdruncfg {
    
    // Getters
    /// Fetch the value of the `PDRUNCFG` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_pdruncfg_Get {
        SYSCON_pdruncfg_Get::new(self)
    }

    
    /// Get value of `IRCOUT_PD` field.
    #[inline(always)]
    pub fn ircout_pd(&self) -> SYSCON_pdruncfg_ircout_pd {
        SYSCON_pdruncfg_Get::new(self).ircout_pd()
    }
    
    /// Get value of `IRC_PD` field.
    #[inline(always)]
    pub fn irc_pd(&self) -> SYSCON_pdruncfg_irc_pd {
        SYSCON_pdruncfg_Get::new(self).irc_pd()
    }
    
    /// Get value of `FLASH_PD` field.
    #[inline(always)]
    pub fn flash_pd(&self) -> SYSCON_pdruncfg_flash_pd {
        SYSCON_pdruncfg_Get::new(self).flash_pd()
    }
    
    /// Get value of `BOD_PD` field.
    #[inline(always)]
    pub fn bod_pd(&self) -> SYSCON_pdruncfg_bod_pd {
        SYSCON_pdruncfg_Get::new(self).bod_pd()
    }
    
    /// Get value of `ADC_PD` field.
    #[inline(always)]
    pub fn adc_pd(&self) -> SYSCON_pdruncfg_adc_pd {
        SYSCON_pdruncfg_Get::new(self).adc_pd()
    }
    
    /// Get value of `SYSOSC_PD` field.
    #[inline(always)]
    pub fn sysosc_pd(&self) -> SYSCON_pdruncfg_sysosc_pd {
        SYSCON_pdruncfg_Get::new(self).sysosc_pd()
    }
    
    /// Get value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn wdtosc_pd(&self) -> SYSCON_pdruncfg_wdtosc_pd {
        SYSCON_pdruncfg_Get::new(self).wdtosc_pd()
    }
    
    /// Get value of `SYSPLL_PD` field.
    #[inline(always)]
    pub fn syspll_pd(&self) -> SYSCON_pdruncfg_syspll_pd {
        SYSCON_pdruncfg_Get::new(self).syspll_pd()
    }
    
    /// Get value of `NOTUSED0` field.
    #[inline(always)]
    pub fn notused0(&self) -> bool {
        SYSCON_pdruncfg_Get::new(self).notused0()
    }
    
    /// Get value of `NOTUSED1` field.
    #[inline(always)]
    pub fn notused1(&self) -> bool {
        SYSCON_pdruncfg_Get::new(self).notused1()
    }
    
    /// Get value of `NOTUSED2` field.
    #[inline(always)]
    pub fn notused2(&self) -> bool {
        SYSCON_pdruncfg_Get::new(self).notused2()
    }
    
    /// Get value of `NOTUSED3` field.
    #[inline(always)]
    pub fn notused3(&self) -> bool {
        SYSCON_pdruncfg_Get::new(self).notused3()
    }
    
    /// Get value of `NOTUSED4` field.
    #[inline(always)]
    pub fn notused4(&self) -> bool {
        SYSCON_pdruncfg_Get::new(self).notused4()
    }
    
    /// Get value of `NOTUSED5` field.
    #[inline(always)]
    pub fn notused5(&self) -> u32 {
        SYSCON_pdruncfg_Get::new(self).notused5()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `PDRUNCFG` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> SYSCON_pdruncfg_Update {
        SYSCON_pdruncfg_Update::new_ignoring_state(self)
    }

    
    /// Set value of `IRCOUT_PD` field.
    #[inline(always)]
    pub fn set_ircout_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_ircout_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_ircout_pd(new_value);
        setter
    }
    
    /// Set value of `IRC_PD` field.
    #[inline(always)]
    pub fn set_irc_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_irc_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_irc_pd(new_value);
        setter
    }
    
    /// Set value of `FLASH_PD` field.
    #[inline(always)]
    pub fn set_flash_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_flash_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_flash_pd(new_value);
        setter
    }
    
    /// Set value of `BOD_PD` field.
    #[inline(always)]
    pub fn set_bod_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_bod_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_bod_pd(new_value);
        setter
    }
    
    /// Set value of `ADC_PD` field.
    #[inline(always)]
    pub fn set_adc_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_adc_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_adc_pd(new_value);
        setter
    }
    
    /// Set value of `SYSOSC_PD` field.
    #[inline(always)]
    pub fn set_sysosc_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_sysosc_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_sysosc_pd(new_value);
        setter
    }
    
    /// Set value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn set_wdtosc_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_wdtosc_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_wdtosc_pd(new_value);
        setter
    }
    
    /// Set value of `SYSPLL_PD` field.
    #[inline(always)]
    pub fn set_syspll_pd<'a>(&'a mut self, new_value: SYSCON_pdruncfg_syspll_pd) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_syspll_pd(new_value);
        setter
    }
    
    /// Set value of `NOTUSED0` field.
    #[inline(always)]
    pub fn set_notused0<'a>(&'a mut self, new_value: bool) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_notused0(new_value);
        setter
    }
    
    /// Set value of `NOTUSED1` field.
    #[inline(always)]
    pub fn set_notused1<'a>(&'a mut self, new_value: bool) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_notused1(new_value);
        setter
    }
    
    /// Set value of `NOTUSED2` field.
    #[inline(always)]
    pub fn set_notused2<'a>(&'a mut self, new_value: bool) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_notused2(new_value);
        setter
    }
    
    /// Set value of `NOTUSED3` field.
    #[inline(always)]
    pub fn set_notused3<'a>(&'a mut self, new_value: bool) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_notused3(new_value);
        setter
    }
    
    /// Set value of `NOTUSED4` field.
    #[inline(always)]
    pub fn set_notused4<'a>(&'a mut self, new_value: bool) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_notused4(new_value);
        setter
    }
    
    /// Set value of `NOTUSED5` field.
    #[inline(always)]
    pub fn set_notused5<'a>(&'a mut self, new_value: u32) -> SYSCON_pdruncfg_Update<'a> {
        let mut setter: SYSCON_pdruncfg_Update = SYSCON_pdruncfg_Update::new(self);
        setter.set_notused5(new_value);
        setter
    }
    

    }


// Getter for SYSCON_pdruncfg
/// `PDRUNCFG`: Power-down configuration register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_pdruncfg_Get {
    value: u32,
}

impl SYSCON_pdruncfg_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_pdruncfg) -> SYSCON_pdruncfg_Get {
        SYSCON_pdruncfg_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `IRCOUT_PD` field: IRC oscillator output power-down
    #[inline(always)]
    pub fn ircout_pd(&self) -> SYSCON_pdruncfg_ircout_pd {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_ircout_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_ircout_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `IRC_PD` field: IRC oscillator power-down
    #[inline(always)]
    pub fn irc_pd(&self) -> SYSCON_pdruncfg_irc_pd {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_irc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_irc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `FLASH_PD` field: Flash power-down
    #[inline(always)]
    pub fn flash_pd(&self) -> SYSCON_pdruncfg_flash_pd {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_flash_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_flash_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BOD_PD` field: BOD power-down
    #[inline(always)]
    pub fn bod_pd(&self) -> SYSCON_pdruncfg_bod_pd {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_bod_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_bod_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ADC_PD` field: ADC power-down
    #[inline(always)]
    pub fn adc_pd(&self) -> SYSCON_pdruncfg_adc_pd {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_adc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_adc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SYSOSC_PD` field: System oscillator power-down
    #[inline(always)]
    pub fn sysosc_pd(&self) -> SYSCON_pdruncfg_sysosc_pd {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_sysosc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_sysosc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WDTOSC_PD` field: Watchdog oscillator power-down
    #[inline(always)]
    pub fn wdtosc_pd(&self) -> SYSCON_pdruncfg_wdtosc_pd {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_wdtosc_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_wdtosc_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SYSPLL_PD` field: System PLL power-down
    #[inline(always)]
    pub fn syspll_pd(&self) -> SYSCON_pdruncfg_syspll_pd {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(SYSCON_pdruncfg_syspll_pd::Powered),
            1 => ::core::option::Option::Some(SYSCON_pdruncfg_syspll_pd::PoweredDown),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NOTUSED0` field: Reserved. Always write this bit as 1.
    #[inline(always)]
    pub fn notused0(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `NOTUSED1` field: Reserved. Always write this bit as 0.
    #[inline(always)]
    pub fn notused1(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `NOTUSED2` field: Reserved. Always write this bit as 1.
    #[inline(always)]
    pub fn notused2(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `NOTUSED3` field: Reserved. Always write this bit as 1.
    #[inline(always)]
    pub fn notused3(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    /// Get value of `NOTUSED4` field: Reserved.  Always write this bit as 0.
    #[inline(always)]
    pub fn notused4(&self) -> bool {
        (self.value >> 12) & 1 != 0
        }
    /// Get value of `NOTUSED5` field: Reserved. Always write these bits as 111.
    #[inline(always)]
    pub fn notused5(&self) -> u32 {
        (self.value >> 13) & 7
        }
    }

impl ::core::marker::Copy for SYSCON_pdruncfg_Get { }


// Updater for SYSCON_pdruncfg
/// Updater for `PDRUNCFG` register.
#[allow(non_camel_case_types)]
pub struct SYSCON_pdruncfg_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a SYSCON_pdruncfg,
}

/// This performs the register update.
impl <'a> Drop for SYSCON_pdruncfg_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> SYSCON_pdruncfg_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a SYSCON_pdruncfg) -> SYSCON_pdruncfg_Update<'a> {
        SYSCON_pdruncfg_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a SYSCON_pdruncfg) -> SYSCON_pdruncfg_Update<'a> {
        SYSCON_pdruncfg_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `IRCOUT_PD` field.
    #[inline(always)]
    pub fn set_ircout_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_ircout_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `IRC_PD` field.
    #[inline(always)]
    pub fn set_irc_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_irc_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `FLASH_PD` field.
    #[inline(always)]
    pub fn set_flash_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_flash_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `BOD_PD` field.
    #[inline(always)]
    pub fn set_bod_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_bod_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `ADC_PD` field.
    #[inline(always)]
    pub fn set_adc_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_adc_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `SYSOSC_PD` field.
    #[inline(always)]
    pub fn set_sysosc_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_sysosc_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `WDTOSC_PD` field.
    #[inline(always)]
    pub fn set_wdtosc_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_wdtosc_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `SYSPLL_PD` field.
    #[inline(always)]
    pub fn set_syspll_pd<'b>(&'b mut self, new_value: SYSCON_pdruncfg_syspll_pd) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `NOTUSED0` field.
    #[inline(always)]
    pub fn set_notused0<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `NOTUSED1` field.
    #[inline(always)]
    pub fn set_notused1<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `NOTUSED2` field.
    #[inline(always)]
    pub fn set_notused2<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `NOTUSED3` field.
    #[inline(always)]
    pub fn set_notused3<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `NOTUSED4` field.
    #[inline(always)]
    pub fn set_notused4<'b>(&'b mut self, new_value: bool) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Set value of `NOTUSED5` field.
    #[inline(always)]
    pub fn set_notused5<'b>(&'b mut self, new_value: u32) -> &'b mut SYSCON_pdruncfg_Update<'a> {
        self.value = (self.value & !(7 << 13))
                   | ((new_value as u32) & 7) << 13;
        self.mask |= 7 << 13;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_ircout_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_irc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_flash_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_bod_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_adc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_sysosc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_wdtosc_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum SYSCON_pdruncfg_syspll_pd {
    /// Powered
    Powered = 0,
    /// Powered down
    PoweredDown = 1,
    }







// Register DEVICE_ID implementation


/// Register `DEVICE_ID`: Device ID register 0 for parts LPC1100, LPC1100C, LPC1100L.
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct SYSCON_device_id {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for SYSCON_device_id { }

impl SYSCON_device_id {
    
    // Getters
    /// Fetch the value of the `DEVICE_ID` register.
    #[inline(always)]
    pub fn get(&self) -> SYSCON_device_id_Get {
        SYSCON_device_id_Get::new(self)
    }

    
    /// Get value of `DEVICEID` field.
    #[inline(always)]
    pub fn deviceid(&self) -> u32 {
        SYSCON_device_id_Get::new(self).deviceid()
    }
    

    }


// Getter for SYSCON_device_id
/// `DEVICE_ID`: Device ID register 0 for parts LPC1100, LPC1100C, LPC1100L.
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct SYSCON_device_id_Get {
    value: u32,
}

impl SYSCON_device_id_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &SYSCON_device_id) -> SYSCON_device_id_Get {
        SYSCON_device_id_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DEVICEID` field: Part ID numbers for LPC111x/LPC11Cxx parts 0x041E 502B; 0x2516 D02B = LPC1111FHN33/101 0x2516 D02B = LPC1111FHN33/102 0x0416 502B; 0x2516 902B = LPC1111FHN33/201 0x2516 902B = LPC1111FHN33/202 0x042D 502B; 0x2524 D02B = LPC1112FHN33/101 0x2524 D02B = LPC1112FHN33/102 0x0425 502B; 0x2524 902B = LPC1112FHN33/201 0x2524 902B = LPC1112FHN33/202  0x2524 902B = LPC1112FHI33/202 0x0434 502B; 0x2532 902B = LPC1113FHN33/201 0x2532 902B = LPC1113FHN33/202 0x0434 102B; 0x2532 102B = LPC1113FHN33/301 0x2532 102B = LPC1113FHN33/302 0x0434 102B; 0x2532 102B = LPC1113FBD48/301 0x2532 102B = LPC1113FBD48/302 0x0444 502B; 0x2540 902B = LPC1114FHN33/201 0x2540 902B = LPC1114FHN33/202 0x0444 102B; 0x2540 102B = LPC1114FHN33/301 0x2540 102B = LPC1114FHN33/302  0x2540 102B = LPC1114FHI33/302 0x0444 102B; 0x2540 102B = LPC1114FBD48/301 0x2540 102B = LPC1114FBD48/302 0x2540 102B = LPC11D14FBD100/302 0x1421 102B = LPC11C12/FBD48/301 0x1440 102B = LPC11C14/FBD48/301 0x1431 102B = LPC11C22/FBD48/301 0X1430 102B = LPC11C24/FBD48/301
    #[inline(always)]
    pub fn deviceid(&self) -> u32 {
        (self.value >> 0) & 4294967295
        }
    }

impl ::core::marker::Copy for SYSCON_device_id_Get { }





// Peripheral SYSCON implementation

/// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx System configuration (SYSCON) Modification date=2/22/2012 Major revision=8 Minor revision=not available 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct SYSCON;

impl SYSCON {
    /// System memory remap
    #[inline(always)]
    pub fn sysmemremap() -> &'static mut SYSCON_sysmemremap {
        unsafe { ::core::intrinsics::transmute(0x40048000 as usize) }
    }
    /// Peripheral reset control
    #[inline(always)]
    pub fn presetctrl() -> &'static mut SYSCON_presetctrl {
        unsafe { ::core::intrinsics::transmute(0x40048004 as usize) }
    }
    /// System PLL control
    #[inline(always)]
    pub fn syspllctrl() -> &'static mut SYSCON_syspllctrl {
        unsafe { ::core::intrinsics::transmute(0x40048008 as usize) }
    }
    /// System PLL status
    #[inline(always)]
    pub fn syspllstat() -> &'static mut SYSCON_syspllstat {
        unsafe { ::core::intrinsics::transmute(0x4004800c as usize) }
    }
    /// System oscillator control
    #[inline(always)]
    pub fn sysoscctrl() -> &'static mut SYSCON_sysoscctrl {
        unsafe { ::core::intrinsics::transmute(0x40048020 as usize) }
    }
    /// Watchdog oscillator control
    #[inline(always)]
    pub fn wdtoscctrl() -> &'static mut SYSCON_wdtoscctrl {
        unsafe { ::core::intrinsics::transmute(0x40048024 as usize) }
    }
    /// IRC control
    #[inline(always)]
    pub fn ircctrl() -> &'static mut SYSCON_ircctrl {
        unsafe { ::core::intrinsics::transmute(0x40048028 as usize) }
    }
    /// System reset status register
    #[inline(always)]
    pub fn sysrststat() -> &'static mut SYSCON_sysrststat {
        unsafe { ::core::intrinsics::transmute(0x40048030 as usize) }
    }
    /// System PLL clock source select
    #[inline(always)]
    pub fn syspllclksel() -> &'static mut SYSCON_syspllclksel {
        unsafe { ::core::intrinsics::transmute(0x40048040 as usize) }
    }
    /// System PLL clock source update enable
    #[inline(always)]
    pub fn syspllclkuen() -> &'static mut SYSCON_syspllclkuen {
        unsafe { ::core::intrinsics::transmute(0x40048044 as usize) }
    }
    /// Main clock source select
    #[inline(always)]
    pub fn mainclksel() -> &'static mut SYSCON_mainclksel {
        unsafe { ::core::intrinsics::transmute(0x40048070 as usize) }
    }
    /// Main clock source update enable
    #[inline(always)]
    pub fn mainclkuen() -> &'static mut SYSCON_mainclkuen {
        unsafe { ::core::intrinsics::transmute(0x40048074 as usize) }
    }
    /// System AHB clock divider
    #[inline(always)]
    pub fn sysahbclkdiv() -> &'static mut SYSCON_sysahbclkdiv {
        unsafe { ::core::intrinsics::transmute(0x40048078 as usize) }
    }
    /// System AHB clock control
    #[inline(always)]
    pub fn sysahbclkctrl() -> &'static mut SYSCON_sysahbclkctrl {
        unsafe { ::core::intrinsics::transmute(0x40048080 as usize) }
    }
    /// SPI0 clock divider
    #[inline(always)]
    pub fn ssp0clkdiv() -> &'static mut SYSCON_ssp0clkdiv {
        unsafe { ::core::intrinsics::transmute(0x40048094 as usize) }
    }
    /// UART clock divder
    #[inline(always)]
    pub fn uartclkdiv() -> &'static mut SYSCON_uartclkdiv {
        unsafe { ::core::intrinsics::transmute(0x40048098 as usize) }
    }
    /// SPI1 clock divder
    #[inline(always)]
    pub fn ssp1clkdiv() -> &'static mut SYSCON_ssp1clkdiv {
        unsafe { ::core::intrinsics::transmute(0x4004809c as usize) }
    }
    /// WDT clock source select
    #[inline(always)]
    pub fn wdtclksel() -> &'static mut SYSCON_wdtclksel {
        unsafe { ::core::intrinsics::transmute(0x400480d0 as usize) }
    }
    /// WDT clock source update enable
    #[inline(always)]
    pub fn wdtclkuen() -> &'static mut SYSCON_wdtclkuen {
        unsafe { ::core::intrinsics::transmute(0x400480d4 as usize) }
    }
    /// WDT clock divider
    #[inline(always)]
    pub fn wdtclkdiv() -> &'static mut SYSCON_wdtclkdiv {
        unsafe { ::core::intrinsics::transmute(0x400480d8 as usize) }
    }
    /// CLKOUT clock source select
    #[inline(always)]
    pub fn clkoutclksel() -> &'static mut SYSCON_clkoutclksel {
        unsafe { ::core::intrinsics::transmute(0x400480e0 as usize) }
    }
    /// CLKOUT clock source update enable
    #[inline(always)]
    pub fn clkoutuen() -> &'static mut SYSCON_clkoutuen {
        unsafe { ::core::intrinsics::transmute(0x400480e4 as usize) }
    }
    /// CLKOUT clock divider
    #[inline(always)]
    pub fn clkoutclkdiv() -> &'static mut SYSCON_clkoutclkdiv {
        unsafe { ::core::intrinsics::transmute(0x400480e8 as usize) }
    }
    /// POR captured PIO status 0
    #[inline(always)]
    pub fn pioporcap0() -> &'static mut SYSCON_pioporcap0 {
        unsafe { ::core::intrinsics::transmute(0x40048100 as usize) }
    }
    /// POR captured PIO status 1
    #[inline(always)]
    pub fn pioporcap1() -> &'static mut SYSCON_pioporcap1 {
        unsafe { ::core::intrinsics::transmute(0x40048104 as usize) }
    }
    /// BOD control
    #[inline(always)]
    pub fn bodctrl() -> &'static mut SYSCON_bodctrl {
        unsafe { ::core::intrinsics::transmute(0x40048150 as usize) }
    }
    /// System tick counter calibration
    #[inline(always)]
    pub fn systckcal() -> &'static mut SYSCON_systckcal {
        unsafe { ::core::intrinsics::transmute(0x40048154 as usize) }
    }
    /// NMI source selection
    #[inline(always)]
    pub fn nmisrc() -> &'static mut SYSCON_nmisrc {
        unsafe { ::core::intrinsics::transmute(0x40048174 as usize) }
    }
    /// Start logic edge control register 0
    #[inline(always)]
    pub fn startaprp0() -> &'static mut SYSCON_startaprp0 {
        unsafe { ::core::intrinsics::transmute(0x40048200 as usize) }
    }
    /// Start logic signal enable register 0
    #[inline(always)]
    pub fn starterp0() -> &'static mut SYSCON_starterp0 {
        unsafe { ::core::intrinsics::transmute(0x40048204 as usize) }
    }
    /// Start logic reset register 0
    #[inline(always)]
    pub fn startrsrp0clr() -> &'static mut SYSCON_startrsrp0clr {
        unsafe { ::core::intrinsics::transmute(0x40048208 as usize) }
    }
    /// Start logic status register 0
    #[inline(always)]
    pub fn startsrp0() -> &'static mut SYSCON_startsrp0 {
        unsafe { ::core::intrinsics::transmute(0x4004820c as usize) }
    }
    /// Power-down states in Deep-sleep mode
    #[inline(always)]
    pub fn pdsleepcfg() -> &'static mut SYSCON_pdsleepcfg {
        unsafe { ::core::intrinsics::transmute(0x40048230 as usize) }
    }
    /// Power-down states after wake-up from Deep-sleep mode
    #[inline(always)]
    pub fn pdawakecfg() -> &'static mut SYSCON_pdawakecfg {
        unsafe { ::core::intrinsics::transmute(0x40048234 as usize) }
    }
    /// Power-down configuration register
    #[inline(always)]
    pub fn pdruncfg() -> &'static mut SYSCON_pdruncfg {
        unsafe { ::core::intrinsics::transmute(0x40048238 as usize) }
    }
    /// Device ID register 0 for parts LPC1100, LPC1100C, LPC1100L.
    #[inline(always)]
    pub fn device_id() -> &'static mut SYSCON_device_id {
        unsafe { ::core::intrinsics::transmute(0x400483f4 as usize) }
    }
    }



// Registers for C_CAN





// Register CANCNTL implementation


/// Register `CANCNTL`: CAN control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_cancntl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_cancntl { }

impl C_CAN_cancntl {
    
    // Getters
    /// Fetch the value of the `CANCNTL` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_cancntl_Get {
        C_CAN_cancntl_Get::new(self)
    }

    
    /// Get value of `INIT` field.
    #[inline(always)]
    pub fn init(&self) -> C_CAN_cancntl_init {
        C_CAN_cancntl_Get::new(self).init()
    }
    
    /// Get value of `IE` field.
    #[inline(always)]
    pub fn ie(&self) -> C_CAN_cancntl_ie {
        C_CAN_cancntl_Get::new(self).ie()
    }
    
    /// Get value of `SIE` field.
    #[inline(always)]
    pub fn sie(&self) -> C_CAN_cancntl_sie {
        C_CAN_cancntl_Get::new(self).sie()
    }
    
    /// Get value of `EIE` field.
    #[inline(always)]
    pub fn eie(&self) -> C_CAN_cancntl_eie {
        C_CAN_cancntl_Get::new(self).eie()
    }
    
    /// Get value of `DAR` field.
    #[inline(always)]
    pub fn dar(&self) -> C_CAN_cancntl_dar {
        C_CAN_cancntl_Get::new(self).dar()
    }
    
    /// Get value of `CCE` field.
    #[inline(always)]
    pub fn cce(&self) -> C_CAN_cancntl_cce {
        C_CAN_cancntl_Get::new(self).cce()
    }
    
    /// Get value of `TEST` field.
    #[inline(always)]
    pub fn test(&self) -> C_CAN_cancntl_test {
        C_CAN_cancntl_Get::new(self).test()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANCNTL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_cancntl_Update {
        C_CAN_cancntl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `INIT` field.
    #[inline(always)]
    pub fn set_init<'a>(&'a mut self, new_value: C_CAN_cancntl_init) -> C_CAN_cancntl_Update<'a> {
        let mut setter: C_CAN_cancntl_Update = C_CAN_cancntl_Update::new(self);
        setter.set_init(new_value);
        setter
    }
    
    /// Set value of `IE` field.
    #[inline(always)]
    pub fn set_ie<'a>(&'a mut self, new_value: C_CAN_cancntl_ie) -> C_CAN_cancntl_Update<'a> {
        let mut setter: C_CAN_cancntl_Update = C_CAN_cancntl_Update::new(self);
        setter.set_ie(new_value);
        setter
    }
    
    /// Set value of `SIE` field.
    #[inline(always)]
    pub fn set_sie<'a>(&'a mut self, new_value: C_CAN_cancntl_sie) -> C_CAN_cancntl_Update<'a> {
        let mut setter: C_CAN_cancntl_Update = C_CAN_cancntl_Update::new(self);
        setter.set_sie(new_value);
        setter
    }
    
    /// Set value of `EIE` field.
    #[inline(always)]
    pub fn set_eie<'a>(&'a mut self, new_value: C_CAN_cancntl_eie) -> C_CAN_cancntl_Update<'a> {
        let mut setter: C_CAN_cancntl_Update = C_CAN_cancntl_Update::new(self);
        setter.set_eie(new_value);
        setter
    }
    
    /// Set value of `DAR` field.
    #[inline(always)]
    pub fn set_dar<'a>(&'a mut self, new_value: C_CAN_cancntl_dar) -> C_CAN_cancntl_Update<'a> {
        let mut setter: C_CAN_cancntl_Update = C_CAN_cancntl_Update::new(self);
        setter.set_dar(new_value);
        setter
    }
    
    /// Set value of `CCE` field.
    #[inline(always)]
    pub fn set_cce<'a>(&'a mut self, new_value: C_CAN_cancntl_cce) -> C_CAN_cancntl_Update<'a> {
        let mut setter: C_CAN_cancntl_Update = C_CAN_cancntl_Update::new(self);
        setter.set_cce(new_value);
        setter
    }
    
    /// Set value of `TEST` field.
    #[inline(always)]
    pub fn set_test<'a>(&'a mut self, new_value: C_CAN_cancntl_test) -> C_CAN_cancntl_Update<'a> {
        let mut setter: C_CAN_cancntl_Update = C_CAN_cancntl_Update::new(self);
        setter.set_test(new_value);
        setter
    }
    

    }


// Getter for C_CAN_cancntl
/// `CANCNTL`: CAN control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_cancntl_Get {
    value: u32,
}

impl C_CAN_cancntl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_cancntl) -> C_CAN_cancntl_Get {
        C_CAN_cancntl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `INIT` field: Initialization
    #[inline(always)]
    pub fn init(&self) -> C_CAN_cancntl_init {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cancntl_init::NormalOperation),
            1 => ::core::option::Option::Some(C_CAN_cancntl_init::Initialization),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `IE` field: Module interrupt enable
    #[inline(always)]
    pub fn ie(&self) -> C_CAN_cancntl_ie {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cancntl_ie::Disabled),
            1 => ::core::option::Option::Some(C_CAN_cancntl_ie::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SIE` field: Status change interrupt enable
    #[inline(always)]
    pub fn sie(&self) -> C_CAN_cancntl_sie {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cancntl_sie::Disabled),
            1 => ::core::option::Option::Some(C_CAN_cancntl_sie::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EIE` field: Error interrupt enable
    #[inline(always)]
    pub fn eie(&self) -> C_CAN_cancntl_eie {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cancntl_eie::Disabled),
            1 => ::core::option::Option::Some(C_CAN_cancntl_eie::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DAR` field: Disable automatic retransmission
    #[inline(always)]
    pub fn dar(&self) -> C_CAN_cancntl_dar {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cancntl_dar::Enabled),
            1 => ::core::option::Option::Some(C_CAN_cancntl_dar::Disabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CCE` field: Configuration change enable
    #[inline(always)]
    pub fn cce(&self) -> C_CAN_cancntl_cce {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cancntl_cce::NoAccess),
            1 => ::core::option::Option::Some(C_CAN_cancntl_cce::WriteAccess),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TEST` field: Test mode enable
    #[inline(always)]
    pub fn test(&self) -> C_CAN_cancntl_test {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cancntl_test::NormalOperation),
            1 => ::core::option::Option::Some(C_CAN_cancntl_test::TestMode),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_cancntl_Get { }


// Updater for C_CAN_cancntl
/// Updater for `CANCNTL` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_cancntl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_cancntl,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_cancntl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_cancntl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_cancntl) -> C_CAN_cancntl_Update<'a> {
        C_CAN_cancntl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_cancntl) -> C_CAN_cancntl_Update<'a> {
        C_CAN_cancntl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `INIT` field.
    #[inline(always)]
    pub fn set_init<'b>(&'b mut self, new_value: C_CAN_cancntl_init) -> &'b mut C_CAN_cancntl_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `IE` field.
    #[inline(always)]
    pub fn set_ie<'b>(&'b mut self, new_value: C_CAN_cancntl_ie) -> &'b mut C_CAN_cancntl_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `SIE` field.
    #[inline(always)]
    pub fn set_sie<'b>(&'b mut self, new_value: C_CAN_cancntl_sie) -> &'b mut C_CAN_cancntl_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `EIE` field.
    #[inline(always)]
    pub fn set_eie<'b>(&'b mut self, new_value: C_CAN_cancntl_eie) -> &'b mut C_CAN_cancntl_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `DAR` field.
    #[inline(always)]
    pub fn set_dar<'b>(&'b mut self, new_value: C_CAN_cancntl_dar) -> &'b mut C_CAN_cancntl_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `CCE` field.
    #[inline(always)]
    pub fn set_cce<'b>(&'b mut self, new_value: C_CAN_cancntl_cce) -> &'b mut C_CAN_cancntl_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `TEST` field.
    #[inline(always)]
    pub fn set_test<'b>(&'b mut self, new_value: C_CAN_cancntl_test) -> &'b mut C_CAN_cancntl_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cancntl_init {
    /// Normal operation.
    NormalOperation = 0,
    /// Initialization is started. On reset, software needs to initialize the CAN controller.
    Initialization = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cancntl_ie {
    /// Disable CAN interrupts. The interrupt line is always HIGH.
    Disabled = 0,
    /// Enable CAN interrupts. The interrupt line is set to LOW and remains LOW until all pending interrupts are cleared.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cancntl_sie {
    /// Disable status change interrupts. No status change interrupt will be generated.
    Disabled = 0,
    /// Enable status change interrupts. A status change interrupt will be generated when a message transfer is successfully completed or a CAN bus error is detected.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cancntl_eie {
    /// Disable error interrupt. No error status interrupt will be generated.
    Disabled = 0,
    /// Enable error interrupt. A change in the bits BOFF or EWARN in the CANSTAT registers will generate an interrupt.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cancntl_dar {
    /// Automatic retransmission of disturbed messages enabled.
    Enabled = 0,
    /// Automatic retransmission disabled.
    Disabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cancntl_cce {
    /// The CPU has no write access to the bit timing register.
    NoAccess = 0,
    /// The CPU has write access to the CANBT register while the INIT bit is one.
    WriteAccess = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cancntl_test {
    /// Normal operation.
    NormalOperation = 0,
    /// Test mode.
    TestMode = 1,
    }







// Register CANSTAT implementation


/// Register `CANSTAT`: Status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canstat {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canstat { }

impl C_CAN_canstat {
    
    // Getters
    /// Fetch the value of the `CANSTAT` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canstat_Get {
        C_CAN_canstat_Get::new(self)
    }

    
    /// Get value of `LEC` field.
    #[inline(always)]
    pub fn lec(&self) -> C_CAN_canstat_lec {
        C_CAN_canstat_Get::new(self).lec()
    }
    
    /// Get value of `TXOK` field.
    #[inline(always)]
    pub fn txok(&self) -> C_CAN_canstat_txok {
        C_CAN_canstat_Get::new(self).txok()
    }
    
    /// Get value of `RXOK` field.
    #[inline(always)]
    pub fn rxok(&self) -> C_CAN_canstat_rxok {
        C_CAN_canstat_Get::new(self).rxok()
    }
    
    /// Get value of `EPASS` field.
    #[inline(always)]
    pub fn epass(&self) -> C_CAN_canstat_epass {
        C_CAN_canstat_Get::new(self).epass()
    }
    
    /// Get value of `EWARN` field.
    #[inline(always)]
    pub fn ewarn(&self) -> C_CAN_canstat_ewarn {
        C_CAN_canstat_Get::new(self).ewarn()
    }
    
    /// Get value of `BOFF` field.
    #[inline(always)]
    pub fn boff(&self) -> C_CAN_canstat_boff {
        C_CAN_canstat_Get::new(self).boff()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANSTAT` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canstat_Update {
        C_CAN_canstat_Update::new_ignoring_state(self)
    }

    
    /// Set value of `LEC` field.
    #[inline(always)]
    pub fn set_lec<'a>(&'a mut self, new_value: C_CAN_canstat_lec) -> C_CAN_canstat_Update<'a> {
        let mut setter: C_CAN_canstat_Update = C_CAN_canstat_Update::new(self);
        setter.set_lec(new_value);
        setter
    }
    
    /// Set value of `TXOK` field.
    #[inline(always)]
    pub fn set_txok<'a>(&'a mut self, new_value: C_CAN_canstat_txok) -> C_CAN_canstat_Update<'a> {
        let mut setter: C_CAN_canstat_Update = C_CAN_canstat_Update::new(self);
        setter.set_txok(new_value);
        setter
    }
    
    /// Set value of `RXOK` field.
    #[inline(always)]
    pub fn set_rxok<'a>(&'a mut self, new_value: C_CAN_canstat_rxok) -> C_CAN_canstat_Update<'a> {
        let mut setter: C_CAN_canstat_Update = C_CAN_canstat_Update::new(self);
        setter.set_rxok(new_value);
        setter
    }
    
    /// Set value of `EPASS` field.
    #[inline(always)]
    pub fn set_epass<'a>(&'a mut self, new_value: C_CAN_canstat_epass) -> C_CAN_canstat_Update<'a> {
        let mut setter: C_CAN_canstat_Update = C_CAN_canstat_Update::new(self);
        setter.set_epass(new_value);
        setter
    }
    
    /// Set value of `EWARN` field.
    #[inline(always)]
    pub fn set_ewarn<'a>(&'a mut self, new_value: C_CAN_canstat_ewarn) -> C_CAN_canstat_Update<'a> {
        let mut setter: C_CAN_canstat_Update = C_CAN_canstat_Update::new(self);
        setter.set_ewarn(new_value);
        setter
    }
    
    /// Set value of `BOFF` field.
    #[inline(always)]
    pub fn set_boff<'a>(&'a mut self, new_value: C_CAN_canstat_boff) -> C_CAN_canstat_Update<'a> {
        let mut setter: C_CAN_canstat_Update = C_CAN_canstat_Update::new(self);
        setter.set_boff(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canstat
/// `CANSTAT`: Status register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canstat_Get {
    value: u32,
}

impl C_CAN_canstat_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canstat) -> C_CAN_canstat_Get {
        C_CAN_canstat_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `LEC` field: Last error code Type of the last error to occur on the CAN bus.The LEC field holds a code which indicates the type of the last error to occur on the CAN bus. This field will be cleared to 0 when a message has been transferred (reception or transmission) without error. The unused code 111 may be written by the CPU to check for updates.
    #[inline(always)]
    pub fn lec(&self) -> C_CAN_canstat_lec {
        match (self.value >> 0) & 7 {
            0 => ::core::option::Option::Some(C_CAN_canstat_lec::NoError),
            1 => ::core::option::Option::Some(C_CAN_canstat_lec::StuffError),
            2 => ::core::option::Option::Some(C_CAN_canstat_lec::FormError),
            3 => ::core::option::Option::Some(C_CAN_canstat_lec::AckError),
            4 => ::core::option::Option::Some(C_CAN_canstat_lec::Bit1Error),
            5 => ::core::option::Option::Some(C_CAN_canstat_lec::Bit0Error),
            6 => ::core::option::Option::Some(C_CAN_canstat_lec::CRCError),
            7 => ::core::option::Option::Some(C_CAN_canstat_lec::Unused),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TXOK` field: Transmitted a message successfully This bit is reset by the CPU. It is never reset by the CAN controller.
    #[inline(always)]
    pub fn txok(&self) -> C_CAN_canstat_txok {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canstat_txok::NoSuccessfulTramsmission),
            1 => ::core::option::Option::Some(C_CAN_canstat_txok::SuccessfulTransmission),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RXOK` field: Received a message successfully This bit is reset by the CPU. It is never reset by the CAN controller.
    #[inline(always)]
    pub fn rxok(&self) -> C_CAN_canstat_rxok {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canstat_rxok::NoSuccessfulTramsmission),
            1 => ::core::option::Option::Some(C_CAN_canstat_rxok::SuccessfulTransmission),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EPASS` field: Error passive
    #[inline(always)]
    pub fn epass(&self) -> C_CAN_canstat_epass {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canstat_epass::Active),
            1 => ::core::option::Option::Some(C_CAN_canstat_epass::Passive),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `EWARN` field: Warning status
    #[inline(always)]
    pub fn ewarn(&self) -> C_CAN_canstat_ewarn {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canstat_ewarn::BelowWarningLimit),
            1 => ::core::option::Option::Some(C_CAN_canstat_ewarn::OverWarningLimit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `BOFF` field: Busoff status
    #[inline(always)]
    pub fn boff(&self) -> C_CAN_canstat_boff {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canstat_boff::NoInBusOff),
            1 => ::core::option::Option::Some(C_CAN_canstat_boff::InBusOff),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canstat_Get { }


// Updater for C_CAN_canstat
/// Updater for `CANSTAT` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canstat_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canstat,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canstat_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canstat_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canstat) -> C_CAN_canstat_Update<'a> {
        C_CAN_canstat_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canstat) -> C_CAN_canstat_Update<'a> {
        C_CAN_canstat_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `LEC` field.
    #[inline(always)]
    pub fn set_lec<'b>(&'b mut self, new_value: C_CAN_canstat_lec) -> &'b mut C_CAN_canstat_Update<'a> {
        self.value = (self.value & !(7 << 0))
                   | ((new_value as u32) & 7) << 0;
        self.mask |= 7 << 0;
        self
    }
    /// Set value of `TXOK` field.
    #[inline(always)]
    pub fn set_txok<'b>(&'b mut self, new_value: C_CAN_canstat_txok) -> &'b mut C_CAN_canstat_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `RXOK` field.
    #[inline(always)]
    pub fn set_rxok<'b>(&'b mut self, new_value: C_CAN_canstat_rxok) -> &'b mut C_CAN_canstat_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `EPASS` field.
    #[inline(always)]
    pub fn set_epass<'b>(&'b mut self, new_value: C_CAN_canstat_epass) -> &'b mut C_CAN_canstat_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `EWARN` field.
    #[inline(always)]
    pub fn set_ewarn<'b>(&'b mut self, new_value: C_CAN_canstat_ewarn) -> &'b mut C_CAN_canstat_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `BOFF` field.
    #[inline(always)]
    pub fn set_boff<'b>(&'b mut self, new_value: C_CAN_canstat_boff) -> &'b mut C_CAN_canstat_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canstat_lec {
    /// No error.
    NoError = 0,
    /// Stuff error: More than 5 equal bits in a sequence have occurred in a part of a received message where this is not allowed.
    StuffError = 1,
    /// Form error: A fixed format part of a received frame has the wrong format.
    FormError = 2,
    /// AckError: The message this CAN core transmitted was not acknowledged.
    AckError = 3,
    /// Bit1Error: During the transmission of a message (with the exception of the arbitration field), the device wanted to send a HIGH/recessive level (bit of logical value 1), but the monitored bus value was LOW/dominant.
    Bit1Error = 4,
    /// Bit0Error: During the transmission of a message (or acknowledge bit, or active error flag, or overload flag), the device wanted to send a LOW/dominant level (data or identifier bit logical value 0), but the monitored Bus value was HIGH/recessive. During busoff recovery this status is set each time a sequence of 11 HIGH/recessive bits has been monitored. This enables the CPU to monitor the proceeding of the busoff recovery sequence (indicating the bus is not stuck at LOW/dominant or continuously disturbed).
    Bit0Error = 5,
    /// CRCError: The CRC checksum was incorrect in the message received.
    CRCError = 6,
    /// Unused: No CAN bus event was detected (written by the CPU).
    Unused = 7,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canstat_txok {
    /// Since this bit was reset by the CPU, no message has been successfully transmitted.
    NoSuccessfulTramsmission = 0,
    /// Since this bit was last reset by the CPU, a message has been successfully transmitted (error free and acknowledged by at least one other node).
    SuccessfulTransmission = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canstat_rxok {
    /// Since this bit was last reset by the CPU, no message has been successfully transmitted.
    NoSuccessfulTramsmission = 0,
    /// Since this bit was last set to zero by the CPU, a message has been successfully received independent of the result of acceptance filtering.
    SuccessfulTransmission = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canstat_epass {
    /// The CAN controller is in the error active state.
    Active = 0,
    /// The CAN controller is in the error passive state as defined in the CAN 2.0 specification.
    Passive = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canstat_ewarn {
    /// Both error counters are below the error warning limit of 96.
    BelowWarningLimit = 0,
    /// At least one of the error counters in the EML has reached the error warning limit of 96.
    OverWarningLimit = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canstat_boff {
    /// The CAN module is not in busoff.
    NoInBusOff = 0,
    /// The CAN controller is in busoff state.
    InBusOff = 1,
    }







// Register CANEC implementation


/// Register `CANEC`: Error counter
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canec {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canec { }

impl C_CAN_canec {
    
    // Getters
    /// Fetch the value of the `CANEC` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canec_Get {
        C_CAN_canec_Get::new(self)
    }

    
    /// Get value of `TEC_7_0` field.
    #[inline(always)]
    pub fn tec_7_0(&self) -> u32 {
        C_CAN_canec_Get::new(self).tec_7_0()
    }
    
    /// Get value of `REC_6_0` field.
    #[inline(always)]
    pub fn rec_6_0(&self) -> u32 {
        C_CAN_canec_Get::new(self).rec_6_0()
    }
    
    /// Get value of `RP` field.
    #[inline(always)]
    pub fn rp(&self) -> C_CAN_canec_rp {
        C_CAN_canec_Get::new(self).rp()
    }
    

    }


// Getter for C_CAN_canec
/// `CANEC`: Error counter
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canec_Get {
    value: u32,
}

impl C_CAN_canec_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canec) -> C_CAN_canec_Get {
        C_CAN_canec_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TEC_7_0` field: Transmit error counter Current value of the transmit error counter (maximum value 255)
    #[inline(always)]
    pub fn tec_7_0(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `REC_6_0` field: Receive error counter Current value of the receive error counter (maximum value 127).
    #[inline(always)]
    pub fn rec_6_0(&self) -> u32 {
        (self.value >> 8) & 127
        }
    /// Get value of `RP` field: Receive error passive
    #[inline(always)]
    pub fn rp(&self) -> C_CAN_canec_rp {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canec_rp::BelowErrorPassive),
            1 => ::core::option::Option::Some(C_CAN_canec_rp::OverErrorPassive),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canec_Get { }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canec_rp {
    /// The receive counter is below the error passive level.
    BelowErrorPassive = 0,
    /// The receive counter has reached the error passive level as defined in the  CAN2.0 specification.
    OverErrorPassive = 1,
    }







// Register CANBT implementation


/// Register `CANBT`: Bit timing register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canbt {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canbt { }

impl C_CAN_canbt {
    
    // Getters
    /// Fetch the value of the `CANBT` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canbt_Get {
        C_CAN_canbt_Get::new(self)
    }

    
    /// Get value of `BRP` field.
    #[inline(always)]
    pub fn brp(&self) -> u32 {
        C_CAN_canbt_Get::new(self).brp()
    }
    
    /// Get value of `SJW` field.
    #[inline(always)]
    pub fn sjw(&self) -> u32 {
        C_CAN_canbt_Get::new(self).sjw()
    }
    
    /// Get value of `TSEG1` field.
    #[inline(always)]
    pub fn tseg1(&self) -> u32 {
        C_CAN_canbt_Get::new(self).tseg1()
    }
    
    /// Get value of `TSEG2` field.
    #[inline(always)]
    pub fn tseg2(&self) -> u32 {
        C_CAN_canbt_Get::new(self).tseg2()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANBT` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canbt_Update {
        C_CAN_canbt_Update::new_ignoring_state(self)
    }

    
    /// Set value of `BRP` field.
    #[inline(always)]
    pub fn set_brp<'a>(&'a mut self, new_value: u32) -> C_CAN_canbt_Update<'a> {
        let mut setter: C_CAN_canbt_Update = C_CAN_canbt_Update::new(self);
        setter.set_brp(new_value);
        setter
    }
    
    /// Set value of `SJW` field.
    #[inline(always)]
    pub fn set_sjw<'a>(&'a mut self, new_value: u32) -> C_CAN_canbt_Update<'a> {
        let mut setter: C_CAN_canbt_Update = C_CAN_canbt_Update::new(self);
        setter.set_sjw(new_value);
        setter
    }
    
    /// Set value of `TSEG1` field.
    #[inline(always)]
    pub fn set_tseg1<'a>(&'a mut self, new_value: u32) -> C_CAN_canbt_Update<'a> {
        let mut setter: C_CAN_canbt_Update = C_CAN_canbt_Update::new(self);
        setter.set_tseg1(new_value);
        setter
    }
    
    /// Set value of `TSEG2` field.
    #[inline(always)]
    pub fn set_tseg2<'a>(&'a mut self, new_value: u32) -> C_CAN_canbt_Update<'a> {
        let mut setter: C_CAN_canbt_Update = C_CAN_canbt_Update::new(self);
        setter.set_tseg2(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canbt
/// `CANBT`: Bit timing register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canbt_Get {
    value: u32,
}

impl C_CAN_canbt_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canbt) -> C_CAN_canbt_Get {
        C_CAN_canbt_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `BRP` field: Baud rate prescaler The value by which the oscillator frequency is divided for generating the bit time quanta. The bit time is built up from a multiple of this quanta. Valid values for the Baud Rate Prescaler are 0 to 63.[1]
    #[inline(always)]
    pub fn brp(&self) -> u32 {
        (self.value >> 0) & 63
        }
    /// Get value of `SJW` field: (Re)synchronization jump width Valid programmed values are 0 to 3.[1]
    #[inline(always)]
    pub fn sjw(&self) -> u32 {
        (self.value >> 6) & 3
        }
    /// Get value of `TSEG1` field: Time segment before the sample point Valid values are 1 to 15.[1]
    #[inline(always)]
    pub fn tseg1(&self) -> u32 {
        (self.value >> 8) & 15
        }
    /// Get value of `TSEG2` field: Time segment after the sample point Valid values are 0 to 7.[1]
    #[inline(always)]
    pub fn tseg2(&self) -> u32 {
        (self.value >> 12) & 7
        }
    }

impl ::core::marker::Copy for C_CAN_canbt_Get { }


// Updater for C_CAN_canbt
/// Updater for `CANBT` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canbt_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canbt,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canbt_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canbt_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canbt) -> C_CAN_canbt_Update<'a> {
        C_CAN_canbt_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canbt) -> C_CAN_canbt_Update<'a> {
        C_CAN_canbt_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `BRP` field.
    #[inline(always)]
    pub fn set_brp<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canbt_Update<'a> {
        self.value = (self.value & !(63 << 0))
                   | ((new_value as u32) & 63) << 0;
        self.mask |= 63 << 0;
        self
    }
    /// Set value of `SJW` field.
    #[inline(always)]
    pub fn set_sjw<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canbt_Update<'a> {
        self.value = (self.value & !(3 << 6))
                   | ((new_value as u32) & 3) << 6;
        self.mask |= 3 << 6;
        self
    }
    /// Set value of `TSEG1` field.
    #[inline(always)]
    pub fn set_tseg1<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canbt_Update<'a> {
        self.value = (self.value & !(15 << 8))
                   | ((new_value as u32) & 15) << 8;
        self.mask |= 15 << 8;
        self
    }
    /// Set value of `TSEG2` field.
    #[inline(always)]
    pub fn set_tseg2<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canbt_Update<'a> {
        self.value = (self.value & !(7 << 12))
                   | ((new_value as u32) & 7) << 12;
        self.mask |= 7 << 12;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANINT implementation


/// Register `CANINT`: Interrupt register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canint {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canint { }

impl C_CAN_canint {
    
    // Getters
    /// Fetch the value of the `CANINT` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canint_Get {
        C_CAN_canint_Get::new(self)
    }

    
    /// Get value of `INTID` field.
    #[inline(always)]
    pub fn intid(&self) -> u32 {
        C_CAN_canint_Get::new(self).intid()
    }
    

    }


// Getter for C_CAN_canint
/// `CANINT`: Interrupt register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canint_Get {
    value: u32,
}

impl C_CAN_canint_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canint) -> C_CAN_canint_Get {
        C_CAN_canint_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `INTID` field: 0x0000 = No interrupt is pending. 0x0001 - 0x0020 = Number of message object which caused the interrupt. 0x0021 - 0x7FFF = Unused 0x8000 = Status interrupt 0x8001 - 0xFFFF = Unused
    #[inline(always)]
    pub fn intid(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_canint_Get { }







// Register CANTEST implementation


/// Register `CANTEST`: Test register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_cantest {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_cantest { }

impl C_CAN_cantest {
    
    // Getters
    /// Fetch the value of the `CANTEST` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_cantest_Get {
        C_CAN_cantest_Get::new(self)
    }

    
    /// Get value of `BASIC` field.
    #[inline(always)]
    pub fn basic(&self) -> C_CAN_cantest_basic {
        C_CAN_cantest_Get::new(self).basic()
    }
    
    /// Get value of `SILENT` field.
    #[inline(always)]
    pub fn silent(&self) -> C_CAN_cantest_silent {
        C_CAN_cantest_Get::new(self).silent()
    }
    
    /// Get value of `LBACK` field.
    #[inline(always)]
    pub fn lback(&self) -> C_CAN_cantest_lback {
        C_CAN_cantest_Get::new(self).lback()
    }
    
    /// Get value of `TX` field.
    #[inline(always)]
    pub fn tx(&self) -> C_CAN_cantest_tx {
        C_CAN_cantest_Get::new(self).tx()
    }
    
    /// Get value of `RX` field.
    #[inline(always)]
    pub fn rx(&self) -> C_CAN_cantest_rx {
        C_CAN_cantest_Get::new(self).rx()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANTEST` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_cantest_Update {
        C_CAN_cantest_Update::new_ignoring_state(self)
    }

    
    /// Set value of `BASIC` field.
    #[inline(always)]
    pub fn set_basic<'a>(&'a mut self, new_value: C_CAN_cantest_basic) -> C_CAN_cantest_Update<'a> {
        let mut setter: C_CAN_cantest_Update = C_CAN_cantest_Update::new(self);
        setter.set_basic(new_value);
        setter
    }
    
    /// Set value of `SILENT` field.
    #[inline(always)]
    pub fn set_silent<'a>(&'a mut self, new_value: C_CAN_cantest_silent) -> C_CAN_cantest_Update<'a> {
        let mut setter: C_CAN_cantest_Update = C_CAN_cantest_Update::new(self);
        setter.set_silent(new_value);
        setter
    }
    
    /// Set value of `LBACK` field.
    #[inline(always)]
    pub fn set_lback<'a>(&'a mut self, new_value: C_CAN_cantest_lback) -> C_CAN_cantest_Update<'a> {
        let mut setter: C_CAN_cantest_Update = C_CAN_cantest_Update::new(self);
        setter.set_lback(new_value);
        setter
    }
    
    /// Set value of `TX` field.
    #[inline(always)]
    pub fn set_tx<'a>(&'a mut self, new_value: C_CAN_cantest_tx) -> C_CAN_cantest_Update<'a> {
        let mut setter: C_CAN_cantest_Update = C_CAN_cantest_Update::new(self);
        setter.set_tx(new_value);
        setter
    }
    
    /// Set value of `RX` field.
    #[inline(always)]
    pub fn set_rx<'a>(&'a mut self, new_value: C_CAN_cantest_rx) -> C_CAN_cantest_Update<'a> {
        let mut setter: C_CAN_cantest_Update = C_CAN_cantest_Update::new(self);
        setter.set_rx(new_value);
        setter
    }
    

    }


// Getter for C_CAN_cantest
/// `CANTEST`: Test register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_cantest_Get {
    value: u32,
}

impl C_CAN_cantest_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_cantest) -> C_CAN_cantest_Get {
        C_CAN_cantest_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `BASIC` field: Basic mode
    #[inline(always)]
    pub fn basic(&self) -> C_CAN_cantest_basic {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cantest_basic::Disabled),
            1 => ::core::option::Option::Some(C_CAN_cantest_basic::TXRX),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `SILENT` field: Silent mode
    #[inline(always)]
    pub fn silent(&self) -> C_CAN_cantest_silent {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cantest_silent::NormalOperation),
            1 => ::core::option::Option::Some(C_CAN_cantest_silent::Silent),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `LBACK` field: Loop back mode
    #[inline(always)]
    pub fn lback(&self) -> C_CAN_cantest_lback {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cantest_lback::Disabled),
            1 => ::core::option::Option::Some(C_CAN_cantest_lback::Enabled),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TX` field: Control of CAN_TXD pins
    #[inline(always)]
    pub fn tx(&self) -> C_CAN_cantest_tx {
        match (self.value >> 5) & 3 {
            0 => ::core::option::Option::Some(C_CAN_cantest_tx::ControlledByCANController),
            1 => ::core::option::Option::Some(C_CAN_cantest_tx::TXD),
            2 => ::core::option::Option::Some(C_CAN_cantest_tx::Low),
            3 => ::core::option::Option::Some(C_CAN_cantest_tx::High),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RX` field: Monitors the actual value of the CAN_RXD pin.
    #[inline(always)]
    pub fn rx(&self) -> C_CAN_cantest_rx {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(C_CAN_cantest_rx::Recessive),
            1 => ::core::option::Option::Some(C_CAN_cantest_rx::Dormant),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_cantest_Get { }


// Updater for C_CAN_cantest
/// Updater for `CANTEST` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_cantest_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_cantest,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_cantest_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_cantest_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_cantest) -> C_CAN_cantest_Update<'a> {
        C_CAN_cantest_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_cantest) -> C_CAN_cantest_Update<'a> {
        C_CAN_cantest_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `BASIC` field.
    #[inline(always)]
    pub fn set_basic<'b>(&'b mut self, new_value: C_CAN_cantest_basic) -> &'b mut C_CAN_cantest_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `SILENT` field.
    #[inline(always)]
    pub fn set_silent<'b>(&'b mut self, new_value: C_CAN_cantest_silent) -> &'b mut C_CAN_cantest_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `LBACK` field.
    #[inline(always)]
    pub fn set_lback<'b>(&'b mut self, new_value: C_CAN_cantest_lback) -> &'b mut C_CAN_cantest_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `TX` field.
    #[inline(always)]
    pub fn set_tx<'b>(&'b mut self, new_value: C_CAN_cantest_tx) -> &'b mut C_CAN_cantest_Update<'a> {
        self.value = (self.value & !(3 << 5))
                   | ((new_value as u32) & 3) << 5;
        self.mask |= 3 << 5;
        self
    }
    /// Set value of `RX` field.
    #[inline(always)]
    pub fn set_rx<'b>(&'b mut self, new_value: C_CAN_cantest_rx) -> &'b mut C_CAN_cantest_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cantest_basic {
    /// Basic mode disabled.
    Disabled = 0,
    /// IF1 registers used as TX buffer, IF2 registers used as RX buffer.
    TXRX = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cantest_silent {
    /// Normal operation.
    NormalOperation = 0,
    /// The module is in silent mode.
    Silent = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cantest_lback {
    /// Loop back mode is disabled.
    Disabled = 0,
    /// Loop back mode is enabled.
    Enabled = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cantest_tx {
    /// Level at the CAN_TXD pin is controlled by the CAN controller. This is the value at reset.
    ControlledByCANController = 0,
    /// The sample point can be monitored at the CAN_TXD pin.
    TXD = 1,
    /// CAN_TXD pin is driven LOW/dominant.
    Low = 2,
    /// CAN_TXD pin is driven HIGH/recessive.
    High = 3,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_cantest_rx {
    /// The CAN bus is recessive (CAN_RXD = 1).
    Recessive = 0,
    /// The CAN bus is dominant (CAN_RXD = 0).
    Dormant = 1,
    }







// Register CANBRPE implementation


/// Register `CANBRPE`: Baud rate prescaler extension register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canbrpe {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canbrpe { }

impl C_CAN_canbrpe {
    
    // Getters
    /// Fetch the value of the `CANBRPE` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canbrpe_Get {
        C_CAN_canbrpe_Get::new(self)
    }

    
    /// Get value of `BRPE` field.
    #[inline(always)]
    pub fn brpe(&self) -> u32 {
        C_CAN_canbrpe_Get::new(self).brpe()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANBRPE` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canbrpe_Update {
        C_CAN_canbrpe_Update::new_ignoring_state(self)
    }

    
    /// Set value of `BRPE` field.
    #[inline(always)]
    pub fn set_brpe<'a>(&'a mut self, new_value: u32) -> C_CAN_canbrpe_Update<'a> {
        let mut setter: C_CAN_canbrpe_Update = C_CAN_canbrpe_Update::new(self);
        setter.set_brpe(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canbrpe
/// `CANBRPE`: Baud rate prescaler extension register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canbrpe_Get {
    value: u32,
}

impl C_CAN_canbrpe_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canbrpe) -> C_CAN_canbrpe_Get {
        C_CAN_canbrpe_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `BRPE` field: Baud rate prescaler extension By programming BRPE the Baud Rate Prescaler can be extended to values up to 1023. Hardware interprets the value as the value of BRPE (MSBs) and BRP (LSBs) plus one. Allowed values are 0 to 15.
    #[inline(always)]
    pub fn brpe(&self) -> u32 {
        (self.value >> 0) & 15
        }
    }

impl ::core::marker::Copy for C_CAN_canbrpe_Get { }


// Updater for C_CAN_canbrpe
/// Updater for `CANBRPE` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canbrpe_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canbrpe,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canbrpe_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canbrpe_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canbrpe) -> C_CAN_canbrpe_Update<'a> {
        C_CAN_canbrpe_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canbrpe) -> C_CAN_canbrpe_Update<'a> {
        C_CAN_canbrpe_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `BRPE` field.
    #[inline(always)]
    pub fn set_brpe<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canbrpe_Update<'a> {
        self.value = (self.value & !(15 << 0))
                   | ((new_value as u32) & 15) << 0;
        self.mask |= 15 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF1_CMDREQ implementation


/// Register `CANIF1_CMDREQ`: Message interface  command request
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_cmdreq {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_cmdreq { }

impl C_CAN_canif1_cmdreq {
    
    // Getters
    /// Fetch the value of the `CANIF1_CMDREQ` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_cmdreq_Get {
        C_CAN_canif1_cmdreq_Get::new(self)
    }

    
    /// Get value of `MN` field.
    #[inline(always)]
    pub fn mn(&self) -> u32 {
        C_CAN_canif1_cmdreq_Get::new(self).mn()
    }
    
    /// Get value of `BUSY` field.
    #[inline(always)]
    pub fn busy(&self) -> C_CAN_canif1_cmdreq_busy {
        C_CAN_canif1_cmdreq_Get::new(self).busy()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_CMDREQ` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_cmdreq_Update {
        C_CAN_canif1_cmdreq_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MN` field.
    #[inline(always)]
    pub fn set_mn<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_cmdreq_Update<'a> {
        let mut setter: C_CAN_canif1_cmdreq_Update = C_CAN_canif1_cmdreq_Update::new(self);
        setter.set_mn(new_value);
        setter
    }
    
    /// Set value of `BUSY` field.
    #[inline(always)]
    pub fn set_busy<'a>(&'a mut self, new_value: C_CAN_canif1_cmdreq_busy) -> C_CAN_canif1_cmdreq_Update<'a> {
        let mut setter: C_CAN_canif1_cmdreq_Update = C_CAN_canif1_cmdreq_Update::new(self);
        setter.set_busy(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_cmdreq
/// `CANIF1_CMDREQ`: Message interface  command request
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_cmdreq_Get {
    value: u32,
}

impl C_CAN_canif1_cmdreq_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_cmdreq) -> C_CAN_canif1_cmdreq_Get {
        C_CAN_canif1_cmdreq_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MN` field: Message number 0x01 - 0x20 = Valid message numbers. The message object in the message RAM is selected for data transfer. 0x00 = Not a valid message number. This value is interpreted as 0x20.[1] 0x21 - 0x3F = Not a valid message number. This value is interpreted as 0x01 - 0x1F.[1]
    #[inline(always)]
    pub fn mn(&self) -> u32 {
        (self.value >> 0) & 63
        }
    /// Get value of `BUSY` field: BUSY flag
    #[inline(always)]
    pub fn busy(&self) -> C_CAN_canif1_cmdreq_busy {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdreq_busy::Zero),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdreq_busy::One),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_cmdreq_Get { }


// Updater for C_CAN_canif1_cmdreq
/// Updater for `CANIF1_CMDREQ` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_cmdreq_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_cmdreq,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_cmdreq_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_cmdreq_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_cmdreq) -> C_CAN_canif1_cmdreq_Update<'a> {
        C_CAN_canif1_cmdreq_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_cmdreq) -> C_CAN_canif1_cmdreq_Update<'a> {
        C_CAN_canif1_cmdreq_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MN` field.
    #[inline(always)]
    pub fn set_mn<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_cmdreq_Update<'a> {
        self.value = (self.value & !(63 << 0))
                   | ((new_value as u32) & 63) << 0;
        self.mask |= 63 << 0;
        self
    }
    /// Set value of `BUSY` field.
    #[inline(always)]
    pub fn set_busy<'b>(&'b mut self, new_value: C_CAN_canif1_cmdreq_busy) -> &'b mut C_CAN_canif1_cmdreq_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdreq_busy {
    /// Set to zero by hardware when read/write action to this Command request register has finished.
    Zero = 0,
    /// Set to one by hardware when writing to this Command request register.
    One = 1,
    }







// Register CANIF2_CMDREQ implementation


/// Register `CANIF2_CMDREQ`: Message interface  command request
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_cmdreq {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_cmdreq { }

impl C_CAN_canif2_cmdreq {
    
    // Getters
    /// Fetch the value of the `CANIF2_CMDREQ` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_cmdreq_Get {
        C_CAN_canif2_cmdreq_Get::new(self)
    }

    
    /// Get value of `MN` field.
    #[inline(always)]
    pub fn mn(&self) -> u32 {
        C_CAN_canif2_cmdreq_Get::new(self).mn()
    }
    
    /// Get value of `BUSY` field.
    #[inline(always)]
    pub fn busy(&self) -> C_CAN_canif2_cmdreq_busy {
        C_CAN_canif2_cmdreq_Get::new(self).busy()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_CMDREQ` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_cmdreq_Update {
        C_CAN_canif2_cmdreq_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MN` field.
    #[inline(always)]
    pub fn set_mn<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_cmdreq_Update<'a> {
        let mut setter: C_CAN_canif2_cmdreq_Update = C_CAN_canif2_cmdreq_Update::new(self);
        setter.set_mn(new_value);
        setter
    }
    
    /// Set value of `BUSY` field.
    #[inline(always)]
    pub fn set_busy<'a>(&'a mut self, new_value: C_CAN_canif2_cmdreq_busy) -> C_CAN_canif2_cmdreq_Update<'a> {
        let mut setter: C_CAN_canif2_cmdreq_Update = C_CAN_canif2_cmdreq_Update::new(self);
        setter.set_busy(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_cmdreq
/// `CANIF2_CMDREQ`: Message interface  command request
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_cmdreq_Get {
    value: u32,
}

impl C_CAN_canif2_cmdreq_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_cmdreq) -> C_CAN_canif2_cmdreq_Get {
        C_CAN_canif2_cmdreq_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MN` field: Message number 0x01 - 0x20 = Valid message numbers. The message object in the message RAM is selected for data transfer. 0x00 = Not a valid message number. This value is interpreted as 0x20.[1] 0x21 - 0x3F = Not a valid message number. This value is interpreted as 0x01 - 0x1F.[1]
    #[inline(always)]
    pub fn mn(&self) -> u32 {
        (self.value >> 0) & 63
        }
    /// Get value of `BUSY` field: BUSY flag
    #[inline(always)]
    pub fn busy(&self) -> C_CAN_canif2_cmdreq_busy {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdreq_busy::Zero),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdreq_busy::One),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_cmdreq_Get { }


// Updater for C_CAN_canif2_cmdreq
/// Updater for `CANIF2_CMDREQ` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_cmdreq_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_cmdreq,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_cmdreq_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_cmdreq_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_cmdreq) -> C_CAN_canif2_cmdreq_Update<'a> {
        C_CAN_canif2_cmdreq_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_cmdreq) -> C_CAN_canif2_cmdreq_Update<'a> {
        C_CAN_canif2_cmdreq_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MN` field.
    #[inline(always)]
    pub fn set_mn<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_cmdreq_Update<'a> {
        self.value = (self.value & !(63 << 0))
                   | ((new_value as u32) & 63) << 0;
        self.mask |= 63 << 0;
        self
    }
    /// Set value of `BUSY` field.
    #[inline(always)]
    pub fn set_busy<'b>(&'b mut self, new_value: C_CAN_canif2_cmdreq_busy) -> &'b mut C_CAN_canif2_cmdreq_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdreq_busy {
    /// Set to zero by hardware when read/write action to this Command request register has finished.
    Zero = 0,
    /// Set to one by hardware when writing to this Command request register.
    One = 1,
    }







// Register CANIF1_CMDMSK_W implementation


/// Register `CANIF1_CMDMSK_W`: Message interface command mask - write direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_cmdmsk_w {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_cmdmsk_w { }

impl C_CAN_canif1_cmdmsk_w {
    
    // Getters
    /// Fetch the value of the `CANIF1_CMDMSK_W` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_cmdmsk_w_Get {
        C_CAN_canif1_cmdmsk_w_Get::new(self)
    }

    
    /// Get value of `DATA_B` field.
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif1_cmdmsk_w_data_b {
        C_CAN_canif1_cmdmsk_w_Get::new(self).data_b()
    }
    
    /// Get value of `DATA_A` field.
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif1_cmdmsk_w_data_a {
        C_CAN_canif1_cmdmsk_w_Get::new(self).data_a()
    }
    
    /// Get value of `TXRQST` field.
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif1_cmdmsk_w_txrqst {
        C_CAN_canif1_cmdmsk_w_Get::new(self).txrqst()
    }
    
    /// Get value of `CLRINTPND` field.
    #[inline(always)]
    pub fn clrintpnd(&self) -> bool {
        C_CAN_canif1_cmdmsk_w_Get::new(self).clrintpnd()
    }
    
    /// Get value of `CTRL` field.
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif1_cmdmsk_w_ctrl {
        C_CAN_canif1_cmdmsk_w_Get::new(self).ctrl()
    }
    
    /// Get value of `ARB` field.
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif1_cmdmsk_w_arb {
        C_CAN_canif1_cmdmsk_w_Get::new(self).arb()
    }
    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif1_cmdmsk_w_mask {
        C_CAN_canif1_cmdmsk_w_Get::new(self).mask()
    }
    
    /// Get value of `WR_RD` field.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        C_CAN_canif1_cmdmsk_w_Get::new(self).wr_rd()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_CMDMSK_W` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_cmdmsk_w_Update {
        C_CAN_canif1_cmdmsk_w_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_w_data_b) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_data_b(new_value);
        setter
    }
    
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_w_data_a) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_data_a(new_value);
        setter
    }
    
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_w_txrqst) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_txrqst(new_value);
        setter
    }
    
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'a>(&'a mut self, new_value: bool) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_clrintpnd(new_value);
        setter
    }
    
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_w_ctrl) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_ctrl(new_value);
        setter
    }
    
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_w_arb) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_arb(new_value);
        setter
    }
    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_w_mask) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'a>(&'a mut self, new_value: bool) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_w_Update = C_CAN_canif1_cmdmsk_w_Update::new(self);
        setter.set_wr_rd(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_cmdmsk_w
/// `CANIF1_CMDMSK_W`: Message interface command mask - write direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_cmdmsk_w_Get {
    value: u32,
}

impl C_CAN_canif1_cmdmsk_w_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_cmdmsk_w) -> C_CAN_canif1_cmdmsk_w_Get {
        C_CAN_canif1_cmdmsk_w_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA_B` field: Access data bytes 4-7
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif1_cmdmsk_w_data_b {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_data_b::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_data_b::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DATA_A` field: Access data bytes 0-3
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif1_cmdmsk_w_data_a {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_data_a::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_data_a::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TXRQST` field: Access transmission request bit
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif1_cmdmsk_w_txrqst {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_txrqst::NoTransmissionRequest),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_txrqst::RequestTransmission),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CLRINTPND` field: This bit is ignored in the write direction.
    #[inline(always)]
    pub fn clrintpnd(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `CTRL` field: Access control bits
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif1_cmdmsk_w_ctrl {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_ctrl::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_ctrl::TransferControlBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ARB` field: Access arbitration bits
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif1_cmdmsk_w_arb {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_arb::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_arb::TransferIdentifierDIR_XTD_MSGVALBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MASK` field: Access mask bits
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif1_cmdmsk_w_mask {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_mask::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_w_mask::TransferIdentifierMASK_MDIR_MXTDBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WR_RD` field: Write transfer Transfer data from the selected message buffer registers to the message object addressed by the command request register CANIFn_CMDREQ.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_cmdmsk_w_Get { }


// Updater for C_CAN_canif1_cmdmsk_w
/// Updater for `CANIF1_CMDMSK_W` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_cmdmsk_w_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_cmdmsk_w,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_cmdmsk_w_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_cmdmsk_w_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_cmdmsk_w) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        C_CAN_canif1_cmdmsk_w_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_cmdmsk_w) -> C_CAN_canif1_cmdmsk_w_Update<'a> {
        C_CAN_canif1_cmdmsk_w_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_w_data_b) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_w_data_a) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_w_txrqst) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'b>(&'b mut self, new_value: bool) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_w_ctrl) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_w_arb) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_w_mask) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'b>(&'b mut self, new_value: bool) -> &'b mut C_CAN_canif1_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_w_data_b {
    /// Data bytes 4-7 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 4-7 to message object.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_w_data_a {
    /// Data bytes 0-3 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 0-3 to message object.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_w_txrqst {
    /// No transmission request. TXRQSRT bit unchanged in IF1/2_MCTRL. If a transmission is requested by programming this bit, the TXRQST bit in the CANIFn_MCTRL register is ignored.
    NoTransmissionRequest = 0,
    /// Request a transmission. Set the TXRQST bit IF1/2_MCTRL.
    RequestTransmission = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_w_ctrl {
    /// Control bits unchanged.
    Unchanged = 0,
    /// Transfer control bits to message object
    TransferControlBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_w_arb {
    /// Arbitration bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier, DIR, XTD, and MSGVAL bits to message object.
    TransferIdentifierDIR_XTD_MSGVALBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_w_mask {
    /// Mask bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier MASK + MDIR + MXTD to message object.
    TransferIdentifierMASK_MDIR_MXTDBits = 1,
    }







// Register CANIF2_CMDMSK_W implementation


/// Register `CANIF2_CMDMSK_W`: Message interface command mask - write direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_cmdmsk_w {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_cmdmsk_w { }

impl C_CAN_canif2_cmdmsk_w {
    
    // Getters
    /// Fetch the value of the `CANIF2_CMDMSK_W` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_cmdmsk_w_Get {
        C_CAN_canif2_cmdmsk_w_Get::new(self)
    }

    
    /// Get value of `DATA_B` field.
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif2_cmdmsk_w_data_b {
        C_CAN_canif2_cmdmsk_w_Get::new(self).data_b()
    }
    
    /// Get value of `DATA_A` field.
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif2_cmdmsk_w_data_a {
        C_CAN_canif2_cmdmsk_w_Get::new(self).data_a()
    }
    
    /// Get value of `TXRQST` field.
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif2_cmdmsk_w_txrqst {
        C_CAN_canif2_cmdmsk_w_Get::new(self).txrqst()
    }
    
    /// Get value of `CLRINTPND` field.
    #[inline(always)]
    pub fn clrintpnd(&self) -> bool {
        C_CAN_canif2_cmdmsk_w_Get::new(self).clrintpnd()
    }
    
    /// Get value of `CTRL` field.
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif2_cmdmsk_w_ctrl {
        C_CAN_canif2_cmdmsk_w_Get::new(self).ctrl()
    }
    
    /// Get value of `ARB` field.
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif2_cmdmsk_w_arb {
        C_CAN_canif2_cmdmsk_w_Get::new(self).arb()
    }
    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif2_cmdmsk_w_mask {
        C_CAN_canif2_cmdmsk_w_Get::new(self).mask()
    }
    
    /// Get value of `WR_RD` field.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        C_CAN_canif2_cmdmsk_w_Get::new(self).wr_rd()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_CMDMSK_W` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_cmdmsk_w_Update {
        C_CAN_canif2_cmdmsk_w_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_w_data_b) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_data_b(new_value);
        setter
    }
    
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_w_data_a) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_data_a(new_value);
        setter
    }
    
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_w_txrqst) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_txrqst(new_value);
        setter
    }
    
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'a>(&'a mut self, new_value: bool) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_clrintpnd(new_value);
        setter
    }
    
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_w_ctrl) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_ctrl(new_value);
        setter
    }
    
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_w_arb) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_arb(new_value);
        setter
    }
    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_w_mask) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'a>(&'a mut self, new_value: bool) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_w_Update = C_CAN_canif2_cmdmsk_w_Update::new(self);
        setter.set_wr_rd(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_cmdmsk_w
/// `CANIF2_CMDMSK_W`: Message interface command mask - write direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_cmdmsk_w_Get {
    value: u32,
}

impl C_CAN_canif2_cmdmsk_w_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_cmdmsk_w) -> C_CAN_canif2_cmdmsk_w_Get {
        C_CAN_canif2_cmdmsk_w_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA_B` field: Access data bytes 4-7
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif2_cmdmsk_w_data_b {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_data_b::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_data_b::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DATA_A` field: Access data bytes 0-3
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif2_cmdmsk_w_data_a {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_data_a::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_data_a::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TXRQST` field: Access transmission request bit
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif2_cmdmsk_w_txrqst {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_txrqst::NoTransmissionRequest),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_txrqst::RequestTransmission),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CLRINTPND` field: This bit is ignored in the write direction.
    #[inline(always)]
    pub fn clrintpnd(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `CTRL` field: Access control bits
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif2_cmdmsk_w_ctrl {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_ctrl::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_ctrl::TransferControlBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ARB` field: Access arbitration bits
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif2_cmdmsk_w_arb {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_arb::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_arb::TransferIdentifierDIR_XTD_MSGVALBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MASK` field: Access mask bits
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif2_cmdmsk_w_mask {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_mask::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_w_mask::TransferIdentifierMASK_MDIR_MXTDBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WR_RD` field: Write transfer Transfer data from the selected message buffer registers to the message object addressed by the command request register CANIFn_CMDREQ.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_cmdmsk_w_Get { }


// Updater for C_CAN_canif2_cmdmsk_w
/// Updater for `CANIF2_CMDMSK_W` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_cmdmsk_w_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_cmdmsk_w,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_cmdmsk_w_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_cmdmsk_w_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_cmdmsk_w) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        C_CAN_canif2_cmdmsk_w_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_cmdmsk_w) -> C_CAN_canif2_cmdmsk_w_Update<'a> {
        C_CAN_canif2_cmdmsk_w_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_w_data_b) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_w_data_a) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_w_txrqst) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'b>(&'b mut self, new_value: bool) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_w_ctrl) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_w_arb) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_w_mask) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'b>(&'b mut self, new_value: bool) -> &'b mut C_CAN_canif2_cmdmsk_w_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_w_data_b {
    /// Data bytes 4-7 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 4-7 to message object.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_w_data_a {
    /// Data bytes 0-3 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 0-3 to message object.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_w_txrqst {
    /// No transmission request. TXRQSRT bit unchanged in IF1/2_MCTRL. If a transmission is requested by programming this bit, the TXRQST bit in the CANIFn_MCTRL register is ignored.
    NoTransmissionRequest = 0,
    /// Request a transmission. Set the TXRQST bit IF1/2_MCTRL.
    RequestTransmission = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_w_ctrl {
    /// Control bits unchanged.
    Unchanged = 0,
    /// Transfer control bits to message object
    TransferControlBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_w_arb {
    /// Arbitration bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier, DIR, XTD, and MSGVAL bits to message object.
    TransferIdentifierDIR_XTD_MSGVALBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_w_mask {
    /// Mask bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier MASK + MDIR + MXTD to message object.
    TransferIdentifierMASK_MDIR_MXTDBits = 1,
    }







// Register CANIF1_CMDMSK_R implementation


/// Register `CANIF1_CMDMSK_R`: Message interface  command mask - read direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_cmdmsk_r {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_cmdmsk_r { }

impl C_CAN_canif1_cmdmsk_r {
    
    // Getters
    /// Fetch the value of the `CANIF1_CMDMSK_R` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_cmdmsk_r_Get {
        C_CAN_canif1_cmdmsk_r_Get::new(self)
    }

    
    /// Get value of `DATA_B` field.
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif1_cmdmsk_r_data_b {
        C_CAN_canif1_cmdmsk_r_Get::new(self).data_b()
    }
    
    /// Get value of `DATA_A` field.
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif1_cmdmsk_r_data_a {
        C_CAN_canif1_cmdmsk_r_Get::new(self).data_a()
    }
    
    /// Get value of `NEWDAT` field.
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif1_cmdmsk_r_newdat {
        C_CAN_canif1_cmdmsk_r_Get::new(self).newdat()
    }
    
    /// Get value of `CLRINTPND` field.
    #[inline(always)]
    pub fn clrintpnd(&self) -> C_CAN_canif1_cmdmsk_r_clrintpnd {
        C_CAN_canif1_cmdmsk_r_Get::new(self).clrintpnd()
    }
    
    /// Get value of `CTRL` field.
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif1_cmdmsk_r_ctrl {
        C_CAN_canif1_cmdmsk_r_Get::new(self).ctrl()
    }
    
    /// Get value of `ARB` field.
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif1_cmdmsk_r_arb {
        C_CAN_canif1_cmdmsk_r_Get::new(self).arb()
    }
    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif1_cmdmsk_r_mask {
        C_CAN_canif1_cmdmsk_r_Get::new(self).mask()
    }
    
    /// Get value of `WR_RD` field.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        C_CAN_canif1_cmdmsk_r_Get::new(self).wr_rd()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_CMDMSK_R` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_cmdmsk_r_Update {
        C_CAN_canif1_cmdmsk_r_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_r_data_b) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_data_b(new_value);
        setter
    }
    
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_r_data_a) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_data_a(new_value);
        setter
    }
    
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_r_newdat) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_newdat(new_value);
        setter
    }
    
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_r_clrintpnd) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_clrintpnd(new_value);
        setter
    }
    
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_r_ctrl) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_ctrl(new_value);
        setter
    }
    
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_r_arb) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_arb(new_value);
        setter
    }
    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: C_CAN_canif1_cmdmsk_r_mask) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'a>(&'a mut self, new_value: bool) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif1_cmdmsk_r_Update = C_CAN_canif1_cmdmsk_r_Update::new(self);
        setter.set_wr_rd(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_cmdmsk_r
/// `CANIF1_CMDMSK_R`: Message interface  command mask - read direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_cmdmsk_r_Get {
    value: u32,
}

impl C_CAN_canif1_cmdmsk_r_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_cmdmsk_r) -> C_CAN_canif1_cmdmsk_r_Get {
        C_CAN_canif1_cmdmsk_r_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA_B` field: Access data bytes 4-7
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif1_cmdmsk_r_data_b {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_data_b::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_data_b::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DATA_A` field: Access data bytes 0-3
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif1_cmdmsk_r_data_a {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_data_a::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_data_a::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NEWDAT` field: Access new data bit
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif1_cmdmsk_r_newdat {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_newdat::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_newdat::ClearBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CLRINTPND` field: Clear interrupt pending bit.
    #[inline(always)]
    pub fn clrintpnd(&self) -> C_CAN_canif1_cmdmsk_r_clrintpnd {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_clrintpnd::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_clrintpnd::ClearBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CTRL` field: Access control bits
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif1_cmdmsk_r_ctrl {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_ctrl::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_ctrl::TransferControlBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ARB` field: Access arbitration bits
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif1_cmdmsk_r_arb {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_arb::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_arb::TransferIdentifierDIR_XTD_MSGVALBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MASK` field: Access mask bits
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif1_cmdmsk_r_mask {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_mask::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif1_cmdmsk_r_mask::TransferIdentifierMASK_MDIR_MXTDBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WR_RD` field: Read transfer Transfer data from the message object addressed by the command request register to the selected message buffer registers CANIFn_CMDREQ.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_cmdmsk_r_Get { }


// Updater for C_CAN_canif1_cmdmsk_r
/// Updater for `CANIF1_CMDMSK_R` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_cmdmsk_r_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_cmdmsk_r,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_cmdmsk_r_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_cmdmsk_r_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_cmdmsk_r) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        C_CAN_canif1_cmdmsk_r_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_cmdmsk_r) -> C_CAN_canif1_cmdmsk_r_Update<'a> {
        C_CAN_canif1_cmdmsk_r_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_r_data_b) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_r_data_a) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_r_newdat) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_r_clrintpnd) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_r_ctrl) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_r_arb) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: C_CAN_canif1_cmdmsk_r_mask) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'b>(&'b mut self, new_value: bool) -> &'b mut C_CAN_canif1_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_r_data_b {
    /// Data bytes 4-7 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 4-7 to IFx message buffer register.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_r_data_a {
    /// Data bytes 0-3 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 0-3 to IFx message buffer.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_r_newdat {
    /// NEWDAT bit remains unchanged. A read access to a message object can be combined with the reset of the control bits INTPND and NEWDAT in IF1/2_MCTRL. The values of these bits transferred to the IFx Message Control Register always reflect the status before resetting these bits.
    Unchanged = 0,
    /// Clear NEWDAT bit in the message object.
    ClearBit = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_r_clrintpnd {
    /// INTPND bit remains unchanged.
    Unchanged = 0,
    /// Clear INTPND bit in the message object.
    ClearBit = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_r_ctrl {
    /// Control bits unchanged.
    Unchanged = 0,
    /// Transfer control bits to IFx message buffer.
    TransferControlBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_r_arb {
    /// Arbitration bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier, DIR, XTD, and MSGVAL bits to IFx message buffer register.
    TransferIdentifierDIR_XTD_MSGVALBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_cmdmsk_r_mask {
    /// Mask bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier MASK + MDIR + MXTD to IFx message buffer register.
    TransferIdentifierMASK_MDIR_MXTDBits = 1,
    }







// Register CANIF2_CMDMSK_R implementation


/// Register `CANIF2_CMDMSK_R`: Message interface  command mask - read direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_cmdmsk_r {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_cmdmsk_r { }

impl C_CAN_canif2_cmdmsk_r {
    
    // Getters
    /// Fetch the value of the `CANIF2_CMDMSK_R` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_cmdmsk_r_Get {
        C_CAN_canif2_cmdmsk_r_Get::new(self)
    }

    
    /// Get value of `DATA_B` field.
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif2_cmdmsk_r_data_b {
        C_CAN_canif2_cmdmsk_r_Get::new(self).data_b()
    }
    
    /// Get value of `DATA_A` field.
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif2_cmdmsk_r_data_a {
        C_CAN_canif2_cmdmsk_r_Get::new(self).data_a()
    }
    
    /// Get value of `NEWDAT` field.
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif2_cmdmsk_r_newdat {
        C_CAN_canif2_cmdmsk_r_Get::new(self).newdat()
    }
    
    /// Get value of `CLRINTPND` field.
    #[inline(always)]
    pub fn clrintpnd(&self) -> C_CAN_canif2_cmdmsk_r_clrintpnd {
        C_CAN_canif2_cmdmsk_r_Get::new(self).clrintpnd()
    }
    
    /// Get value of `CTRL` field.
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif2_cmdmsk_r_ctrl {
        C_CAN_canif2_cmdmsk_r_Get::new(self).ctrl()
    }
    
    /// Get value of `ARB` field.
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif2_cmdmsk_r_arb {
        C_CAN_canif2_cmdmsk_r_Get::new(self).arb()
    }
    
    /// Get value of `MASK` field.
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif2_cmdmsk_r_mask {
        C_CAN_canif2_cmdmsk_r_Get::new(self).mask()
    }
    
    /// Get value of `WR_RD` field.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        C_CAN_canif2_cmdmsk_r_Get::new(self).wr_rd()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_CMDMSK_R` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_cmdmsk_r_Update {
        C_CAN_canif2_cmdmsk_r_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_r_data_b) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_data_b(new_value);
        setter
    }
    
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_r_data_a) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_data_a(new_value);
        setter
    }
    
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_r_newdat) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_newdat(new_value);
        setter
    }
    
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_r_clrintpnd) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_clrintpnd(new_value);
        setter
    }
    
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_r_ctrl) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_ctrl(new_value);
        setter
    }
    
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_r_arb) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_arb(new_value);
        setter
    }
    
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'a>(&'a mut self, new_value: C_CAN_canif2_cmdmsk_r_mask) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_mask(new_value);
        setter
    }
    
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'a>(&'a mut self, new_value: bool) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        let mut setter: C_CAN_canif2_cmdmsk_r_Update = C_CAN_canif2_cmdmsk_r_Update::new(self);
        setter.set_wr_rd(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_cmdmsk_r
/// `CANIF2_CMDMSK_R`: Message interface  command mask - read direction
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_cmdmsk_r_Get {
    value: u32,
}

impl C_CAN_canif2_cmdmsk_r_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_cmdmsk_r) -> C_CAN_canif2_cmdmsk_r_Get {
        C_CAN_canif2_cmdmsk_r_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA_B` field: Access data bytes 4-7
    #[inline(always)]
    pub fn data_b(&self) -> C_CAN_canif2_cmdmsk_r_data_b {
        match (self.value >> 0) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_data_b::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_data_b::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `DATA_A` field: Access data bytes 0-3
    #[inline(always)]
    pub fn data_a(&self) -> C_CAN_canif2_cmdmsk_r_data_a {
        match (self.value >> 1) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_data_a::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_data_a::Transfer),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NEWDAT` field: Access new data bit
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif2_cmdmsk_r_newdat {
        match (self.value >> 2) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_newdat::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_newdat::ClearBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CLRINTPND` field: Clear interrupt pending bit.
    #[inline(always)]
    pub fn clrintpnd(&self) -> C_CAN_canif2_cmdmsk_r_clrintpnd {
        match (self.value >> 3) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_clrintpnd::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_clrintpnd::ClearBit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `CTRL` field: Access control bits
    #[inline(always)]
    pub fn ctrl(&self) -> C_CAN_canif2_cmdmsk_r_ctrl {
        match (self.value >> 4) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_ctrl::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_ctrl::TransferControlBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `ARB` field: Access arbitration bits
    #[inline(always)]
    pub fn arb(&self) -> C_CAN_canif2_cmdmsk_r_arb {
        match (self.value >> 5) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_arb::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_arb::TransferIdentifierDIR_XTD_MSGVALBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MASK` field: Access mask bits
    #[inline(always)]
    pub fn mask(&self) -> C_CAN_canif2_cmdmsk_r_mask {
        match (self.value >> 6) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_mask::Unchanged),
            1 => ::core::option::Option::Some(C_CAN_canif2_cmdmsk_r_mask::TransferIdentifierMASK_MDIR_MXTDBits),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `WR_RD` field: Read transfer Transfer data from the message object addressed by the command request register to the selected message buffer registers CANIFn_CMDREQ.
    #[inline(always)]
    pub fn wr_rd(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_cmdmsk_r_Get { }


// Updater for C_CAN_canif2_cmdmsk_r
/// Updater for `CANIF2_CMDMSK_R` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_cmdmsk_r_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_cmdmsk_r,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_cmdmsk_r_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_cmdmsk_r_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_cmdmsk_r) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        C_CAN_canif2_cmdmsk_r_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_cmdmsk_r) -> C_CAN_canif2_cmdmsk_r_Update<'a> {
        C_CAN_canif2_cmdmsk_r_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA_B` field.
    #[inline(always)]
    pub fn set_data_b<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_r_data_b) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `DATA_A` field.
    #[inline(always)]
    pub fn set_data_a<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_r_data_a) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_r_newdat) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CLRINTPND` field.
    #[inline(always)]
    pub fn set_clrintpnd<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_r_clrintpnd) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CTRL` field.
    #[inline(always)]
    pub fn set_ctrl<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_r_ctrl) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `ARB` field.
    #[inline(always)]
    pub fn set_arb<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_r_arb) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `MASK` field.
    #[inline(always)]
    pub fn set_mask<'b>(&'b mut self, new_value: C_CAN_canif2_cmdmsk_r_mask) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `WR_RD` field.
    #[inline(always)]
    pub fn set_wr_rd<'b>(&'b mut self, new_value: bool) -> &'b mut C_CAN_canif2_cmdmsk_r_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_r_data_b {
    /// Data bytes 4-7 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 4-7 to IFx message buffer register.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_r_data_a {
    /// Data bytes 0-3 unchanged.
    Unchanged = 0,
    /// Transfer data bytes 0-3 to IFx message buffer.
    Transfer = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_r_newdat {
    /// NEWDAT bit remains unchanged. A read access to a message object can be combined with the reset of the control bits INTPND and NEWDAT in IF1/2_MCTRL. The values of these bits transferred to the IFx Message Control Register always reflect the status before resetting these bits.
    Unchanged = 0,
    /// Clear NEWDAT bit in the message object.
    ClearBit = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_r_clrintpnd {
    /// INTPND bit remains unchanged.
    Unchanged = 0,
    /// Clear INTPND bit in the message object.
    ClearBit = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_r_ctrl {
    /// Control bits unchanged.
    Unchanged = 0,
    /// Transfer control bits to IFx message buffer.
    TransferControlBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_r_arb {
    /// Arbitration bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier, DIR, XTD, and MSGVAL bits to IFx message buffer register.
    TransferIdentifierDIR_XTD_MSGVALBits = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_cmdmsk_r_mask {
    /// Mask bits unchanged.
    Unchanged = 0,
    /// Transfer Identifier MASK + MDIR + MXTD to IFx message buffer register.
    TransferIdentifierMASK_MDIR_MXTDBits = 1,
    }







// Register CANIF1_MSK1 implementation


/// Register `CANIF1_MSK1`: Message interface 1 mask 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_msk1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_msk1 { }

impl C_CAN_canif1_msk1 {
    
    // Getters
    /// Fetch the value of the `CANIF1_MSK1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_msk1_Get {
        C_CAN_canif1_msk1_Get::new(self)
    }

    
    /// Get value of `MSK_15_0` field.
    #[inline(always)]
    pub fn msk_15_0(&self) -> C_CAN_canif1_msk1_msk_15_0 {
        C_CAN_canif1_msk1_Get::new(self).msk_15_0()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_MSK1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_msk1_Update {
        C_CAN_canif1_msk1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MSK_15_0` field.
    #[inline(always)]
    pub fn set_msk_15_0<'a>(&'a mut self, new_value: C_CAN_canif1_msk1_msk_15_0) -> C_CAN_canif1_msk1_Update<'a> {
        let mut setter: C_CAN_canif1_msk1_Update = C_CAN_canif1_msk1_Update::new(self);
        setter.set_msk_15_0(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_msk1
/// `CANIF1_MSK1`: Message interface 1 mask 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_msk1_Get {
    value: u32,
}

impl C_CAN_canif1_msk1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_msk1) -> C_CAN_canif1_msk1_Get {
        C_CAN_canif1_msk1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MSK_15_0` field: Identifier mask
    #[inline(always)]
    pub fn msk_15_0(&self) -> C_CAN_canif1_msk1_msk_15_0 {
        match (self.value >> 0) & 65535 {
            0 => ::core::option::Option::Some(C_CAN_canif1_msk1_msk_15_0::NoInhibit),
            1 => ::core::option::Option::Some(C_CAN_canif1_msk1_msk_15_0::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_msk1_Get { }


// Updater for C_CAN_canif1_msk1
/// Updater for `CANIF1_MSK1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_msk1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_msk1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_msk1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_msk1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_msk1) -> C_CAN_canif1_msk1_Update<'a> {
        C_CAN_canif1_msk1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_msk1) -> C_CAN_canif1_msk1_Update<'a> {
        C_CAN_canif1_msk1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MSK_15_0` field.
    #[inline(always)]
    pub fn set_msk_15_0<'b>(&'b mut self, new_value: C_CAN_canif1_msk1_msk_15_0) -> &'b mut C_CAN_canif1_msk1_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_msk1_msk_15_0 {
    /// The corresponding bit in the identifier of the message can not inhibit the match in the acceptance filtering.
    NoInhibit = 0,
    /// The corresponding identifier bit is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }







// Register CANIF2_MSK1 implementation


/// Register `CANIF2_MSK1`: Message interface 1 mask 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_msk1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_msk1 { }

impl C_CAN_canif2_msk1 {
    
    // Getters
    /// Fetch the value of the `CANIF2_MSK1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_msk1_Get {
        C_CAN_canif2_msk1_Get::new(self)
    }

    
    /// Get value of `MSK_15_0` field.
    #[inline(always)]
    pub fn msk_15_0(&self) -> C_CAN_canif2_msk1_msk_15_0 {
        C_CAN_canif2_msk1_Get::new(self).msk_15_0()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_MSK1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_msk1_Update {
        C_CAN_canif2_msk1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MSK_15_0` field.
    #[inline(always)]
    pub fn set_msk_15_0<'a>(&'a mut self, new_value: C_CAN_canif2_msk1_msk_15_0) -> C_CAN_canif2_msk1_Update<'a> {
        let mut setter: C_CAN_canif2_msk1_Update = C_CAN_canif2_msk1_Update::new(self);
        setter.set_msk_15_0(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_msk1
/// `CANIF2_MSK1`: Message interface 1 mask 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_msk1_Get {
    value: u32,
}

impl C_CAN_canif2_msk1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_msk1) -> C_CAN_canif2_msk1_Get {
        C_CAN_canif2_msk1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MSK_15_0` field: Identifier mask
    #[inline(always)]
    pub fn msk_15_0(&self) -> C_CAN_canif2_msk1_msk_15_0 {
        match (self.value >> 0) & 65535 {
            0 => ::core::option::Option::Some(C_CAN_canif2_msk1_msk_15_0::NoInhibit),
            1 => ::core::option::Option::Some(C_CAN_canif2_msk1_msk_15_0::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_msk1_Get { }


// Updater for C_CAN_canif2_msk1
/// Updater for `CANIF2_MSK1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_msk1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_msk1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_msk1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_msk1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_msk1) -> C_CAN_canif2_msk1_Update<'a> {
        C_CAN_canif2_msk1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_msk1) -> C_CAN_canif2_msk1_Update<'a> {
        C_CAN_canif2_msk1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MSK_15_0` field.
    #[inline(always)]
    pub fn set_msk_15_0<'b>(&'b mut self, new_value: C_CAN_canif2_msk1_msk_15_0) -> &'b mut C_CAN_canif2_msk1_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_msk1_msk_15_0 {
    /// The corresponding bit in the identifier of the message can not inhibit the match in the acceptance filtering.
    NoInhibit = 0,
    /// The corresponding identifier bit is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }







// Register CANIF1_MSK2 implementation


/// Register `CANIF1_MSK2`: Message interface 1 mask 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_msk2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_msk2 { }

impl C_CAN_canif1_msk2 {
    
    // Getters
    /// Fetch the value of the `CANIF1_MSK2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_msk2_Get {
        C_CAN_canif1_msk2_Get::new(self)
    }

    
    /// Get value of `MSK_28_16` field.
    #[inline(always)]
    pub fn msk_28_16(&self) -> C_CAN_canif1_msk2_msk_28_16 {
        C_CAN_canif1_msk2_Get::new(self).msk_28_16()
    }
    
    /// Get value of `MDIR` field.
    #[inline(always)]
    pub fn mdir(&self) -> C_CAN_canif1_msk2_mdir {
        C_CAN_canif1_msk2_Get::new(self).mdir()
    }
    
    /// Get value of `MXTD` field.
    #[inline(always)]
    pub fn mxtd(&self) -> C_CAN_canif1_msk2_mxtd {
        C_CAN_canif1_msk2_Get::new(self).mxtd()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_MSK2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_msk2_Update {
        C_CAN_canif1_msk2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MSK_28_16` field.
    #[inline(always)]
    pub fn set_msk_28_16<'a>(&'a mut self, new_value: C_CAN_canif1_msk2_msk_28_16) -> C_CAN_canif1_msk2_Update<'a> {
        let mut setter: C_CAN_canif1_msk2_Update = C_CAN_canif1_msk2_Update::new(self);
        setter.set_msk_28_16(new_value);
        setter
    }
    
    /// Set value of `MDIR` field.
    #[inline(always)]
    pub fn set_mdir<'a>(&'a mut self, new_value: C_CAN_canif1_msk2_mdir) -> C_CAN_canif1_msk2_Update<'a> {
        let mut setter: C_CAN_canif1_msk2_Update = C_CAN_canif1_msk2_Update::new(self);
        setter.set_mdir(new_value);
        setter
    }
    
    /// Set value of `MXTD` field.
    #[inline(always)]
    pub fn set_mxtd<'a>(&'a mut self, new_value: C_CAN_canif1_msk2_mxtd) -> C_CAN_canif1_msk2_Update<'a> {
        let mut setter: C_CAN_canif1_msk2_Update = C_CAN_canif1_msk2_Update::new(self);
        setter.set_mxtd(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_msk2
/// `CANIF1_MSK2`: Message interface 1 mask 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_msk2_Get {
    value: u32,
}

impl C_CAN_canif1_msk2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_msk2) -> C_CAN_canif1_msk2_Get {
        C_CAN_canif1_msk2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MSK_28_16` field: Identifier mask
    #[inline(always)]
    pub fn msk_28_16(&self) -> C_CAN_canif1_msk2_msk_28_16 {
        match (self.value >> 0) & 8191 {
            0 => ::core::option::Option::Some(C_CAN_canif1_msk2_msk_28_16::NoInhibit),
            1 => ::core::option::Option::Some(C_CAN_canif1_msk2_msk_28_16::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MDIR` field: Mask message direction
    #[inline(always)]
    pub fn mdir(&self) -> C_CAN_canif1_msk2_mdir {
        match (self.value >> 14) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_msk2_mdir::NoEffect),
            1 => ::core::option::Option::Some(C_CAN_canif1_msk2_mdir::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MXTD` field: Mask extend identifier
    #[inline(always)]
    pub fn mxtd(&self) -> C_CAN_canif1_msk2_mxtd {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_msk2_mxtd::NoEffect),
            1 => ::core::option::Option::Some(C_CAN_canif1_msk2_mxtd::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_msk2_Get { }


// Updater for C_CAN_canif1_msk2
/// Updater for `CANIF1_MSK2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_msk2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_msk2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_msk2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_msk2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_msk2) -> C_CAN_canif1_msk2_Update<'a> {
        C_CAN_canif1_msk2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_msk2) -> C_CAN_canif1_msk2_Update<'a> {
        C_CAN_canif1_msk2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MSK_28_16` field.
    #[inline(always)]
    pub fn set_msk_28_16<'b>(&'b mut self, new_value: C_CAN_canif1_msk2_msk_28_16) -> &'b mut C_CAN_canif1_msk2_Update<'a> {
        self.value = (self.value & !(8191 << 0))
                   | ((new_value as u32) & 8191) << 0;
        self.mask |= 8191 << 0;
        self
    }
    /// Set value of `MDIR` field.
    #[inline(always)]
    pub fn set_mdir<'b>(&'b mut self, new_value: C_CAN_canif1_msk2_mdir) -> &'b mut C_CAN_canif1_msk2_Update<'a> {
        self.value = (self.value & !(1 << 14))
                   | ((new_value as u32) & 1) << 14;
        self.mask |= 1 << 14;
        self
    }
    /// Set value of `MXTD` field.
    #[inline(always)]
    pub fn set_mxtd<'b>(&'b mut self, new_value: C_CAN_canif1_msk2_mxtd) -> &'b mut C_CAN_canif1_msk2_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_msk2_msk_28_16 {
    /// The corresponding bit in the identifier of the message can not inhibit the match in the acceptance filtering.
    NoInhibit = 0,
    /// The corresponding identifier bit is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_msk2_mdir {
    /// The message direction bit (DIR) has no effect on acceptance filtering.
    NoEffect = 0,
    /// The message direction bit (DIR) is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_msk2_mxtd {
    /// The extended identifier bit (XTD) has no effect on acceptance filtering.
    NoEffect = 0,
    /// The extended identifier bit (XTD) is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }







// Register CANIF2_MSK2 implementation


/// Register `CANIF2_MSK2`: Message interface 1 mask 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_msk2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_msk2 { }

impl C_CAN_canif2_msk2 {
    
    // Getters
    /// Fetch the value of the `CANIF2_MSK2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_msk2_Get {
        C_CAN_canif2_msk2_Get::new(self)
    }

    
    /// Get value of `MSK_28_16` field.
    #[inline(always)]
    pub fn msk_28_16(&self) -> C_CAN_canif2_msk2_msk_28_16 {
        C_CAN_canif2_msk2_Get::new(self).msk_28_16()
    }
    
    /// Get value of `MDIR` field.
    #[inline(always)]
    pub fn mdir(&self) -> C_CAN_canif2_msk2_mdir {
        C_CAN_canif2_msk2_Get::new(self).mdir()
    }
    
    /// Get value of `MXTD` field.
    #[inline(always)]
    pub fn mxtd(&self) -> C_CAN_canif2_msk2_mxtd {
        C_CAN_canif2_msk2_Get::new(self).mxtd()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_MSK2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_msk2_Update {
        C_CAN_canif2_msk2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MSK_28_16` field.
    #[inline(always)]
    pub fn set_msk_28_16<'a>(&'a mut self, new_value: C_CAN_canif2_msk2_msk_28_16) -> C_CAN_canif2_msk2_Update<'a> {
        let mut setter: C_CAN_canif2_msk2_Update = C_CAN_canif2_msk2_Update::new(self);
        setter.set_msk_28_16(new_value);
        setter
    }
    
    /// Set value of `MDIR` field.
    #[inline(always)]
    pub fn set_mdir<'a>(&'a mut self, new_value: C_CAN_canif2_msk2_mdir) -> C_CAN_canif2_msk2_Update<'a> {
        let mut setter: C_CAN_canif2_msk2_Update = C_CAN_canif2_msk2_Update::new(self);
        setter.set_mdir(new_value);
        setter
    }
    
    /// Set value of `MXTD` field.
    #[inline(always)]
    pub fn set_mxtd<'a>(&'a mut self, new_value: C_CAN_canif2_msk2_mxtd) -> C_CAN_canif2_msk2_Update<'a> {
        let mut setter: C_CAN_canif2_msk2_Update = C_CAN_canif2_msk2_Update::new(self);
        setter.set_mxtd(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_msk2
/// `CANIF2_MSK2`: Message interface 1 mask 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_msk2_Get {
    value: u32,
}

impl C_CAN_canif2_msk2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_msk2) -> C_CAN_canif2_msk2_Get {
        C_CAN_canif2_msk2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MSK_28_16` field: Identifier mask
    #[inline(always)]
    pub fn msk_28_16(&self) -> C_CAN_canif2_msk2_msk_28_16 {
        match (self.value >> 0) & 8191 {
            0 => ::core::option::Option::Some(C_CAN_canif2_msk2_msk_28_16::NoInhibit),
            1 => ::core::option::Option::Some(C_CAN_canif2_msk2_msk_28_16::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MDIR` field: Mask message direction
    #[inline(always)]
    pub fn mdir(&self) -> C_CAN_canif2_msk2_mdir {
        match (self.value >> 14) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_msk2_mdir::NoEffect),
            1 => ::core::option::Option::Some(C_CAN_canif2_msk2_mdir::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MXTD` field: Mask extend identifier
    #[inline(always)]
    pub fn mxtd(&self) -> C_CAN_canif2_msk2_mxtd {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_msk2_mxtd::NoEffect),
            1 => ::core::option::Option::Some(C_CAN_canif2_msk2_mxtd::AcceptanceFiltering),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_msk2_Get { }


// Updater for C_CAN_canif2_msk2
/// Updater for `CANIF2_MSK2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_msk2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_msk2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_msk2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_msk2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_msk2) -> C_CAN_canif2_msk2_Update<'a> {
        C_CAN_canif2_msk2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_msk2) -> C_CAN_canif2_msk2_Update<'a> {
        C_CAN_canif2_msk2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MSK_28_16` field.
    #[inline(always)]
    pub fn set_msk_28_16<'b>(&'b mut self, new_value: C_CAN_canif2_msk2_msk_28_16) -> &'b mut C_CAN_canif2_msk2_Update<'a> {
        self.value = (self.value & !(8191 << 0))
                   | ((new_value as u32) & 8191) << 0;
        self.mask |= 8191 << 0;
        self
    }
    /// Set value of `MDIR` field.
    #[inline(always)]
    pub fn set_mdir<'b>(&'b mut self, new_value: C_CAN_canif2_msk2_mdir) -> &'b mut C_CAN_canif2_msk2_Update<'a> {
        self.value = (self.value & !(1 << 14))
                   | ((new_value as u32) & 1) << 14;
        self.mask |= 1 << 14;
        self
    }
    /// Set value of `MXTD` field.
    #[inline(always)]
    pub fn set_mxtd<'b>(&'b mut self, new_value: C_CAN_canif2_msk2_mxtd) -> &'b mut C_CAN_canif2_msk2_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_msk2_msk_28_16 {
    /// The corresponding bit in the identifier of the message can not inhibit the match in the acceptance filtering.
    NoInhibit = 0,
    /// The corresponding identifier bit is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_msk2_mdir {
    /// The message direction bit (DIR) has no effect on acceptance filtering.
    NoEffect = 0,
    /// The message direction bit (DIR) is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_msk2_mxtd {
    /// The extended identifier bit (XTD) has no effect on acceptance filtering.
    NoEffect = 0,
    /// The extended identifier bit (XTD) is used for acceptance filtering.
    AcceptanceFiltering = 1,
    }







// Register CANIF1_ARB1 implementation


/// Register `CANIF1_ARB1`: Message interface 1 arbitration 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_arb1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_arb1 { }

impl C_CAN_canif1_arb1 {
    
    // Getters
    /// Fetch the value of the `CANIF1_ARB1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_arb1_Get {
        C_CAN_canif1_arb1_Get::new(self)
    }

    
    /// Get value of `ID_15_0` field.
    #[inline(always)]
    pub fn id_15_0(&self) -> u32 {
        C_CAN_canif1_arb1_Get::new(self).id_15_0()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_ARB1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_arb1_Update {
        C_CAN_canif1_arb1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ID_15_0` field.
    #[inline(always)]
    pub fn set_id_15_0<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_arb1_Update<'a> {
        let mut setter: C_CAN_canif1_arb1_Update = C_CAN_canif1_arb1_Update::new(self);
        setter.set_id_15_0(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_arb1
/// `CANIF1_ARB1`: Message interface 1 arbitration 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_arb1_Get {
    value: u32,
}

impl C_CAN_canif1_arb1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_arb1) -> C_CAN_canif1_arb1_Get {
        C_CAN_canif1_arb1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ID_15_0` field: Message identifier  29-bit identifier (extended frame) 11-bit identifier (standard frame)
    #[inline(always)]
    pub fn id_15_0(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_arb1_Get { }


// Updater for C_CAN_canif1_arb1
/// Updater for `CANIF1_ARB1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_arb1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_arb1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_arb1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_arb1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_arb1) -> C_CAN_canif1_arb1_Update<'a> {
        C_CAN_canif1_arb1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_arb1) -> C_CAN_canif1_arb1_Update<'a> {
        C_CAN_canif1_arb1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ID_15_0` field.
    #[inline(always)]
    pub fn set_id_15_0<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_arb1_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF2_ARB1 implementation


/// Register `CANIF2_ARB1`: Message interface 1 arbitration 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_arb1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_arb1 { }

impl C_CAN_canif2_arb1 {
    
    // Getters
    /// Fetch the value of the `CANIF2_ARB1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_arb1_Get {
        C_CAN_canif2_arb1_Get::new(self)
    }

    
    /// Get value of `ID_15_0` field.
    #[inline(always)]
    pub fn id_15_0(&self) -> u32 {
        C_CAN_canif2_arb1_Get::new(self).id_15_0()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_ARB1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_arb1_Update {
        C_CAN_canif2_arb1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ID_15_0` field.
    #[inline(always)]
    pub fn set_id_15_0<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_arb1_Update<'a> {
        let mut setter: C_CAN_canif2_arb1_Update = C_CAN_canif2_arb1_Update::new(self);
        setter.set_id_15_0(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_arb1
/// `CANIF2_ARB1`: Message interface 1 arbitration 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_arb1_Get {
    value: u32,
}

impl C_CAN_canif2_arb1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_arb1) -> C_CAN_canif2_arb1_Get {
        C_CAN_canif2_arb1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ID_15_0` field: Message identifier  29-bit identifier (extended frame) 11-bit identifier (standard frame)
    #[inline(always)]
    pub fn id_15_0(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_arb1_Get { }


// Updater for C_CAN_canif2_arb1
/// Updater for `CANIF2_ARB1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_arb1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_arb1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_arb1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_arb1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_arb1) -> C_CAN_canif2_arb1_Update<'a> {
        C_CAN_canif2_arb1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_arb1) -> C_CAN_canif2_arb1_Update<'a> {
        C_CAN_canif2_arb1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ID_15_0` field.
    #[inline(always)]
    pub fn set_id_15_0<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_arb1_Update<'a> {
        self.value = (self.value & !(65535 << 0))
                   | ((new_value as u32) & 65535) << 0;
        self.mask |= 65535 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF1_ARB2 implementation


/// Register `CANIF1_ARB2`: Message interface 1 arbitration 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_arb2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_arb2 { }

impl C_CAN_canif1_arb2 {
    
    // Getters
    /// Fetch the value of the `CANIF1_ARB2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_arb2_Get {
        C_CAN_canif1_arb2_Get::new(self)
    }

    
    /// Get value of `ID_28_16` field.
    #[inline(always)]
    pub fn id_28_16(&self) -> u32 {
        C_CAN_canif1_arb2_Get::new(self).id_28_16()
    }
    
    /// Get value of `DIR` field.
    #[inline(always)]
    pub fn dir(&self) -> C_CAN_canif1_arb2_dir {
        C_CAN_canif1_arb2_Get::new(self).dir()
    }
    
    /// Get value of `XTD` field.
    #[inline(always)]
    pub fn xtd(&self) -> C_CAN_canif1_arb2_xtd {
        C_CAN_canif1_arb2_Get::new(self).xtd()
    }
    
    /// Get value of `MSGVAL` field.
    #[inline(always)]
    pub fn msgval(&self) -> C_CAN_canif1_arb2_msgval {
        C_CAN_canif1_arb2_Get::new(self).msgval()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_ARB2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_arb2_Update {
        C_CAN_canif1_arb2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ID_28_16` field.
    #[inline(always)]
    pub fn set_id_28_16<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_arb2_Update<'a> {
        let mut setter: C_CAN_canif1_arb2_Update = C_CAN_canif1_arb2_Update::new(self);
        setter.set_id_28_16(new_value);
        setter
    }
    
    /// Set value of `DIR` field.
    #[inline(always)]
    pub fn set_dir<'a>(&'a mut self, new_value: C_CAN_canif1_arb2_dir) -> C_CAN_canif1_arb2_Update<'a> {
        let mut setter: C_CAN_canif1_arb2_Update = C_CAN_canif1_arb2_Update::new(self);
        setter.set_dir(new_value);
        setter
    }
    
    /// Set value of `XTD` field.
    #[inline(always)]
    pub fn set_xtd<'a>(&'a mut self, new_value: C_CAN_canif1_arb2_xtd) -> C_CAN_canif1_arb2_Update<'a> {
        let mut setter: C_CAN_canif1_arb2_Update = C_CAN_canif1_arb2_Update::new(self);
        setter.set_xtd(new_value);
        setter
    }
    
    /// Set value of `MSGVAL` field.
    #[inline(always)]
    pub fn set_msgval<'a>(&'a mut self, new_value: C_CAN_canif1_arb2_msgval) -> C_CAN_canif1_arb2_Update<'a> {
        let mut setter: C_CAN_canif1_arb2_Update = C_CAN_canif1_arb2_Update::new(self);
        setter.set_msgval(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_arb2
/// `CANIF1_ARB2`: Message interface 1 arbitration 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_arb2_Get {
    value: u32,
}

impl C_CAN_canif1_arb2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_arb2) -> C_CAN_canif1_arb2_Get {
        C_CAN_canif1_arb2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ID_28_16` field: Message identifier  29-bit identifier (extended frame) 11-bit identifier (standard frame)
    #[inline(always)]
    pub fn id_28_16(&self) -> u32 {
        (self.value >> 0) & 8191
        }
    /// Get value of `DIR` field: Message direction
    #[inline(always)]
    pub fn dir(&self) -> C_CAN_canif1_arb2_dir {
        match (self.value >> 13) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_arb2_dir::Receive),
            1 => ::core::option::Option::Some(C_CAN_canif1_arb2_dir::SuccessfulTransmission),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `XTD` field: Extend identifier
    #[inline(always)]
    pub fn xtd(&self) -> C_CAN_canif1_arb2_xtd {
        match (self.value >> 14) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_arb2_xtd::Standard11Bit),
            1 => ::core::option::Option::Some(C_CAN_canif1_arb2_xtd::Standard29Bit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MSGVAL` field: Message valid The CPU must reset the MSGVAL bit of all unused Messages Objects during the initialization before it resets bit INIT in the CAN Control Register. This bit must also be reset before the identifier ID28:0, the control bits XTD, DIR, or the Data Length Code DLC3:0 are modified, or if the Messages Object is no longer required.
    #[inline(always)]
    pub fn msgval(&self) -> C_CAN_canif1_arb2_msgval {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_arb2_msgval::Ignore),
            1 => ::core::option::Option::Some(C_CAN_canif1_arb2_msgval::Configured),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_arb2_Get { }


// Updater for C_CAN_canif1_arb2
/// Updater for `CANIF1_ARB2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_arb2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_arb2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_arb2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_arb2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_arb2) -> C_CAN_canif1_arb2_Update<'a> {
        C_CAN_canif1_arb2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_arb2) -> C_CAN_canif1_arb2_Update<'a> {
        C_CAN_canif1_arb2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ID_28_16` field.
    #[inline(always)]
    pub fn set_id_28_16<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_arb2_Update<'a> {
        self.value = (self.value & !(8191 << 0))
                   | ((new_value as u32) & 8191) << 0;
        self.mask |= 8191 << 0;
        self
    }
    /// Set value of `DIR` field.
    #[inline(always)]
    pub fn set_dir<'b>(&'b mut self, new_value: C_CAN_canif1_arb2_dir) -> &'b mut C_CAN_canif1_arb2_Update<'a> {
        self.value = (self.value & !(1 << 13))
                   | ((new_value as u32) & 1) << 13;
        self.mask |= 1 << 13;
        self
    }
    /// Set value of `XTD` field.
    #[inline(always)]
    pub fn set_xtd<'b>(&'b mut self, new_value: C_CAN_canif1_arb2_xtd) -> &'b mut C_CAN_canif1_arb2_Update<'a> {
        self.value = (self.value & !(1 << 14))
                   | ((new_value as u32) & 1) << 14;
        self.mask |= 1 << 14;
        self
    }
    /// Set value of `MSGVAL` field.
    #[inline(always)]
    pub fn set_msgval<'b>(&'b mut self, new_value: C_CAN_canif1_arb2_msgval) -> &'b mut C_CAN_canif1_arb2_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_arb2_dir {
    /// Direction = receive. On TXRQST, a Remote Frame with the identifier of this Message Object is transmitted. On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
    Receive = 0,
    /// Direction = transmit. On TXRQST, the respective Message Object is transmitted as a Data Frame. On reception of a Remote Frame with matching identifier, the TXRQST bit of this Message Object is set (if RMTEN = one).
    SuccessfulTransmission = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_arb2_xtd {
    /// The 11-bit standard identifier will be used for this message object.
    Standard11Bit = 0,
    /// The 29-bit extended identifier will be used for this message object.
    Standard29Bit = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_arb2_msgval {
    /// The message object is ignored by the message handler.
    Ignore = 0,
    /// The message object is configured and should be considered by the message handler.
    Configured = 1,
    }







// Register CANIF2_ARB2 implementation


/// Register `CANIF2_ARB2`: Message interface 1 arbitration 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_arb2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_arb2 { }

impl C_CAN_canif2_arb2 {
    
    // Getters
    /// Fetch the value of the `CANIF2_ARB2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_arb2_Get {
        C_CAN_canif2_arb2_Get::new(self)
    }

    
    /// Get value of `ID_28_16` field.
    #[inline(always)]
    pub fn id_28_16(&self) -> u32 {
        C_CAN_canif2_arb2_Get::new(self).id_28_16()
    }
    
    /// Get value of `DIR` field.
    #[inline(always)]
    pub fn dir(&self) -> C_CAN_canif2_arb2_dir {
        C_CAN_canif2_arb2_Get::new(self).dir()
    }
    
    /// Get value of `XTD` field.
    #[inline(always)]
    pub fn xtd(&self) -> C_CAN_canif2_arb2_xtd {
        C_CAN_canif2_arb2_Get::new(self).xtd()
    }
    
    /// Get value of `MSGVAL` field.
    #[inline(always)]
    pub fn msgval(&self) -> C_CAN_canif2_arb2_msgval {
        C_CAN_canif2_arb2_Get::new(self).msgval()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_ARB2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_arb2_Update {
        C_CAN_canif2_arb2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ID_28_16` field.
    #[inline(always)]
    pub fn set_id_28_16<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_arb2_Update<'a> {
        let mut setter: C_CAN_canif2_arb2_Update = C_CAN_canif2_arb2_Update::new(self);
        setter.set_id_28_16(new_value);
        setter
    }
    
    /// Set value of `DIR` field.
    #[inline(always)]
    pub fn set_dir<'a>(&'a mut self, new_value: C_CAN_canif2_arb2_dir) -> C_CAN_canif2_arb2_Update<'a> {
        let mut setter: C_CAN_canif2_arb2_Update = C_CAN_canif2_arb2_Update::new(self);
        setter.set_dir(new_value);
        setter
    }
    
    /// Set value of `XTD` field.
    #[inline(always)]
    pub fn set_xtd<'a>(&'a mut self, new_value: C_CAN_canif2_arb2_xtd) -> C_CAN_canif2_arb2_Update<'a> {
        let mut setter: C_CAN_canif2_arb2_Update = C_CAN_canif2_arb2_Update::new(self);
        setter.set_xtd(new_value);
        setter
    }
    
    /// Set value of `MSGVAL` field.
    #[inline(always)]
    pub fn set_msgval<'a>(&'a mut self, new_value: C_CAN_canif2_arb2_msgval) -> C_CAN_canif2_arb2_Update<'a> {
        let mut setter: C_CAN_canif2_arb2_Update = C_CAN_canif2_arb2_Update::new(self);
        setter.set_msgval(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_arb2
/// `CANIF2_ARB2`: Message interface 1 arbitration 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_arb2_Get {
    value: u32,
}

impl C_CAN_canif2_arb2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_arb2) -> C_CAN_canif2_arb2_Get {
        C_CAN_canif2_arb2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ID_28_16` field: Message identifier  29-bit identifier (extended frame) 11-bit identifier (standard frame)
    #[inline(always)]
    pub fn id_28_16(&self) -> u32 {
        (self.value >> 0) & 8191
        }
    /// Get value of `DIR` field: Message direction
    #[inline(always)]
    pub fn dir(&self) -> C_CAN_canif2_arb2_dir {
        match (self.value >> 13) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_arb2_dir::Receive),
            1 => ::core::option::Option::Some(C_CAN_canif2_arb2_dir::SuccessfulTransmission),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `XTD` field: Extend identifier
    #[inline(always)]
    pub fn xtd(&self) -> C_CAN_canif2_arb2_xtd {
        match (self.value >> 14) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_arb2_xtd::Standard11Bit),
            1 => ::core::option::Option::Some(C_CAN_canif2_arb2_xtd::Standard29Bit),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MSGVAL` field: Message valid The CPU must reset the MSGVAL bit of all unused Messages Objects during the initialization before it resets bit INIT in the CAN Control Register. This bit must also be reset before the identifier ID28:0, the control bits XTD, DIR, or the Data Length Code DLC3:0 are modified, or if the Messages Object is no longer required.
    #[inline(always)]
    pub fn msgval(&self) -> C_CAN_canif2_arb2_msgval {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_arb2_msgval::Ignore),
            1 => ::core::option::Option::Some(C_CAN_canif2_arb2_msgval::Configured),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_arb2_Get { }


// Updater for C_CAN_canif2_arb2
/// Updater for `CANIF2_ARB2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_arb2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_arb2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_arb2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_arb2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_arb2) -> C_CAN_canif2_arb2_Update<'a> {
        C_CAN_canif2_arb2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_arb2) -> C_CAN_canif2_arb2_Update<'a> {
        C_CAN_canif2_arb2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ID_28_16` field.
    #[inline(always)]
    pub fn set_id_28_16<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_arb2_Update<'a> {
        self.value = (self.value & !(8191 << 0))
                   | ((new_value as u32) & 8191) << 0;
        self.mask |= 8191 << 0;
        self
    }
    /// Set value of `DIR` field.
    #[inline(always)]
    pub fn set_dir<'b>(&'b mut self, new_value: C_CAN_canif2_arb2_dir) -> &'b mut C_CAN_canif2_arb2_Update<'a> {
        self.value = (self.value & !(1 << 13))
                   | ((new_value as u32) & 1) << 13;
        self.mask |= 1 << 13;
        self
    }
    /// Set value of `XTD` field.
    #[inline(always)]
    pub fn set_xtd<'b>(&'b mut self, new_value: C_CAN_canif2_arb2_xtd) -> &'b mut C_CAN_canif2_arb2_Update<'a> {
        self.value = (self.value & !(1 << 14))
                   | ((new_value as u32) & 1) << 14;
        self.mask |= 1 << 14;
        self
    }
    /// Set value of `MSGVAL` field.
    #[inline(always)]
    pub fn set_msgval<'b>(&'b mut self, new_value: C_CAN_canif2_arb2_msgval) -> &'b mut C_CAN_canif2_arb2_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_arb2_dir {
    /// Direction = receive. On TXRQST, a Remote Frame with the identifier of this Message Object is transmitted. On reception of a Data Frame with matching identifier, that message is stored in this Message Object.
    Receive = 0,
    /// Direction = transmit. On TXRQST, the respective Message Object is transmitted as a Data Frame. On reception of a Remote Frame with matching identifier, the TXRQST bit of this Message Object is set (if RMTEN = one).
    SuccessfulTransmission = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_arb2_xtd {
    /// The 11-bit standard identifier will be used for this message object.
    Standard11Bit = 0,
    /// The 29-bit extended identifier will be used for this message object.
    Standard29Bit = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_arb2_msgval {
    /// The message object is ignored by the message handler.
    Ignore = 0,
    /// The message object is configured and should be considered by the message handler.
    Configured = 1,
    }







// Register CANIF1_MCTRL implementation


/// Register `CANIF1_MCTRL`: Message interface 1 message control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_mctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_mctrl { }

impl C_CAN_canif1_mctrl {
    
    // Getters
    /// Fetch the value of the `CANIF1_MCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_mctrl_Get {
        C_CAN_canif1_mctrl_Get::new(self)
    }

    
    /// Get value of `DLC_3_0` field.
    #[inline(always)]
    pub fn dlc_3_0(&self) -> u32 {
        C_CAN_canif1_mctrl_Get::new(self).dlc_3_0()
    }
    
    /// Get value of `EOB` field.
    #[inline(always)]
    pub fn eob(&self) -> C_CAN_canif1_mctrl_eob {
        C_CAN_canif1_mctrl_Get::new(self).eob()
    }
    
    /// Get value of `TXRQST` field.
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif1_mctrl_txrqst {
        C_CAN_canif1_mctrl_Get::new(self).txrqst()
    }
    
    /// Get value of `RMTEN` field.
    #[inline(always)]
    pub fn rmten(&self) -> C_CAN_canif1_mctrl_rmten {
        C_CAN_canif1_mctrl_Get::new(self).rmten()
    }
    
    /// Get value of `RXIE` field.
    #[inline(always)]
    pub fn rxie(&self) -> C_CAN_canif1_mctrl_rxie {
        C_CAN_canif1_mctrl_Get::new(self).rxie()
    }
    
    /// Get value of `TXIE` field.
    #[inline(always)]
    pub fn txie(&self) -> C_CAN_canif1_mctrl_txie {
        C_CAN_canif1_mctrl_Get::new(self).txie()
    }
    
    /// Get value of `UMASK` field.
    #[inline(always)]
    pub fn umask(&self) -> C_CAN_canif1_mctrl_umask {
        C_CAN_canif1_mctrl_Get::new(self).umask()
    }
    
    /// Get value of `INTPND` field.
    #[inline(always)]
    pub fn intpnd(&self) -> C_CAN_canif1_mctrl_intpnd {
        C_CAN_canif1_mctrl_Get::new(self).intpnd()
    }
    
    /// Get value of `MSGLST` field.
    #[inline(always)]
    pub fn msglst(&self) -> C_CAN_canif1_mctrl_msglst {
        C_CAN_canif1_mctrl_Get::new(self).msglst()
    }
    
    /// Get value of `NEWDAT` field.
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif1_mctrl_newdat {
        C_CAN_canif1_mctrl_Get::new(self).newdat()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_MCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_mctrl_Update {
        C_CAN_canif1_mctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DLC_3_0` field.
    #[inline(always)]
    pub fn set_dlc_3_0<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_dlc_3_0(new_value);
        setter
    }
    
    /// Set value of `EOB` field.
    #[inline(always)]
    pub fn set_eob<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_eob) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_eob(new_value);
        setter
    }
    
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_txrqst) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_txrqst(new_value);
        setter
    }
    
    /// Set value of `RMTEN` field.
    #[inline(always)]
    pub fn set_rmten<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_rmten) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_rmten(new_value);
        setter
    }
    
    /// Set value of `RXIE` field.
    #[inline(always)]
    pub fn set_rxie<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_rxie) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_rxie(new_value);
        setter
    }
    
    /// Set value of `TXIE` field.
    #[inline(always)]
    pub fn set_txie<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_txie) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_txie(new_value);
        setter
    }
    
    /// Set value of `UMASK` field.
    #[inline(always)]
    pub fn set_umask<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_umask) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_umask(new_value);
        setter
    }
    
    /// Set value of `INTPND` field.
    #[inline(always)]
    pub fn set_intpnd<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_intpnd) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_intpnd(new_value);
        setter
    }
    
    /// Set value of `MSGLST` field.
    #[inline(always)]
    pub fn set_msglst<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_msglst) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_msglst(new_value);
        setter
    }
    
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'a>(&'a mut self, new_value: C_CAN_canif1_mctrl_newdat) -> C_CAN_canif1_mctrl_Update<'a> {
        let mut setter: C_CAN_canif1_mctrl_Update = C_CAN_canif1_mctrl_Update::new(self);
        setter.set_newdat(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_mctrl
/// `CANIF1_MCTRL`: Message interface 1 message control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_mctrl_Get {
    value: u32,
}

impl C_CAN_canif1_mctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_mctrl) -> C_CAN_canif1_mctrl_Get {
        C_CAN_canif1_mctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DLC_3_0` field: Data length code The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the Message Handler stores a data frame, it will write the DLC to the value given by the received message. 0000 - 1000 = Data frame has 0 - 8 data bytes. 1001 - 1111 = Data frame has 8 data bytes.
    #[inline(always)]
    pub fn dlc_3_0(&self) -> u32 {
        (self.value >> 0) & 15
        }
    /// Get value of `EOB` field: End of buffer
    #[inline(always)]
    pub fn eob(&self) -> C_CAN_canif1_mctrl_eob {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_eob::FIFO),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_eob::SingleLast),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TXRQST` field: Transmit request
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif1_mctrl_txrqst {
        match (self.value >> 8) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_txrqst::NoWait),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_txrqst::Wait),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RMTEN` field: Remote enable
    #[inline(always)]
    pub fn rmten(&self) -> C_CAN_canif1_mctrl_rmten {
        match (self.value >> 9) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_rmten::NoChange),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_rmten::Set),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RXIE` field: Receive interrupt enable
    #[inline(always)]
    pub fn rxie(&self) -> C_CAN_canif1_mctrl_rxie {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_rxie::NoChange),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_rxie::Set),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TXIE` field: Transmit interrupt enable
    #[inline(always)]
    pub fn txie(&self) -> C_CAN_canif1_mctrl_txie {
        match (self.value >> 11) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_txie::NoChange),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_txie::Set),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `UMASK` field: Use acceptance mask If UMASK is set to 1, the message object's mask bits have to be programmed during initialization of the message object before MAGVAL is set to 1.
    #[inline(always)]
    pub fn umask(&self) -> C_CAN_canif1_mctrl_umask {
        match (self.value >> 12) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_umask::Ignore),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_umask::UseMask),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `INTPND` field: Interrupt pending
    #[inline(always)]
    pub fn intpnd(&self) -> C_CAN_canif1_mctrl_intpnd {
        match (self.value >> 13) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_intpnd::NoInterruptSource),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_intpnd::InterruptSource),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MSGLST` field: Message lost (only valid for message objects in the direction receive).
    #[inline(always)]
    pub fn msglst(&self) -> C_CAN_canif1_mctrl_msglst {
        match (self.value >> 14) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_msglst::NoMessagesLost),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_msglst::NewMessageLost),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NEWDAT` field: New data
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif1_mctrl_newdat {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif1_mctrl_newdat::NoNewData),
            1 => ::core::option::Option::Some(C_CAN_canif1_mctrl_newdat::NewDataWritten),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_mctrl_Get { }


// Updater for C_CAN_canif1_mctrl
/// Updater for `CANIF1_MCTRL` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_mctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_mctrl,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_mctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_mctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_mctrl) -> C_CAN_canif1_mctrl_Update<'a> {
        C_CAN_canif1_mctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_mctrl) -> C_CAN_canif1_mctrl_Update<'a> {
        C_CAN_canif1_mctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DLC_3_0` field.
    #[inline(always)]
    pub fn set_dlc_3_0<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(15 << 0))
                   | ((new_value as u32) & 15) << 0;
        self.mask |= 15 << 0;
        self
    }
    /// Set value of `EOB` field.
    #[inline(always)]
    pub fn set_eob<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_eob) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_txrqst) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `RMTEN` field.
    #[inline(always)]
    pub fn set_rmten<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_rmten) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `RXIE` field.
    #[inline(always)]
    pub fn set_rxie<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_rxie) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `TXIE` field.
    #[inline(always)]
    pub fn set_txie<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_txie) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `UMASK` field.
    #[inline(always)]
    pub fn set_umask<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_umask) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Set value of `INTPND` field.
    #[inline(always)]
    pub fn set_intpnd<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_intpnd) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 13))
                   | ((new_value as u32) & 1) << 13;
        self.mask |= 1 << 13;
        self
    }
    /// Set value of `MSGLST` field.
    #[inline(always)]
    pub fn set_msglst<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_msglst) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 14))
                   | ((new_value as u32) & 1) << 14;
        self.mask |= 1 << 14;
        self
    }
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'b>(&'b mut self, new_value: C_CAN_canif1_mctrl_newdat) -> &'b mut C_CAN_canif1_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_eob {
    /// Message object belongs to a FIFO buffer and is not the last message object of that FIFO buffer.
    FIFO = 0,
    /// Single message object or last message object of a FIFO buffer.
    SingleLast = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_txrqst {
    /// This message object is not waiting for transmission.
    NoWait = 0,
    /// The transmission of this message object is requested and is not yet done
    Wait = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_rmten {
    /// At the reception of a remote frame, TXRQST is left unchanged.
    NoChange = 0,
    /// At the reception of a remote frame, TXRQST is set.
    Set = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_rxie {
    /// INTPND will be left unchanged after successful reception of a frame.
    NoChange = 0,
    /// INTPND will be set after successful reception of a frame.
    Set = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_txie {
    /// The INTPND bit will be left unchanged after a successful transmission of a frame.
    NoChange = 0,
    /// INTPND will be set after a successful transmission of a frame.
    Set = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_umask {
    /// Mask ignored.
    Ignore = 0,
    /// Use mask (MSK[28:0], MXTD, and MDIR) for acceptance filtering.
    UseMask = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_intpnd {
    /// This message object is not the source of an interrupt.
    NoInterruptSource = 0,
    /// This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
    InterruptSource = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_msglst {
    /// No message lost since this bit was reset last by the CPU.
    NoMessagesLost = 0,
    /// The Message Handler stored a new message into this object when NEWDAT was still set, the CPU has lost a message.
    NewMessageLost = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif1_mctrl_newdat {
    /// No new data has been written into the data portion of this message object by the message handler since this flag was cleared last by the CPU.
    NoNewData = 0,
    /// The message handler or the CPU has written new data into the data portion of this message object.
    NewDataWritten = 1,
    }







// Register CANIF2_MCTRL implementation


/// Register `CANIF2_MCTRL`: Message interface 1 message control
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_mctrl {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_mctrl { }

impl C_CAN_canif2_mctrl {
    
    // Getters
    /// Fetch the value of the `CANIF2_MCTRL` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_mctrl_Get {
        C_CAN_canif2_mctrl_Get::new(self)
    }

    
    /// Get value of `DLC_3_0` field.
    #[inline(always)]
    pub fn dlc_3_0(&self) -> u32 {
        C_CAN_canif2_mctrl_Get::new(self).dlc_3_0()
    }
    
    /// Get value of `EOB` field.
    #[inline(always)]
    pub fn eob(&self) -> C_CAN_canif2_mctrl_eob {
        C_CAN_canif2_mctrl_Get::new(self).eob()
    }
    
    /// Get value of `TXRQST` field.
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif2_mctrl_txrqst {
        C_CAN_canif2_mctrl_Get::new(self).txrqst()
    }
    
    /// Get value of `RMTEN` field.
    #[inline(always)]
    pub fn rmten(&self) -> C_CAN_canif2_mctrl_rmten {
        C_CAN_canif2_mctrl_Get::new(self).rmten()
    }
    
    /// Get value of `RXIE` field.
    #[inline(always)]
    pub fn rxie(&self) -> C_CAN_canif2_mctrl_rxie {
        C_CAN_canif2_mctrl_Get::new(self).rxie()
    }
    
    /// Get value of `TXIE` field.
    #[inline(always)]
    pub fn txie(&self) -> C_CAN_canif2_mctrl_txie {
        C_CAN_canif2_mctrl_Get::new(self).txie()
    }
    
    /// Get value of `UMASK` field.
    #[inline(always)]
    pub fn umask(&self) -> C_CAN_canif2_mctrl_umask {
        C_CAN_canif2_mctrl_Get::new(self).umask()
    }
    
    /// Get value of `INTPND` field.
    #[inline(always)]
    pub fn intpnd(&self) -> C_CAN_canif2_mctrl_intpnd {
        C_CAN_canif2_mctrl_Get::new(self).intpnd()
    }
    
    /// Get value of `MSGLST` field.
    #[inline(always)]
    pub fn msglst(&self) -> C_CAN_canif2_mctrl_msglst {
        C_CAN_canif2_mctrl_Get::new(self).msglst()
    }
    
    /// Get value of `NEWDAT` field.
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif2_mctrl_newdat {
        C_CAN_canif2_mctrl_Get::new(self).newdat()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_MCTRL` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_mctrl_Update {
        C_CAN_canif2_mctrl_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DLC_3_0` field.
    #[inline(always)]
    pub fn set_dlc_3_0<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_dlc_3_0(new_value);
        setter
    }
    
    /// Set value of `EOB` field.
    #[inline(always)]
    pub fn set_eob<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_eob) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_eob(new_value);
        setter
    }
    
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_txrqst) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_txrqst(new_value);
        setter
    }
    
    /// Set value of `RMTEN` field.
    #[inline(always)]
    pub fn set_rmten<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_rmten) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_rmten(new_value);
        setter
    }
    
    /// Set value of `RXIE` field.
    #[inline(always)]
    pub fn set_rxie<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_rxie) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_rxie(new_value);
        setter
    }
    
    /// Set value of `TXIE` field.
    #[inline(always)]
    pub fn set_txie<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_txie) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_txie(new_value);
        setter
    }
    
    /// Set value of `UMASK` field.
    #[inline(always)]
    pub fn set_umask<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_umask) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_umask(new_value);
        setter
    }
    
    /// Set value of `INTPND` field.
    #[inline(always)]
    pub fn set_intpnd<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_intpnd) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_intpnd(new_value);
        setter
    }
    
    /// Set value of `MSGLST` field.
    #[inline(always)]
    pub fn set_msglst<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_msglst) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_msglst(new_value);
        setter
    }
    
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'a>(&'a mut self, new_value: C_CAN_canif2_mctrl_newdat) -> C_CAN_canif2_mctrl_Update<'a> {
        let mut setter: C_CAN_canif2_mctrl_Update = C_CAN_canif2_mctrl_Update::new(self);
        setter.set_newdat(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_mctrl
/// `CANIF2_MCTRL`: Message interface 1 message control
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_mctrl_Get {
    value: u32,
}

impl C_CAN_canif2_mctrl_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_mctrl) -> C_CAN_canif2_mctrl_Get {
        C_CAN_canif2_mctrl_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DLC_3_0` field: Data length code The Data Length Code of a Message Object must be defined the same as in all the corresponding objects with the same identifier at other nodes. When the Message Handler stores a data frame, it will write the DLC to the value given by the received message. 0000 - 1000 = Data frame has 0 - 8 data bytes. 1001 - 1111 = Data frame has 8 data bytes.
    #[inline(always)]
    pub fn dlc_3_0(&self) -> u32 {
        (self.value >> 0) & 15
        }
    /// Get value of `EOB` field: End of buffer
    #[inline(always)]
    pub fn eob(&self) -> C_CAN_canif2_mctrl_eob {
        match (self.value >> 7) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_eob::FIFO),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_eob::SingleLast),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TXRQST` field: Transmit request
    #[inline(always)]
    pub fn txrqst(&self) -> C_CAN_canif2_mctrl_txrqst {
        match (self.value >> 8) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_txrqst::NoWait),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_txrqst::Wait),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RMTEN` field: Remote enable
    #[inline(always)]
    pub fn rmten(&self) -> C_CAN_canif2_mctrl_rmten {
        match (self.value >> 9) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_rmten::NoChange),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_rmten::Set),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `RXIE` field: Receive interrupt enable
    #[inline(always)]
    pub fn rxie(&self) -> C_CAN_canif2_mctrl_rxie {
        match (self.value >> 10) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_rxie::NoChange),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_rxie::Set),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `TXIE` field: Transmit interrupt enable
    #[inline(always)]
    pub fn txie(&self) -> C_CAN_canif2_mctrl_txie {
        match (self.value >> 11) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_txie::NoChange),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_txie::Set),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `UMASK` field: Use acceptance mask If UMASK is set to 1, the message object's mask bits have to be programmed during initialization of the message object before MAGVAL is set to 1.
    #[inline(always)]
    pub fn umask(&self) -> C_CAN_canif2_mctrl_umask {
        match (self.value >> 12) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_umask::Ignore),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_umask::UseMask),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `INTPND` field: Interrupt pending
    #[inline(always)]
    pub fn intpnd(&self) -> C_CAN_canif2_mctrl_intpnd {
        match (self.value >> 13) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_intpnd::NoInterruptSource),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_intpnd::InterruptSource),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `MSGLST` field: Message lost (only valid for message objects in the direction receive).
    #[inline(always)]
    pub fn msglst(&self) -> C_CAN_canif2_mctrl_msglst {
        match (self.value >> 14) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_msglst::NoMessagesLost),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_msglst::NewMessageLost),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    /// Get value of `NEWDAT` field: New data
    #[inline(always)]
    pub fn newdat(&self) -> C_CAN_canif2_mctrl_newdat {
        match (self.value >> 15) & 1 {
            0 => ::core::option::Option::Some(C_CAN_canif2_mctrl_newdat::NoNewData),
            1 => ::core::option::Option::Some(C_CAN_canif2_mctrl_newdat::NewDataWritten),
            _ => ::core::option::Option::None,
        }.unwrap()
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_mctrl_Get { }


// Updater for C_CAN_canif2_mctrl
/// Updater for `CANIF2_MCTRL` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_mctrl_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_mctrl,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_mctrl_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_mctrl_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_mctrl) -> C_CAN_canif2_mctrl_Update<'a> {
        C_CAN_canif2_mctrl_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_mctrl) -> C_CAN_canif2_mctrl_Update<'a> {
        C_CAN_canif2_mctrl_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DLC_3_0` field.
    #[inline(always)]
    pub fn set_dlc_3_0<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(15 << 0))
                   | ((new_value as u32) & 15) << 0;
        self.mask |= 15 << 0;
        self
    }
    /// Set value of `EOB` field.
    #[inline(always)]
    pub fn set_eob<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_eob) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `TXRQST` field.
    #[inline(always)]
    pub fn set_txrqst<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_txrqst) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `RMTEN` field.
    #[inline(always)]
    pub fn set_rmten<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_rmten) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `RXIE` field.
    #[inline(always)]
    pub fn set_rxie<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_rxie) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `TXIE` field.
    #[inline(always)]
    pub fn set_txie<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_txie) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Set value of `UMASK` field.
    #[inline(always)]
    pub fn set_umask<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_umask) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 12))
                   | ((new_value as u32) & 1) << 12;
        self.mask |= 1 << 12;
        self
    }
    /// Set value of `INTPND` field.
    #[inline(always)]
    pub fn set_intpnd<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_intpnd) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 13))
                   | ((new_value as u32) & 1) << 13;
        self.mask |= 1 << 13;
        self
    }
    /// Set value of `MSGLST` field.
    #[inline(always)]
    pub fn set_msglst<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_msglst) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 14))
                   | ((new_value as u32) & 1) << 14;
        self.mask |= 1 << 14;
        self
    }
    /// Set value of `NEWDAT` field.
    #[inline(always)]
    pub fn set_newdat<'b>(&'b mut self, new_value: C_CAN_canif2_mctrl_newdat) -> &'b mut C_CAN_canif2_mctrl_Update<'a> {
        self.value = (self.value & !(1 << 15))
                   | ((new_value as u32) & 1) << 15;
        self.mask |= 1 << 15;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_eob {
    /// Message object belongs to a FIFO buffer and is not the last message object of that FIFO buffer.
    FIFO = 0,
    /// Single message object or last message object of a FIFO buffer.
    SingleLast = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_txrqst {
    /// This message object is not waiting for transmission.
    NoWait = 0,
    /// The transmission of this message object is requested and is not yet done
    Wait = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_rmten {
    /// At the reception of a remote frame, TXRQST is left unchanged.
    NoChange = 0,
    /// At the reception of a remote frame, TXRQST is set.
    Set = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_rxie {
    /// INTPND will be left unchanged after successful reception of a frame.
    NoChange = 0,
    /// INTPND will be set after successful reception of a frame.
    Set = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_txie {
    /// The INTPND bit will be left unchanged after a successful transmission of a frame.
    NoChange = 0,
    /// INTPND will be set after a successful transmission of a frame.
    Set = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_umask {
    /// Mask ignored.
    Ignore = 0,
    /// Use mask (MSK[28:0], MXTD, and MDIR) for acceptance filtering.
    UseMask = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_intpnd {
    /// This message object is not the source of an interrupt.
    NoInterruptSource = 0,
    /// This message object is the source of an interrupt. The Interrupt Identifier in the Interrupt Register will point to this message object if there is no other interrupt source with higher priority.
    InterruptSource = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_msglst {
    /// No message lost since this bit was reset last by the CPU.
    NoMessagesLost = 0,
    /// The Message Handler stored a new message into this object when NEWDAT was still set, the CPU has lost a message.
    NewMessageLost = 1,
    }


#[derive(PartialEq)]
#[allow(non_camel_case_types)]
#[repr(u32)]
pub enum C_CAN_canif2_mctrl_newdat {
    /// No new data has been written into the data portion of this message object by the message handler since this flag was cleared last by the CPU.
    NoNewData = 0,
    /// The message handler or the CPU has written new data into the data portion of this message object.
    NewDataWritten = 1,
    }







// Register CANIF1_DA1 implementation


/// Register `CANIF1_DA1`: Message interface 1 data A1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_da1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_da1 { }

impl C_CAN_canif1_da1 {
    
    // Getters
    /// Fetch the value of the `CANIF1_DA1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_da1_Get {
        C_CAN_canif1_da1_Get::new(self)
    }

    
    /// Get value of `DATA0` field.
    #[inline(always)]
    pub fn data0(&self) -> u32 {
        C_CAN_canif1_da1_Get::new(self).data0()
    }
    
    /// Get value of `DATA1` field.
    #[inline(always)]
    pub fn data1(&self) -> u32 {
        C_CAN_canif1_da1_Get::new(self).data1()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_DA1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_da1_Update {
        C_CAN_canif1_da1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA0` field.
    #[inline(always)]
    pub fn set_data0<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_da1_Update<'a> {
        let mut setter: C_CAN_canif1_da1_Update = C_CAN_canif1_da1_Update::new(self);
        setter.set_data0(new_value);
        setter
    }
    
    /// Set value of `DATA1` field.
    #[inline(always)]
    pub fn set_data1<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_da1_Update<'a> {
        let mut setter: C_CAN_canif1_da1_Update = C_CAN_canif1_da1_Update::new(self);
        setter.set_data1(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_da1
/// `CANIF1_DA1`: Message interface 1 data A1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_da1_Get {
    value: u32,
}

impl C_CAN_canif1_da1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_da1) -> C_CAN_canif1_da1_Get {
        C_CAN_canif1_da1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA0` field: Data byte 0
    #[inline(always)]
    pub fn data0(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA1` field: Data byte 1
    #[inline(always)]
    pub fn data1(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_da1_Get { }


// Updater for C_CAN_canif1_da1
/// Updater for `CANIF1_DA1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_da1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_da1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_da1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_da1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_da1) -> C_CAN_canif1_da1_Update<'a> {
        C_CAN_canif1_da1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_da1) -> C_CAN_canif1_da1_Update<'a> {
        C_CAN_canif1_da1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA0` field.
    #[inline(always)]
    pub fn set_data0<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_da1_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA1` field.
    #[inline(always)]
    pub fn set_data1<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_da1_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF2_DA1 implementation


/// Register `CANIF2_DA1`: Message interface 1 data A1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_da1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_da1 { }

impl C_CAN_canif2_da1 {
    
    // Getters
    /// Fetch the value of the `CANIF2_DA1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_da1_Get {
        C_CAN_canif2_da1_Get::new(self)
    }

    
    /// Get value of `DATA0` field.
    #[inline(always)]
    pub fn data0(&self) -> u32 {
        C_CAN_canif2_da1_Get::new(self).data0()
    }
    
    /// Get value of `DATA1` field.
    #[inline(always)]
    pub fn data1(&self) -> u32 {
        C_CAN_canif2_da1_Get::new(self).data1()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_DA1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_da1_Update {
        C_CAN_canif2_da1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA0` field.
    #[inline(always)]
    pub fn set_data0<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_da1_Update<'a> {
        let mut setter: C_CAN_canif2_da1_Update = C_CAN_canif2_da1_Update::new(self);
        setter.set_data0(new_value);
        setter
    }
    
    /// Set value of `DATA1` field.
    #[inline(always)]
    pub fn set_data1<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_da1_Update<'a> {
        let mut setter: C_CAN_canif2_da1_Update = C_CAN_canif2_da1_Update::new(self);
        setter.set_data1(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_da1
/// `CANIF2_DA1`: Message interface 1 data A1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_da1_Get {
    value: u32,
}

impl C_CAN_canif2_da1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_da1) -> C_CAN_canif2_da1_Get {
        C_CAN_canif2_da1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA0` field: Data byte 0
    #[inline(always)]
    pub fn data0(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA1` field: Data byte 1
    #[inline(always)]
    pub fn data1(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_da1_Get { }


// Updater for C_CAN_canif2_da1
/// Updater for `CANIF2_DA1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_da1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_da1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_da1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_da1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_da1) -> C_CAN_canif2_da1_Update<'a> {
        C_CAN_canif2_da1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_da1) -> C_CAN_canif2_da1_Update<'a> {
        C_CAN_canif2_da1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA0` field.
    #[inline(always)]
    pub fn set_data0<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_da1_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA1` field.
    #[inline(always)]
    pub fn set_data1<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_da1_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF1_DA2 implementation


/// Register `CANIF1_DA2`: Message interface 1 data A2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_da2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_da2 { }

impl C_CAN_canif1_da2 {
    
    // Getters
    /// Fetch the value of the `CANIF1_DA2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_da2_Get {
        C_CAN_canif1_da2_Get::new(self)
    }

    
    /// Get value of `DATA2` field.
    #[inline(always)]
    pub fn data2(&self) -> u32 {
        C_CAN_canif1_da2_Get::new(self).data2()
    }
    
    /// Get value of `DATA3` field.
    #[inline(always)]
    pub fn data3(&self) -> u32 {
        C_CAN_canif1_da2_Get::new(self).data3()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_DA2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_da2_Update {
        C_CAN_canif1_da2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA2` field.
    #[inline(always)]
    pub fn set_data2<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_da2_Update<'a> {
        let mut setter: C_CAN_canif1_da2_Update = C_CAN_canif1_da2_Update::new(self);
        setter.set_data2(new_value);
        setter
    }
    
    /// Set value of `DATA3` field.
    #[inline(always)]
    pub fn set_data3<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_da2_Update<'a> {
        let mut setter: C_CAN_canif1_da2_Update = C_CAN_canif1_da2_Update::new(self);
        setter.set_data3(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_da2
/// `CANIF1_DA2`: Message interface 1 data A2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_da2_Get {
    value: u32,
}

impl C_CAN_canif1_da2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_da2) -> C_CAN_canif1_da2_Get {
        C_CAN_canif1_da2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA2` field: Data byte 2
    #[inline(always)]
    pub fn data2(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA3` field: Data byte 3
    #[inline(always)]
    pub fn data3(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_da2_Get { }


// Updater for C_CAN_canif1_da2
/// Updater for `CANIF1_DA2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_da2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_da2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_da2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_da2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_da2) -> C_CAN_canif1_da2_Update<'a> {
        C_CAN_canif1_da2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_da2) -> C_CAN_canif1_da2_Update<'a> {
        C_CAN_canif1_da2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA2` field.
    #[inline(always)]
    pub fn set_data2<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_da2_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA3` field.
    #[inline(always)]
    pub fn set_data3<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_da2_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF2_DA2 implementation


/// Register `CANIF2_DA2`: Message interface 1 data A2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_da2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_da2 { }

impl C_CAN_canif2_da2 {
    
    // Getters
    /// Fetch the value of the `CANIF2_DA2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_da2_Get {
        C_CAN_canif2_da2_Get::new(self)
    }

    
    /// Get value of `DATA2` field.
    #[inline(always)]
    pub fn data2(&self) -> u32 {
        C_CAN_canif2_da2_Get::new(self).data2()
    }
    
    /// Get value of `DATA3` field.
    #[inline(always)]
    pub fn data3(&self) -> u32 {
        C_CAN_canif2_da2_Get::new(self).data3()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_DA2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_da2_Update {
        C_CAN_canif2_da2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA2` field.
    #[inline(always)]
    pub fn set_data2<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_da2_Update<'a> {
        let mut setter: C_CAN_canif2_da2_Update = C_CAN_canif2_da2_Update::new(self);
        setter.set_data2(new_value);
        setter
    }
    
    /// Set value of `DATA3` field.
    #[inline(always)]
    pub fn set_data3<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_da2_Update<'a> {
        let mut setter: C_CAN_canif2_da2_Update = C_CAN_canif2_da2_Update::new(self);
        setter.set_data3(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_da2
/// `CANIF2_DA2`: Message interface 1 data A2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_da2_Get {
    value: u32,
}

impl C_CAN_canif2_da2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_da2) -> C_CAN_canif2_da2_Get {
        C_CAN_canif2_da2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA2` field: Data byte 2
    #[inline(always)]
    pub fn data2(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA3` field: Data byte 3
    #[inline(always)]
    pub fn data3(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_da2_Get { }


// Updater for C_CAN_canif2_da2
/// Updater for `CANIF2_DA2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_da2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_da2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_da2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_da2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_da2) -> C_CAN_canif2_da2_Update<'a> {
        C_CAN_canif2_da2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_da2) -> C_CAN_canif2_da2_Update<'a> {
        C_CAN_canif2_da2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA2` field.
    #[inline(always)]
    pub fn set_data2<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_da2_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA3` field.
    #[inline(always)]
    pub fn set_data3<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_da2_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF1_DB1 implementation


/// Register `CANIF1_DB1`: Message interface 1 data B1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_db1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_db1 { }

impl C_CAN_canif1_db1 {
    
    // Getters
    /// Fetch the value of the `CANIF1_DB1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_db1_Get {
        C_CAN_canif1_db1_Get::new(self)
    }

    
    /// Get value of `DATA4` field.
    #[inline(always)]
    pub fn data4(&self) -> u32 {
        C_CAN_canif1_db1_Get::new(self).data4()
    }
    
    /// Get value of `DATA5` field.
    #[inline(always)]
    pub fn data5(&self) -> u32 {
        C_CAN_canif1_db1_Get::new(self).data5()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_DB1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_db1_Update {
        C_CAN_canif1_db1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA4` field.
    #[inline(always)]
    pub fn set_data4<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_db1_Update<'a> {
        let mut setter: C_CAN_canif1_db1_Update = C_CAN_canif1_db1_Update::new(self);
        setter.set_data4(new_value);
        setter
    }
    
    /// Set value of `DATA5` field.
    #[inline(always)]
    pub fn set_data5<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_db1_Update<'a> {
        let mut setter: C_CAN_canif1_db1_Update = C_CAN_canif1_db1_Update::new(self);
        setter.set_data5(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_db1
/// `CANIF1_DB1`: Message interface 1 data B1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_db1_Get {
    value: u32,
}

impl C_CAN_canif1_db1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_db1) -> C_CAN_canif1_db1_Get {
        C_CAN_canif1_db1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA4` field: Data byte 4
    #[inline(always)]
    pub fn data4(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA5` field: Data byte 5
    #[inline(always)]
    pub fn data5(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_db1_Get { }


// Updater for C_CAN_canif1_db1
/// Updater for `CANIF1_DB1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_db1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_db1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_db1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_db1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_db1) -> C_CAN_canif1_db1_Update<'a> {
        C_CAN_canif1_db1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_db1) -> C_CAN_canif1_db1_Update<'a> {
        C_CAN_canif1_db1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA4` field.
    #[inline(always)]
    pub fn set_data4<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_db1_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA5` field.
    #[inline(always)]
    pub fn set_data5<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_db1_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF2_DB1 implementation


/// Register `CANIF2_DB1`: Message interface 1 data B1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_db1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_db1 { }

impl C_CAN_canif2_db1 {
    
    // Getters
    /// Fetch the value of the `CANIF2_DB1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_db1_Get {
        C_CAN_canif2_db1_Get::new(self)
    }

    
    /// Get value of `DATA4` field.
    #[inline(always)]
    pub fn data4(&self) -> u32 {
        C_CAN_canif2_db1_Get::new(self).data4()
    }
    
    /// Get value of `DATA5` field.
    #[inline(always)]
    pub fn data5(&self) -> u32 {
        C_CAN_canif2_db1_Get::new(self).data5()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_DB1` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_db1_Update {
        C_CAN_canif2_db1_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA4` field.
    #[inline(always)]
    pub fn set_data4<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_db1_Update<'a> {
        let mut setter: C_CAN_canif2_db1_Update = C_CAN_canif2_db1_Update::new(self);
        setter.set_data4(new_value);
        setter
    }
    
    /// Set value of `DATA5` field.
    #[inline(always)]
    pub fn set_data5<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_db1_Update<'a> {
        let mut setter: C_CAN_canif2_db1_Update = C_CAN_canif2_db1_Update::new(self);
        setter.set_data5(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_db1
/// `CANIF2_DB1`: Message interface 1 data B1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_db1_Get {
    value: u32,
}

impl C_CAN_canif2_db1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_db1) -> C_CAN_canif2_db1_Get {
        C_CAN_canif2_db1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA4` field: Data byte 4
    #[inline(always)]
    pub fn data4(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA5` field: Data byte 5
    #[inline(always)]
    pub fn data5(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_db1_Get { }


// Updater for C_CAN_canif2_db1
/// Updater for `CANIF2_DB1` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_db1_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_db1,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_db1_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_db1_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_db1) -> C_CAN_canif2_db1_Update<'a> {
        C_CAN_canif2_db1_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_db1) -> C_CAN_canif2_db1_Update<'a> {
        C_CAN_canif2_db1_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA4` field.
    #[inline(always)]
    pub fn set_data4<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_db1_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA5` field.
    #[inline(always)]
    pub fn set_data5<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_db1_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF1_DB2 implementation


/// Register `CANIF1_DB2`: Message interface 1 data B2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif1_db2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif1_db2 { }

impl C_CAN_canif1_db2 {
    
    // Getters
    /// Fetch the value of the `CANIF1_DB2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif1_db2_Get {
        C_CAN_canif1_db2_Get::new(self)
    }

    
    /// Get value of `DATA6` field.
    #[inline(always)]
    pub fn data6(&self) -> u32 {
        C_CAN_canif1_db2_Get::new(self).data6()
    }
    
    /// Get value of `DATA7` field.
    #[inline(always)]
    pub fn data7(&self) -> u32 {
        C_CAN_canif1_db2_Get::new(self).data7()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF1_DB2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif1_db2_Update {
        C_CAN_canif1_db2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA6` field.
    #[inline(always)]
    pub fn set_data6<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_db2_Update<'a> {
        let mut setter: C_CAN_canif1_db2_Update = C_CAN_canif1_db2_Update::new(self);
        setter.set_data6(new_value);
        setter
    }
    
    /// Set value of `DATA7` field.
    #[inline(always)]
    pub fn set_data7<'a>(&'a mut self, new_value: u32) -> C_CAN_canif1_db2_Update<'a> {
        let mut setter: C_CAN_canif1_db2_Update = C_CAN_canif1_db2_Update::new(self);
        setter.set_data7(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif1_db2
/// `CANIF1_DB2`: Message interface 1 data B2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_db2_Get {
    value: u32,
}

impl C_CAN_canif1_db2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif1_db2) -> C_CAN_canif1_db2_Get {
        C_CAN_canif1_db2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA6` field: Data byte 6
    #[inline(always)]
    pub fn data6(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA7` field: Data byte 7
    #[inline(always)]
    pub fn data7(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif1_db2_Get { }


// Updater for C_CAN_canif1_db2
/// Updater for `CANIF1_DB2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif1_db2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif1_db2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif1_db2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif1_db2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif1_db2) -> C_CAN_canif1_db2_Update<'a> {
        C_CAN_canif1_db2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif1_db2) -> C_CAN_canif1_db2_Update<'a> {
        C_CAN_canif1_db2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA6` field.
    #[inline(always)]
    pub fn set_data6<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_db2_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA7` field.
    #[inline(always)]
    pub fn set_data7<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif1_db2_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANIF2_DB2 implementation


/// Register `CANIF2_DB2`: Message interface 1 data B2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canif2_db2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canif2_db2 { }

impl C_CAN_canif2_db2 {
    
    // Getters
    /// Fetch the value of the `CANIF2_DB2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canif2_db2_Get {
        C_CAN_canif2_db2_Get::new(self)
    }

    
    /// Get value of `DATA6` field.
    #[inline(always)]
    pub fn data6(&self) -> u32 {
        C_CAN_canif2_db2_Get::new(self).data6()
    }
    
    /// Get value of `DATA7` field.
    #[inline(always)]
    pub fn data7(&self) -> u32 {
        C_CAN_canif2_db2_Get::new(self).data7()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANIF2_DB2` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canif2_db2_Update {
        C_CAN_canif2_db2_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA6` field.
    #[inline(always)]
    pub fn set_data6<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_db2_Update<'a> {
        let mut setter: C_CAN_canif2_db2_Update = C_CAN_canif2_db2_Update::new(self);
        setter.set_data6(new_value);
        setter
    }
    
    /// Set value of `DATA7` field.
    #[inline(always)]
    pub fn set_data7<'a>(&'a mut self, new_value: u32) -> C_CAN_canif2_db2_Update<'a> {
        let mut setter: C_CAN_canif2_db2_Update = C_CAN_canif2_db2_Update::new(self);
        setter.set_data7(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canif2_db2
/// `CANIF2_DB2`: Message interface 1 data B2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_db2_Get {
    value: u32,
}

impl C_CAN_canif2_db2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canif2_db2) -> C_CAN_canif2_db2_Get {
        C_CAN_canif2_db2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA6` field: Data byte 6
    #[inline(always)]
    pub fn data6(&self) -> u32 {
        (self.value >> 0) & 255
        }
    /// Get value of `DATA7` field: Data byte 7
    #[inline(always)]
    pub fn data7(&self) -> u32 {
        (self.value >> 8) & 255
        }
    }

impl ::core::marker::Copy for C_CAN_canif2_db2_Get { }


// Updater for C_CAN_canif2_db2
/// Updater for `CANIF2_DB2` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canif2_db2_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canif2_db2,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canif2_db2_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canif2_db2_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canif2_db2) -> C_CAN_canif2_db2_Update<'a> {
        C_CAN_canif2_db2_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canif2_db2) -> C_CAN_canif2_db2_Update<'a> {
        C_CAN_canif2_db2_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA6` field.
    #[inline(always)]
    pub fn set_data6<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_db2_Update<'a> {
        self.value = (self.value & !(255 << 0))
                   | ((new_value as u32) & 255) << 0;
        self.mask |= 255 << 0;
        self
    }
    /// Set value of `DATA7` field.
    #[inline(always)]
    pub fn set_data7<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canif2_db2_Update<'a> {
        self.value = (self.value & !(255 << 8))
                   | ((new_value as u32) & 255) << 8;
        self.mask |= 255 << 8;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register CANTXREQ1 implementation


/// Register `CANTXREQ1`: Transmission request 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_cantxreq1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_cantxreq1 { }

impl C_CAN_cantxreq1 {
    
    // Getters
    /// Fetch the value of the `CANTXREQ1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_cantxreq1_Get {
        C_CAN_cantxreq1_Get::new(self)
    }

    
    /// Get value of `TXRQST_16_1` field.
    #[inline(always)]
    pub fn txrqst_16_1(&self) -> u32 {
        C_CAN_cantxreq1_Get::new(self).txrqst_16_1()
    }
    

    }


// Getter for C_CAN_cantxreq1
/// `CANTXREQ1`: Transmission request 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_cantxreq1_Get {
    value: u32,
}

impl C_CAN_cantxreq1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_cantxreq1) -> C_CAN_cantxreq1_Get {
        C_CAN_cantxreq1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TXRQST_16_1` field: Transmission request bit of message objects 16 to 1. 0 = This message object is not waiting for transmission. 1 = The transmission of this message object is requested and not yet done.
    #[inline(always)]
    pub fn txrqst_16_1(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_cantxreq1_Get { }







// Register CANTXREQ2 implementation


/// Register `CANTXREQ2`: Transmission request 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_cantxreq2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_cantxreq2 { }

impl C_CAN_cantxreq2 {
    
    // Getters
    /// Fetch the value of the `CANTXREQ2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_cantxreq2_Get {
        C_CAN_cantxreq2_Get::new(self)
    }

    
    /// Get value of `TXRQST_32_17` field.
    #[inline(always)]
    pub fn txrqst_32_17(&self) -> u32 {
        C_CAN_cantxreq2_Get::new(self).txrqst_32_17()
    }
    

    }


// Getter for C_CAN_cantxreq2
/// `CANTXREQ2`: Transmission request 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_cantxreq2_Get {
    value: u32,
}

impl C_CAN_cantxreq2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_cantxreq2) -> C_CAN_cantxreq2_Get {
        C_CAN_cantxreq2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `TXRQST_32_17` field: Transmission request bit of message objects 32 to 17. 0 = This message object is not waiting for transmission. 1 = The transmission of this message object is requested and not yet done.
    #[inline(always)]
    pub fn txrqst_32_17(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_cantxreq2_Get { }







// Register CANND1 implementation


/// Register `CANND1`: New data 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_cannd1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_cannd1 { }

impl C_CAN_cannd1 {
    
    // Getters
    /// Fetch the value of the `CANND1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_cannd1_Get {
        C_CAN_cannd1_Get::new(self)
    }

    
    /// Get value of `NEWDAT_16_1` field.
    #[inline(always)]
    pub fn newdat_16_1(&self) -> u32 {
        C_CAN_cannd1_Get::new(self).newdat_16_1()
    }
    

    }


// Getter for C_CAN_cannd1
/// `CANND1`: New data 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_cannd1_Get {
    value: u32,
}

impl C_CAN_cannd1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_cannd1) -> C_CAN_cannd1_Get {
        C_CAN_cannd1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `NEWDAT_16_1` field: New data bits of message objects 16 to 1. 0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the CPU. 1 = The Message Handler or the CPU has written new data into the data portion of this Message Object.
    #[inline(always)]
    pub fn newdat_16_1(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_cannd1_Get { }







// Register CANND2 implementation


/// Register `CANND2`: New data 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_cannd2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_cannd2 { }

impl C_CAN_cannd2 {
    
    // Getters
    /// Fetch the value of the `CANND2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_cannd2_Get {
        C_CAN_cannd2_Get::new(self)
    }

    
    /// Get value of `NEWDAT_32_17` field.
    #[inline(always)]
    pub fn newdat_32_17(&self) -> u32 {
        C_CAN_cannd2_Get::new(self).newdat_32_17()
    }
    

    }


// Getter for C_CAN_cannd2
/// `CANND2`: New data 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_cannd2_Get {
    value: u32,
}

impl C_CAN_cannd2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_cannd2) -> C_CAN_cannd2_Get {
        C_CAN_cannd2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `NEWDAT_32_17` field: New data bits of message objects 32 to 17. 0 = No new data has been written into the data portion of this Message Object by the Message Handler since last time this flag was cleared by the CPU. 1 = The Message Handler or the CPU has written new data into the data portion of this Message Object.
    #[inline(always)]
    pub fn newdat_32_17(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_cannd2_Get { }







// Register CANIR1 implementation


/// Register `CANIR1`: Interrupt pending 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canir1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canir1 { }

impl C_CAN_canir1 {
    
    // Getters
    /// Fetch the value of the `CANIR1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canir1_Get {
        C_CAN_canir1_Get::new(self)
    }

    
    /// Get value of `INTPND_16_1` field.
    #[inline(always)]
    pub fn intpnd_16_1(&self) -> u32 {
        C_CAN_canir1_Get::new(self).intpnd_16_1()
    }
    

    }


// Getter for C_CAN_canir1
/// `CANIR1`: Interrupt pending 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canir1_Get {
    value: u32,
}

impl C_CAN_canir1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canir1) -> C_CAN_canir1_Get {
        C_CAN_canir1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `INTPND_16_1` field: Interrupt pending bits of message objects 16 to 1. 0 = This message object is ignored by the message handler. 1 = This message object is the source of an interrupt.
    #[inline(always)]
    pub fn intpnd_16_1(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_canir1_Get { }







// Register CANIR2 implementation


/// Register `CANIR2`: Interrupt pending 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canir2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canir2 { }

impl C_CAN_canir2 {
    
    // Getters
    /// Fetch the value of the `CANIR2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canir2_Get {
        C_CAN_canir2_Get::new(self)
    }

    
    /// Get value of `INTPND_32_17` field.
    #[inline(always)]
    pub fn intpnd_32_17(&self) -> u32 {
        C_CAN_canir2_Get::new(self).intpnd_32_17()
    }
    

    }


// Getter for C_CAN_canir2
/// `CANIR2`: Interrupt pending 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canir2_Get {
    value: u32,
}

impl C_CAN_canir2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canir2) -> C_CAN_canir2_Get {
        C_CAN_canir2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `INTPND_32_17` field: Interrupt pending bits of message objects 32 to 17. 0 = This message object is ignored by the message handler. 1 = This message object is the source of an interrupt.
    #[inline(always)]
    pub fn intpnd_32_17(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_canir2_Get { }







// Register CANMSGV1 implementation


/// Register `CANMSGV1`: Message valid 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canmsgv1 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canmsgv1 { }

impl C_CAN_canmsgv1 {
    
    // Getters
    /// Fetch the value of the `CANMSGV1` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canmsgv1_Get {
        C_CAN_canmsgv1_Get::new(self)
    }

    
    /// Get value of `MSGVAL_16_1` field.
    #[inline(always)]
    pub fn msgval_16_1(&self) -> u32 {
        C_CAN_canmsgv1_Get::new(self).msgval_16_1()
    }
    

    }


// Getter for C_CAN_canmsgv1
/// `CANMSGV1`: Message valid 1
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canmsgv1_Get {
    value: u32,
}

impl C_CAN_canmsgv1_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canmsgv1) -> C_CAN_canmsgv1_Get {
        C_CAN_canmsgv1_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MSGVAL_16_1` field: Message valid bits of message objects 16 to 1. 0 = This message object is ignored by the message handler. 1 = This message object is configured and should be considered by the message handler.
    #[inline(always)]
    pub fn msgval_16_1(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_canmsgv1_Get { }







// Register CANMSGV2 implementation


/// Register `CANMSGV2`: Message valid 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canmsgv2 {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canmsgv2 { }

impl C_CAN_canmsgv2 {
    
    // Getters
    /// Fetch the value of the `CANMSGV2` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canmsgv2_Get {
        C_CAN_canmsgv2_Get::new(self)
    }

    
    /// Get value of `MSGVAL_32_17` field.
    #[inline(always)]
    pub fn msgval_32_17(&self) -> u32 {
        C_CAN_canmsgv2_Get::new(self).msgval_32_17()
    }
    

    }


// Getter for C_CAN_canmsgv2
/// `CANMSGV2`: Message valid 2
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canmsgv2_Get {
    value: u32,
}

impl C_CAN_canmsgv2_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canmsgv2) -> C_CAN_canmsgv2_Get {
        C_CAN_canmsgv2_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MSGVAL_32_17` field: Message valid bits of message objects 32 to 17. 0 = This message object is ignored by the message handler. 1 = This message object is configured and should be considered by the message handler.
    #[inline(always)]
    pub fn msgval_32_17(&self) -> u32 {
        (self.value >> 0) & 65535
        }
    }

impl ::core::marker::Copy for C_CAN_canmsgv2_Get { }







// Register CANCLKDIV implementation


/// Register `CANCLKDIV`: Can clock divider register
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct C_CAN_canclkdiv {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for C_CAN_canclkdiv { }

impl C_CAN_canclkdiv {
    
    // Getters
    /// Fetch the value of the `CANCLKDIV` register.
    #[inline(always)]
    pub fn get(&self) -> C_CAN_canclkdiv_Get {
        C_CAN_canclkdiv_Get::new(self)
    }

    
    /// Get value of `CLKDIVVAL` field.
    #[inline(always)]
    pub fn clkdivval(&self) -> u32 {
        C_CAN_canclkdiv_Get::new(self).clkdivval()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `CANCLKDIV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> C_CAN_canclkdiv_Update {
        C_CAN_canclkdiv_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CLKDIVVAL` field.
    #[inline(always)]
    pub fn set_clkdivval<'a>(&'a mut self, new_value: u32) -> C_CAN_canclkdiv_Update<'a> {
        let mut setter: C_CAN_canclkdiv_Update = C_CAN_canclkdiv_Update::new(self);
        setter.set_clkdivval(new_value);
        setter
    }
    

    }


// Getter for C_CAN_canclkdiv
/// `CANCLKDIV`: Can clock divider register
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct C_CAN_canclkdiv_Get {
    value: u32,
}

impl C_CAN_canclkdiv_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &C_CAN_canclkdiv) -> C_CAN_canclkdiv_Get {
        C_CAN_canclkdiv_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `CLKDIVVAL` field: Clock divider value. CAN_CLK = PCLK/(CLKDIVVAL +1) 0000: CAN_CLK = PCLK divided by 1. 0001: CAN_CLK = PCLK divided by 2. 0010: CAN_CLK = PCLK divided by 3 0010: CAN_CLK = PCLK divided by 4. ... 1111: CAN_CLK = PCLK divided by 16.
    #[inline(always)]
    pub fn clkdivval(&self) -> u32 {
        (self.value >> 0) & 15
        }
    }

impl ::core::marker::Copy for C_CAN_canclkdiv_Get { }


// Updater for C_CAN_canclkdiv
/// Updater for `CANCLKDIV` register.
#[allow(non_camel_case_types)]
pub struct C_CAN_canclkdiv_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a C_CAN_canclkdiv,
}

/// This performs the register update.
impl <'a> Drop for C_CAN_canclkdiv_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> C_CAN_canclkdiv_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a C_CAN_canclkdiv) -> C_CAN_canclkdiv_Update<'a> {
        C_CAN_canclkdiv_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a C_CAN_canclkdiv) -> C_CAN_canclkdiv_Update<'a> {
        C_CAN_canclkdiv_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CLKDIVVAL` field.
    #[inline(always)]
    pub fn set_clkdivval<'b>(&'b mut self, new_value: u32) -> &'b mut C_CAN_canclkdiv_Update<'a> {
        self.value = (self.value & !(15 << 0))
                   | ((new_value as u32) & 15) << 0;
        self.mask |= 15 << 0;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral C_CAN implementation

/// Product name title=UM10398 Chapter title=LPC111x/LPC11Cxx C_CAN controller Modification date=9/19/2011 Major revision=7 Minor revision=not available 
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct C_CAN;

impl C_CAN {
    /// CAN control
    #[inline(always)]
    pub fn cancntl() -> &'static mut C_CAN_cancntl {
        unsafe { ::core::intrinsics::transmute(0x40050000 as usize) }
    }
    /// Status register
    #[inline(always)]
    pub fn canstat() -> &'static mut C_CAN_canstat {
        unsafe { ::core::intrinsics::transmute(0x40050004 as usize) }
    }
    /// Error counter
    #[inline(always)]
    pub fn canec() -> &'static mut C_CAN_canec {
        unsafe { ::core::intrinsics::transmute(0x40050008 as usize) }
    }
    /// Bit timing register
    #[inline(always)]
    pub fn canbt() -> &'static mut C_CAN_canbt {
        unsafe { ::core::intrinsics::transmute(0x4005000c as usize) }
    }
    /// Interrupt register
    #[inline(always)]
    pub fn canint() -> &'static mut C_CAN_canint {
        unsafe { ::core::intrinsics::transmute(0x40050010 as usize) }
    }
    /// Test register
    #[inline(always)]
    pub fn cantest() -> &'static mut C_CAN_cantest {
        unsafe { ::core::intrinsics::transmute(0x40050014 as usize) }
    }
    /// Baud rate prescaler extension register
    #[inline(always)]
    pub fn canbrpe() -> &'static mut C_CAN_canbrpe {
        unsafe { ::core::intrinsics::transmute(0x40050018 as usize) }
    }
    /// Message interface  command request
    #[inline(always)]
    pub fn canif1_cmdreq() -> &'static mut C_CAN_canif1_cmdreq {
        unsafe { ::core::intrinsics::transmute(0x40050020 as usize) }
    }
    /// Message interface  command request
    #[inline(always)]
    pub fn canif2_cmdreq() -> &'static mut C_CAN_canif2_cmdreq {
        unsafe { ::core::intrinsics::transmute(0x40050080 as usize) }
    }
    /// Message interface command mask - write direction
    #[inline(always)]
    pub fn canif1_cmdmsk_w() -> &'static mut C_CAN_canif1_cmdmsk_w {
        unsafe { ::core::intrinsics::transmute(0x40050024 as usize) }
    }
    /// Message interface command mask - write direction
    #[inline(always)]
    pub fn canif2_cmdmsk_w() -> &'static mut C_CAN_canif2_cmdmsk_w {
        unsafe { ::core::intrinsics::transmute(0x40050084 as usize) }
    }
    /// Message interface  command mask - read direction
    #[inline(always)]
    pub fn canif1_cmdmsk_r() -> &'static mut C_CAN_canif1_cmdmsk_r {
        unsafe { ::core::intrinsics::transmute(0x40050024 as usize) }
    }
    /// Message interface  command mask - read direction
    #[inline(always)]
    pub fn canif2_cmdmsk_r() -> &'static mut C_CAN_canif2_cmdmsk_r {
        unsafe { ::core::intrinsics::transmute(0x40050084 as usize) }
    }
    /// Message interface 1 mask 1
    #[inline(always)]
    pub fn canif1_msk1() -> &'static mut C_CAN_canif1_msk1 {
        unsafe { ::core::intrinsics::transmute(0x40050028 as usize) }
    }
    /// Message interface 1 mask 1
    #[inline(always)]
    pub fn canif2_msk1() -> &'static mut C_CAN_canif2_msk1 {
        unsafe { ::core::intrinsics::transmute(0x40050088 as usize) }
    }
    /// Message interface 1 mask 2
    #[inline(always)]
    pub fn canif1_msk2() -> &'static mut C_CAN_canif1_msk2 {
        unsafe { ::core::intrinsics::transmute(0x4005002c as usize) }
    }
    /// Message interface 1 mask 2
    #[inline(always)]
    pub fn canif2_msk2() -> &'static mut C_CAN_canif2_msk2 {
        unsafe { ::core::intrinsics::transmute(0x4005008c as usize) }
    }
    /// Message interface 1 arbitration 1
    #[inline(always)]
    pub fn canif1_arb1() -> &'static mut C_CAN_canif1_arb1 {
        unsafe { ::core::intrinsics::transmute(0x40050030 as usize) }
    }
    /// Message interface 1 arbitration 1
    #[inline(always)]
    pub fn canif2_arb1() -> &'static mut C_CAN_canif2_arb1 {
        unsafe { ::core::intrinsics::transmute(0x40050090 as usize) }
    }
    /// Message interface 1 arbitration 2
    #[inline(always)]
    pub fn canif1_arb2() -> &'static mut C_CAN_canif1_arb2 {
        unsafe { ::core::intrinsics::transmute(0x40050034 as usize) }
    }
    /// Message interface 1 arbitration 2
    #[inline(always)]
    pub fn canif2_arb2() -> &'static mut C_CAN_canif2_arb2 {
        unsafe { ::core::intrinsics::transmute(0x40050094 as usize) }
    }
    /// Message interface 1 message control
    #[inline(always)]
    pub fn canif1_mctrl() -> &'static mut C_CAN_canif1_mctrl {
        unsafe { ::core::intrinsics::transmute(0x40050038 as usize) }
    }
    /// Message interface 1 message control
    #[inline(always)]
    pub fn canif2_mctrl() -> &'static mut C_CAN_canif2_mctrl {
        unsafe { ::core::intrinsics::transmute(0x40050098 as usize) }
    }
    /// Message interface 1 data A1
    #[inline(always)]
    pub fn canif1_da1() -> &'static mut C_CAN_canif1_da1 {
        unsafe { ::core::intrinsics::transmute(0x4005003c as usize) }
    }
    /// Message interface 1 data A1
    #[inline(always)]
    pub fn canif2_da1() -> &'static mut C_CAN_canif2_da1 {
        unsafe { ::core::intrinsics::transmute(0x4005009c as usize) }
    }
    /// Message interface 1 data A2
    #[inline(always)]
    pub fn canif1_da2() -> &'static mut C_CAN_canif1_da2 {
        unsafe { ::core::intrinsics::transmute(0x40050040 as usize) }
    }
    /// Message interface 1 data A2
    #[inline(always)]
    pub fn canif2_da2() -> &'static mut C_CAN_canif2_da2 {
        unsafe { ::core::intrinsics::transmute(0x400500a0 as usize) }
    }
    /// Message interface 1 data B1
    #[inline(always)]
    pub fn canif1_db1() -> &'static mut C_CAN_canif1_db1 {
        unsafe { ::core::intrinsics::transmute(0x40050044 as usize) }
    }
    /// Message interface 1 data B1
    #[inline(always)]
    pub fn canif2_db1() -> &'static mut C_CAN_canif2_db1 {
        unsafe { ::core::intrinsics::transmute(0x400500a4 as usize) }
    }
    /// Message interface 1 data B2
    #[inline(always)]
    pub fn canif1_db2() -> &'static mut C_CAN_canif1_db2 {
        unsafe { ::core::intrinsics::transmute(0x40050048 as usize) }
    }
    /// Message interface 1 data B2
    #[inline(always)]
    pub fn canif2_db2() -> &'static mut C_CAN_canif2_db2 {
        unsafe { ::core::intrinsics::transmute(0x400500a8 as usize) }
    }
    /// Transmission request 1
    #[inline(always)]
    pub fn cantxreq1() -> &'static mut C_CAN_cantxreq1 {
        unsafe { ::core::intrinsics::transmute(0x40050100 as usize) }
    }
    /// Transmission request 2
    #[inline(always)]
    pub fn cantxreq2() -> &'static mut C_CAN_cantxreq2 {
        unsafe { ::core::intrinsics::transmute(0x40050104 as usize) }
    }
    /// New data 1
    #[inline(always)]
    pub fn cannd1() -> &'static mut C_CAN_cannd1 {
        unsafe { ::core::intrinsics::transmute(0x40050120 as usize) }
    }
    /// New data 2
    #[inline(always)]
    pub fn cannd2() -> &'static mut C_CAN_cannd2 {
        unsafe { ::core::intrinsics::transmute(0x40050124 as usize) }
    }
    /// Interrupt pending 1
    #[inline(always)]
    pub fn canir1() -> &'static mut C_CAN_canir1 {
        unsafe { ::core::intrinsics::transmute(0x40050140 as usize) }
    }
    /// Interrupt pending 2
    #[inline(always)]
    pub fn canir2() -> &'static mut C_CAN_canir2 {
        unsafe { ::core::intrinsics::transmute(0x40050144 as usize) }
    }
    /// Message valid 1
    #[inline(always)]
    pub fn canmsgv1() -> &'static mut C_CAN_canmsgv1 {
        unsafe { ::core::intrinsics::transmute(0x40050160 as usize) }
    }
    /// Message valid 2
    #[inline(always)]
    pub fn canmsgv2() -> &'static mut C_CAN_canmsgv2 {
        unsafe { ::core::intrinsics::transmute(0x40050164 as usize) }
    }
    /// Can clock divider register
    #[inline(always)]
    pub fn canclkdiv() -> &'static mut C_CAN_canclkdiv {
        unsafe { ::core::intrinsics::transmute(0x40050180 as usize) }
    }
    }



// Registers for SPI1





















// Peripheral SPI1 implementation

/// LPC11xx, LPC11Cxx, LPC11xxL, LPC11xxXL
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct SPI1;

impl SPI1 {
    /// Control Register 0. Selects the serial clock rate, bus type, and data size.
    #[inline(always)]
    pub fn cr0() -> &'static mut SPI0_cr0 {
        unsafe { ::core::intrinsics::transmute(0x40058000 as usize) }
    }
    /// Control Register 1. Selects master/slave and other modes.
    #[inline(always)]
    pub fn cr1() -> &'static mut SPI0_cr1 {
        unsafe { ::core::intrinsics::transmute(0x40058004 as usize) }
    }
    /// Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO.
    #[inline(always)]
    pub fn dr() -> &'static mut SPI0_dr {
        unsafe { ::core::intrinsics::transmute(0x40058008 as usize) }
    }
    /// Status Register
    #[inline(always)]
    pub fn sr() -> &'static mut SPI0_sr {
        unsafe { ::core::intrinsics::transmute(0x4005800c as usize) }
    }
    /// Clock Prescale Register
    #[inline(always)]
    pub fn cpsr() -> &'static mut SPI0_cpsr {
        unsafe { ::core::intrinsics::transmute(0x40058010 as usize) }
    }
    /// Interrupt Mask Set and Clear Register
    #[inline(always)]
    pub fn imsc() -> &'static mut SPI0_imsc {
        unsafe { ::core::intrinsics::transmute(0x40058014 as usize) }
    }
    /// Raw Interrupt Status Register
    #[inline(always)]
    pub fn ris() -> &'static mut SPI0_ris {
        unsafe { ::core::intrinsics::transmute(0x40058018 as usize) }
    }
    /// Masked Interrupt Status Register
    #[inline(always)]
    pub fn mis() -> &'static mut SPI0_mis {
        unsafe { ::core::intrinsics::transmute(0x4005801c as usize) }
    }
    /// SSPICR Interrupt Clear Register
    #[inline(always)]
    pub fn icr() -> &'static mut SPI0_icr {
        unsafe { ::core::intrinsics::transmute(0x40058020 as usize) }
    }
    }



// Registers for GPIO0





// Register DATA implementation


/// Register `DATA`: Port n data register for pins PIOn_0 to PIOn_11
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_data {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_data { }

impl GPIO0_data {
    
    // Getters
    /// Fetch the value of the `DATA` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_data_Get {
        GPIO0_data_Get::new(self)
    }

    
    /// Get value of `DATA0` field.
    #[inline(always)]
    pub fn data0(&self) -> bool {
        GPIO0_data_Get::new(self).data0()
    }
    
    /// Get value of `DATA1` field.
    #[inline(always)]
    pub fn data1(&self) -> bool {
        GPIO0_data_Get::new(self).data1()
    }
    
    /// Get value of `DATA2` field.
    #[inline(always)]
    pub fn data2(&self) -> bool {
        GPIO0_data_Get::new(self).data2()
    }
    
    /// Get value of `DATA3` field.
    #[inline(always)]
    pub fn data3(&self) -> bool {
        GPIO0_data_Get::new(self).data3()
    }
    
    /// Get value of `DATA4` field.
    #[inline(always)]
    pub fn data4(&self) -> bool {
        GPIO0_data_Get::new(self).data4()
    }
    
    /// Get value of `DATA5` field.
    #[inline(always)]
    pub fn data5(&self) -> bool {
        GPIO0_data_Get::new(self).data5()
    }
    
    /// Get value of `DATA6` field.
    #[inline(always)]
    pub fn data6(&self) -> bool {
        GPIO0_data_Get::new(self).data6()
    }
    
    /// Get value of `DATA7` field.
    #[inline(always)]
    pub fn data7(&self) -> bool {
        GPIO0_data_Get::new(self).data7()
    }
    
    /// Get value of `DATA8` field.
    #[inline(always)]
    pub fn data8(&self) -> bool {
        GPIO0_data_Get::new(self).data8()
    }
    
    /// Get value of `DATA9` field.
    #[inline(always)]
    pub fn data9(&self) -> bool {
        GPIO0_data_Get::new(self).data9()
    }
    
    /// Get value of `DATA10` field.
    #[inline(always)]
    pub fn data10(&self) -> bool {
        GPIO0_data_Get::new(self).data10()
    }
    
    /// Get value of `DATA11` field.
    #[inline(always)]
    pub fn data11(&self) -> bool {
        GPIO0_data_Get::new(self).data11()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DATA` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> GPIO0_data_Update {
        GPIO0_data_Update::new_ignoring_state(self)
    }

    
    /// Set value of `DATA0` field.
    #[inline(always)]
    pub fn set_data0<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data0(new_value);
        setter
    }
    
    /// Set value of `DATA1` field.
    #[inline(always)]
    pub fn set_data1<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data1(new_value);
        setter
    }
    
    /// Set value of `DATA2` field.
    #[inline(always)]
    pub fn set_data2<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data2(new_value);
        setter
    }
    
    /// Set value of `DATA3` field.
    #[inline(always)]
    pub fn set_data3<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data3(new_value);
        setter
    }
    
    /// Set value of `DATA4` field.
    #[inline(always)]
    pub fn set_data4<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data4(new_value);
        setter
    }
    
    /// Set value of `DATA5` field.
    #[inline(always)]
    pub fn set_data5<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data5(new_value);
        setter
    }
    
    /// Set value of `DATA6` field.
    #[inline(always)]
    pub fn set_data6<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data6(new_value);
        setter
    }
    
    /// Set value of `DATA7` field.
    #[inline(always)]
    pub fn set_data7<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data7(new_value);
        setter
    }
    
    /// Set value of `DATA8` field.
    #[inline(always)]
    pub fn set_data8<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data8(new_value);
        setter
    }
    
    /// Set value of `DATA9` field.
    #[inline(always)]
    pub fn set_data9<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data9(new_value);
        setter
    }
    
    /// Set value of `DATA10` field.
    #[inline(always)]
    pub fn set_data10<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data10(new_value);
        setter
    }
    
    /// Set value of `DATA11` field.
    #[inline(always)]
    pub fn set_data11<'a>(&'a mut self, new_value: bool) -> GPIO0_data_Update<'a> {
        let mut setter: GPIO0_data_Update = GPIO0_data_Update::new(self);
        setter.set_data11(new_value);
        setter
    }
    

    }


// Getter for GPIO0_data
/// `DATA`: Port n data register for pins PIOn_0 to PIOn_11
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_data_Get {
    value: u32,
}

impl GPIO0_data_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_data) -> GPIO0_data_Get {
        GPIO0_data_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `DATA0` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `DATA1` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `DATA2` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `DATA3` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `DATA4` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `DATA5` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `DATA6` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `DATA7` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `DATA8` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `DATA9` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `DATA10` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `DATA11` field: Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0.
    #[inline(always)]
    pub fn data11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_data_Get { }


// Updater for GPIO0_data
/// Updater for `DATA` register.
#[allow(non_camel_case_types)]
pub struct GPIO0_data_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a GPIO0_data,
}

/// This performs the register update.
impl <'a> Drop for GPIO0_data_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> GPIO0_data_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a GPIO0_data) -> GPIO0_data_Update<'a> {
        GPIO0_data_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a GPIO0_data) -> GPIO0_data_Update<'a> {
        GPIO0_data_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `DATA0` field.
    #[inline(always)]
    pub fn set_data0<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `DATA1` field.
    #[inline(always)]
    pub fn set_data1<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `DATA2` field.
    #[inline(always)]
    pub fn set_data2<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `DATA3` field.
    #[inline(always)]
    pub fn set_data3<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `DATA4` field.
    #[inline(always)]
    pub fn set_data4<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `DATA5` field.
    #[inline(always)]
    pub fn set_data5<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `DATA6` field.
    #[inline(always)]
    pub fn set_data6<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `DATA7` field.
    #[inline(always)]
    pub fn set_data7<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `DATA8` field.
    #[inline(always)]
    pub fn set_data8<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `DATA9` field.
    #[inline(always)]
    pub fn set_data9<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `DATA10` field.
    #[inline(always)]
    pub fn set_data10<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `DATA11` field.
    #[inline(always)]
    pub fn set_data11<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_data_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register DIR implementation


/// Register `DIR`: Data direction register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_dir {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_dir { }

impl GPIO0_dir {
    
    // Getters
    /// Fetch the value of the `DIR` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_dir_Get {
        GPIO0_dir_Get::new(self)
    }

    
    /// Get value of `IO0` field.
    #[inline(always)]
    pub fn io0(&self) -> bool {
        GPIO0_dir_Get::new(self).io0()
    }
    
    /// Get value of `IO1` field.
    #[inline(always)]
    pub fn io1(&self) -> bool {
        GPIO0_dir_Get::new(self).io1()
    }
    
    /// Get value of `IO2` field.
    #[inline(always)]
    pub fn io2(&self) -> bool {
        GPIO0_dir_Get::new(self).io2()
    }
    
    /// Get value of `IO3` field.
    #[inline(always)]
    pub fn io3(&self) -> bool {
        GPIO0_dir_Get::new(self).io3()
    }
    
    /// Get value of `IO4` field.
    #[inline(always)]
    pub fn io4(&self) -> bool {
        GPIO0_dir_Get::new(self).io4()
    }
    
    /// Get value of `IO5` field.
    #[inline(always)]
    pub fn io5(&self) -> bool {
        GPIO0_dir_Get::new(self).io5()
    }
    
    /// Get value of `IO6` field.
    #[inline(always)]
    pub fn io6(&self) -> bool {
        GPIO0_dir_Get::new(self).io6()
    }
    
    /// Get value of `IO7` field.
    #[inline(always)]
    pub fn io7(&self) -> bool {
        GPIO0_dir_Get::new(self).io7()
    }
    
    /// Get value of `IO8` field.
    #[inline(always)]
    pub fn io8(&self) -> bool {
        GPIO0_dir_Get::new(self).io8()
    }
    
    /// Get value of `IO9` field.
    #[inline(always)]
    pub fn io9(&self) -> bool {
        GPIO0_dir_Get::new(self).io9()
    }
    
    /// Get value of `IO10` field.
    #[inline(always)]
    pub fn io10(&self) -> bool {
        GPIO0_dir_Get::new(self).io10()
    }
    
    /// Get value of `IO11` field.
    #[inline(always)]
    pub fn io11(&self) -> bool {
        GPIO0_dir_Get::new(self).io11()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `DIR` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> GPIO0_dir_Update {
        GPIO0_dir_Update::new_ignoring_state(self)
    }

    
    /// Set value of `IO0` field.
    #[inline(always)]
    pub fn set_io0<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io0(new_value);
        setter
    }
    
    /// Set value of `IO1` field.
    #[inline(always)]
    pub fn set_io1<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io1(new_value);
        setter
    }
    
    /// Set value of `IO2` field.
    #[inline(always)]
    pub fn set_io2<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io2(new_value);
        setter
    }
    
    /// Set value of `IO3` field.
    #[inline(always)]
    pub fn set_io3<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io3(new_value);
        setter
    }
    
    /// Set value of `IO4` field.
    #[inline(always)]
    pub fn set_io4<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io4(new_value);
        setter
    }
    
    /// Set value of `IO5` field.
    #[inline(always)]
    pub fn set_io5<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io5(new_value);
        setter
    }
    
    /// Set value of `IO6` field.
    #[inline(always)]
    pub fn set_io6<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io6(new_value);
        setter
    }
    
    /// Set value of `IO7` field.
    #[inline(always)]
    pub fn set_io7<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io7(new_value);
        setter
    }
    
    /// Set value of `IO8` field.
    #[inline(always)]
    pub fn set_io8<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io8(new_value);
        setter
    }
    
    /// Set value of `IO9` field.
    #[inline(always)]
    pub fn set_io9<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io9(new_value);
        setter
    }
    
    /// Set value of `IO10` field.
    #[inline(always)]
    pub fn set_io10<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io10(new_value);
        setter
    }
    
    /// Set value of `IO11` field.
    #[inline(always)]
    pub fn set_io11<'a>(&'a mut self, new_value: bool) -> GPIO0_dir_Update<'a> {
        let mut setter: GPIO0_dir_Update = GPIO0_dir_Update::new(self);
        setter.set_io11(new_value);
        setter
    }
    

    }


// Getter for GPIO0_dir
/// `DIR`: Data direction register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_dir_Get {
    value: u32,
}

impl GPIO0_dir_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_dir) -> GPIO0_dir_Get {
        GPIO0_dir_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `IO0` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `IO1` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `IO2` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `IO3` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `IO4` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `IO5` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `IO6` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `IO7` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `IO8` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `IO9` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `IO10` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `IO11` field: Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output.
    #[inline(always)]
    pub fn io11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_dir_Get { }


// Updater for GPIO0_dir
/// Updater for `DIR` register.
#[allow(non_camel_case_types)]
pub struct GPIO0_dir_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a GPIO0_dir,
}

/// This performs the register update.
impl <'a> Drop for GPIO0_dir_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> GPIO0_dir_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a GPIO0_dir) -> GPIO0_dir_Update<'a> {
        GPIO0_dir_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a GPIO0_dir) -> GPIO0_dir_Update<'a> {
        GPIO0_dir_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `IO0` field.
    #[inline(always)]
    pub fn set_io0<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `IO1` field.
    #[inline(always)]
    pub fn set_io1<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `IO2` field.
    #[inline(always)]
    pub fn set_io2<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `IO3` field.
    #[inline(always)]
    pub fn set_io3<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `IO4` field.
    #[inline(always)]
    pub fn set_io4<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `IO5` field.
    #[inline(always)]
    pub fn set_io5<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `IO6` field.
    #[inline(always)]
    pub fn set_io6<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `IO7` field.
    #[inline(always)]
    pub fn set_io7<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `IO8` field.
    #[inline(always)]
    pub fn set_io8<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `IO9` field.
    #[inline(always)]
    pub fn set_io9<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `IO10` field.
    #[inline(always)]
    pub fn set_io10<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `IO11` field.
    #[inline(always)]
    pub fn set_io11<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_dir_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register IS implementation


/// Register `IS`: Interrupt sense register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_is {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_is { }

impl GPIO0_is {
    
    // Getters
    /// Fetch the value of the `IS` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_is_Get {
        GPIO0_is_Get::new(self)
    }

    
    /// Get value of `ISENSE0` field.
    #[inline(always)]
    pub fn isense0(&self) -> bool {
        GPIO0_is_Get::new(self).isense0()
    }
    
    /// Get value of `ISENSE1` field.
    #[inline(always)]
    pub fn isense1(&self) -> bool {
        GPIO0_is_Get::new(self).isense1()
    }
    
    /// Get value of `ISENSE2` field.
    #[inline(always)]
    pub fn isense2(&self) -> bool {
        GPIO0_is_Get::new(self).isense2()
    }
    
    /// Get value of `ISENSE3` field.
    #[inline(always)]
    pub fn isense3(&self) -> bool {
        GPIO0_is_Get::new(self).isense3()
    }
    
    /// Get value of `ISENSE4` field.
    #[inline(always)]
    pub fn isense4(&self) -> bool {
        GPIO0_is_Get::new(self).isense4()
    }
    
    /// Get value of `ISENSE5` field.
    #[inline(always)]
    pub fn isense5(&self) -> bool {
        GPIO0_is_Get::new(self).isense5()
    }
    
    /// Get value of `ISENSE6` field.
    #[inline(always)]
    pub fn isense6(&self) -> bool {
        GPIO0_is_Get::new(self).isense6()
    }
    
    /// Get value of `ISENSE7` field.
    #[inline(always)]
    pub fn isense7(&self) -> bool {
        GPIO0_is_Get::new(self).isense7()
    }
    
    /// Get value of `ISENSE8` field.
    #[inline(always)]
    pub fn isense8(&self) -> bool {
        GPIO0_is_Get::new(self).isense8()
    }
    
    /// Get value of `ISENSE9` field.
    #[inline(always)]
    pub fn isense9(&self) -> bool {
        GPIO0_is_Get::new(self).isense9()
    }
    
    /// Get value of `ISENSE10` field.
    #[inline(always)]
    pub fn isense10(&self) -> bool {
        GPIO0_is_Get::new(self).isense10()
    }
    
    /// Get value of `ISENSE11` field.
    #[inline(always)]
    pub fn isense11(&self) -> bool {
        GPIO0_is_Get::new(self).isense11()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IS` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> GPIO0_is_Update {
        GPIO0_is_Update::new_ignoring_state(self)
    }

    
    /// Set value of `ISENSE0` field.
    #[inline(always)]
    pub fn set_isense0<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense0(new_value);
        setter
    }
    
    /// Set value of `ISENSE1` field.
    #[inline(always)]
    pub fn set_isense1<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense1(new_value);
        setter
    }
    
    /// Set value of `ISENSE2` field.
    #[inline(always)]
    pub fn set_isense2<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense2(new_value);
        setter
    }
    
    /// Set value of `ISENSE3` field.
    #[inline(always)]
    pub fn set_isense3<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense3(new_value);
        setter
    }
    
    /// Set value of `ISENSE4` field.
    #[inline(always)]
    pub fn set_isense4<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense4(new_value);
        setter
    }
    
    /// Set value of `ISENSE5` field.
    #[inline(always)]
    pub fn set_isense5<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense5(new_value);
        setter
    }
    
    /// Set value of `ISENSE6` field.
    #[inline(always)]
    pub fn set_isense6<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense6(new_value);
        setter
    }
    
    /// Set value of `ISENSE7` field.
    #[inline(always)]
    pub fn set_isense7<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense7(new_value);
        setter
    }
    
    /// Set value of `ISENSE8` field.
    #[inline(always)]
    pub fn set_isense8<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense8(new_value);
        setter
    }
    
    /// Set value of `ISENSE9` field.
    #[inline(always)]
    pub fn set_isense9<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense9(new_value);
        setter
    }
    
    /// Set value of `ISENSE10` field.
    #[inline(always)]
    pub fn set_isense10<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense10(new_value);
        setter
    }
    
    /// Set value of `ISENSE11` field.
    #[inline(always)]
    pub fn set_isense11<'a>(&'a mut self, new_value: bool) -> GPIO0_is_Update<'a> {
        let mut setter: GPIO0_is_Update = GPIO0_is_Update::new(self);
        setter.set_isense11(new_value);
        setter
    }
    

    }


// Getter for GPIO0_is
/// `IS`: Interrupt sense register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_is_Get {
    value: u32,
}

impl GPIO0_is_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_is) -> GPIO0_is_Get {
        GPIO0_is_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `ISENSE0` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `ISENSE1` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `ISENSE2` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `ISENSE3` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `ISENSE4` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `ISENSE5` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `ISENSE6` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `ISENSE7` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `ISENSE8` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `ISENSE9` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `ISENSE10` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `ISENSE11` field: Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive.
    #[inline(always)]
    pub fn isense11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_is_Get { }


// Updater for GPIO0_is
/// Updater for `IS` register.
#[allow(non_camel_case_types)]
pub struct GPIO0_is_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a GPIO0_is,
}

/// This performs the register update.
impl <'a> Drop for GPIO0_is_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> GPIO0_is_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a GPIO0_is) -> GPIO0_is_Update<'a> {
        GPIO0_is_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a GPIO0_is) -> GPIO0_is_Update<'a> {
        GPIO0_is_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `ISENSE0` field.
    #[inline(always)]
    pub fn set_isense0<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `ISENSE1` field.
    #[inline(always)]
    pub fn set_isense1<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `ISENSE2` field.
    #[inline(always)]
    pub fn set_isense2<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `ISENSE3` field.
    #[inline(always)]
    pub fn set_isense3<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `ISENSE4` field.
    #[inline(always)]
    pub fn set_isense4<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `ISENSE5` field.
    #[inline(always)]
    pub fn set_isense5<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `ISENSE6` field.
    #[inline(always)]
    pub fn set_isense6<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `ISENSE7` field.
    #[inline(always)]
    pub fn set_isense7<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `ISENSE8` field.
    #[inline(always)]
    pub fn set_isense8<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `ISENSE9` field.
    #[inline(always)]
    pub fn set_isense9<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `ISENSE10` field.
    #[inline(always)]
    pub fn set_isense10<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `ISENSE11` field.
    #[inline(always)]
    pub fn set_isense11<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_is_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register IBE implementation


/// Register `IBE`: Interrupt both edges register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_ibe {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_ibe { }

impl GPIO0_ibe {
    
    // Getters
    /// Fetch the value of the `IBE` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_ibe_Get {
        GPIO0_ibe_Get::new(self)
    }

    
    /// Get value of `IBE0` field.
    #[inline(always)]
    pub fn ibe0(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe0()
    }
    
    /// Get value of `IBE1` field.
    #[inline(always)]
    pub fn ibe1(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe1()
    }
    
    /// Get value of `IBE2` field.
    #[inline(always)]
    pub fn ibe2(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe2()
    }
    
    /// Get value of `IBE3` field.
    #[inline(always)]
    pub fn ibe3(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe3()
    }
    
    /// Get value of `IBE4` field.
    #[inline(always)]
    pub fn ibe4(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe4()
    }
    
    /// Get value of `IBE5` field.
    #[inline(always)]
    pub fn ibe5(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe5()
    }
    
    /// Get value of `IBE6` field.
    #[inline(always)]
    pub fn ibe6(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe6()
    }
    
    /// Get value of `IBE7` field.
    #[inline(always)]
    pub fn ibe7(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe7()
    }
    
    /// Get value of `IBE8` field.
    #[inline(always)]
    pub fn ibe8(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe8()
    }
    
    /// Get value of `IBE9` field.
    #[inline(always)]
    pub fn ibe9(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe9()
    }
    
    /// Get value of `IBE10` field.
    #[inline(always)]
    pub fn ibe10(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe10()
    }
    
    /// Get value of `IBE11` field.
    #[inline(always)]
    pub fn ibe11(&self) -> bool {
        GPIO0_ibe_Get::new(self).ibe11()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IBE` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> GPIO0_ibe_Update {
        GPIO0_ibe_Update::new_ignoring_state(self)
    }

    
    /// Set value of `IBE0` field.
    #[inline(always)]
    pub fn set_ibe0<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe0(new_value);
        setter
    }
    
    /// Set value of `IBE1` field.
    #[inline(always)]
    pub fn set_ibe1<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe1(new_value);
        setter
    }
    
    /// Set value of `IBE2` field.
    #[inline(always)]
    pub fn set_ibe2<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe2(new_value);
        setter
    }
    
    /// Set value of `IBE3` field.
    #[inline(always)]
    pub fn set_ibe3<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe3(new_value);
        setter
    }
    
    /// Set value of `IBE4` field.
    #[inline(always)]
    pub fn set_ibe4<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe4(new_value);
        setter
    }
    
    /// Set value of `IBE5` field.
    #[inline(always)]
    pub fn set_ibe5<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe5(new_value);
        setter
    }
    
    /// Set value of `IBE6` field.
    #[inline(always)]
    pub fn set_ibe6<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe6(new_value);
        setter
    }
    
    /// Set value of `IBE7` field.
    #[inline(always)]
    pub fn set_ibe7<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe7(new_value);
        setter
    }
    
    /// Set value of `IBE8` field.
    #[inline(always)]
    pub fn set_ibe8<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe8(new_value);
        setter
    }
    
    /// Set value of `IBE9` field.
    #[inline(always)]
    pub fn set_ibe9<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe9(new_value);
        setter
    }
    
    /// Set value of `IBE10` field.
    #[inline(always)]
    pub fn set_ibe10<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe10(new_value);
        setter
    }
    
    /// Set value of `IBE11` field.
    #[inline(always)]
    pub fn set_ibe11<'a>(&'a mut self, new_value: bool) -> GPIO0_ibe_Update<'a> {
        let mut setter: GPIO0_ibe_Update = GPIO0_ibe_Update::new(self);
        setter.set_ibe11(new_value);
        setter
    }
    

    }


// Getter for GPIO0_ibe
/// `IBE`: Interrupt both edges register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_ibe_Get {
    value: u32,
}

impl GPIO0_ibe_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_ibe) -> GPIO0_ibe_Get {
        GPIO0_ibe_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `IBE0` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `IBE1` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `IBE2` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `IBE3` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `IBE4` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `IBE5` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `IBE6` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `IBE7` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `IBE8` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `IBE9` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `IBE10` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `IBE11` field: Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOnIEV. 1 = Both edges on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn ibe11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_ibe_Get { }


// Updater for GPIO0_ibe
/// Updater for `IBE` register.
#[allow(non_camel_case_types)]
pub struct GPIO0_ibe_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a GPIO0_ibe,
}

/// This performs the register update.
impl <'a> Drop for GPIO0_ibe_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> GPIO0_ibe_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a GPIO0_ibe) -> GPIO0_ibe_Update<'a> {
        GPIO0_ibe_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a GPIO0_ibe) -> GPIO0_ibe_Update<'a> {
        GPIO0_ibe_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `IBE0` field.
    #[inline(always)]
    pub fn set_ibe0<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `IBE1` field.
    #[inline(always)]
    pub fn set_ibe1<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `IBE2` field.
    #[inline(always)]
    pub fn set_ibe2<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `IBE3` field.
    #[inline(always)]
    pub fn set_ibe3<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `IBE4` field.
    #[inline(always)]
    pub fn set_ibe4<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `IBE5` field.
    #[inline(always)]
    pub fn set_ibe5<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `IBE6` field.
    #[inline(always)]
    pub fn set_ibe6<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `IBE7` field.
    #[inline(always)]
    pub fn set_ibe7<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `IBE8` field.
    #[inline(always)]
    pub fn set_ibe8<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `IBE9` field.
    #[inline(always)]
    pub fn set_ibe9<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `IBE10` field.
    #[inline(always)]
    pub fn set_ibe10<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `IBE11` field.
    #[inline(always)]
    pub fn set_ibe11<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ibe_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register IEV implementation


/// Register `IEV`: Interrupt event register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_iev {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_iev { }

impl GPIO0_iev {
    
    // Getters
    /// Fetch the value of the `IEV` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_iev_Get {
        GPIO0_iev_Get::new(self)
    }

    
    /// Get value of `IEV0` field.
    #[inline(always)]
    pub fn iev0(&self) -> bool {
        GPIO0_iev_Get::new(self).iev0()
    }
    
    /// Get value of `IEV1` field.
    #[inline(always)]
    pub fn iev1(&self) -> bool {
        GPIO0_iev_Get::new(self).iev1()
    }
    
    /// Get value of `IEV2` field.
    #[inline(always)]
    pub fn iev2(&self) -> bool {
        GPIO0_iev_Get::new(self).iev2()
    }
    
    /// Get value of `IEV3` field.
    #[inline(always)]
    pub fn iev3(&self) -> bool {
        GPIO0_iev_Get::new(self).iev3()
    }
    
    /// Get value of `IEV4` field.
    #[inline(always)]
    pub fn iev4(&self) -> bool {
        GPIO0_iev_Get::new(self).iev4()
    }
    
    /// Get value of `IEV5` field.
    #[inline(always)]
    pub fn iev5(&self) -> bool {
        GPIO0_iev_Get::new(self).iev5()
    }
    
    /// Get value of `IEV6` field.
    #[inline(always)]
    pub fn iev6(&self) -> bool {
        GPIO0_iev_Get::new(self).iev6()
    }
    
    /// Get value of `IEV7` field.
    #[inline(always)]
    pub fn iev7(&self) -> bool {
        GPIO0_iev_Get::new(self).iev7()
    }
    
    /// Get value of `IEV8` field.
    #[inline(always)]
    pub fn iev8(&self) -> bool {
        GPIO0_iev_Get::new(self).iev8()
    }
    
    /// Get value of `IEV9` field.
    #[inline(always)]
    pub fn iev9(&self) -> bool {
        GPIO0_iev_Get::new(self).iev9()
    }
    
    /// Get value of `IEV10` field.
    #[inline(always)]
    pub fn iev10(&self) -> bool {
        GPIO0_iev_Get::new(self).iev10()
    }
    
    /// Get value of `IEV11` field.
    #[inline(always)]
    pub fn iev11(&self) -> bool {
        GPIO0_iev_Get::new(self).iev11()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IEV` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> GPIO0_iev_Update {
        GPIO0_iev_Update::new_ignoring_state(self)
    }

    
    /// Set value of `IEV0` field.
    #[inline(always)]
    pub fn set_iev0<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev0(new_value);
        setter
    }
    
    /// Set value of `IEV1` field.
    #[inline(always)]
    pub fn set_iev1<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev1(new_value);
        setter
    }
    
    /// Set value of `IEV2` field.
    #[inline(always)]
    pub fn set_iev2<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev2(new_value);
        setter
    }
    
    /// Set value of `IEV3` field.
    #[inline(always)]
    pub fn set_iev3<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev3(new_value);
        setter
    }
    
    /// Set value of `IEV4` field.
    #[inline(always)]
    pub fn set_iev4<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev4(new_value);
        setter
    }
    
    /// Set value of `IEV5` field.
    #[inline(always)]
    pub fn set_iev5<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev5(new_value);
        setter
    }
    
    /// Set value of `IEV6` field.
    #[inline(always)]
    pub fn set_iev6<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev6(new_value);
        setter
    }
    
    /// Set value of `IEV7` field.
    #[inline(always)]
    pub fn set_iev7<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev7(new_value);
        setter
    }
    
    /// Set value of `IEV8` field.
    #[inline(always)]
    pub fn set_iev8<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev8(new_value);
        setter
    }
    
    /// Set value of `IEV9` field.
    #[inline(always)]
    pub fn set_iev9<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev9(new_value);
        setter
    }
    
    /// Set value of `IEV10` field.
    #[inline(always)]
    pub fn set_iev10<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev10(new_value);
        setter
    }
    
    /// Set value of `IEV11` field.
    #[inline(always)]
    pub fn set_iev11<'a>(&'a mut self, new_value: bool) -> GPIO0_iev_Update<'a> {
        let mut setter: GPIO0_iev_Update = GPIO0_iev_Update::new(self);
        setter.set_iev11(new_value);
        setter
    }
    

    }


// Getter for GPIO0_iev
/// `IEV`: Interrupt event register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_iev_Get {
    value: u32,
}

impl GPIO0_iev_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_iev) -> GPIO0_iev_Get {
        GPIO0_iev_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `IEV0` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `IEV1` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `IEV2` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `IEV3` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `IEV4` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `IEV5` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `IEV6` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `IEV7` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `IEV8` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `IEV9` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `IEV10` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `IEV11` field: Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOnIS (see Table 109), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOnIS (see Table 109), rising edges or HIGH level on pin PIOn_x trigger an interrupt.
    #[inline(always)]
    pub fn iev11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_iev_Get { }


// Updater for GPIO0_iev
/// Updater for `IEV` register.
#[allow(non_camel_case_types)]
pub struct GPIO0_iev_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a GPIO0_iev,
}

/// This performs the register update.
impl <'a> Drop for GPIO0_iev_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> GPIO0_iev_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a GPIO0_iev) -> GPIO0_iev_Update<'a> {
        GPIO0_iev_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a GPIO0_iev) -> GPIO0_iev_Update<'a> {
        GPIO0_iev_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `IEV0` field.
    #[inline(always)]
    pub fn set_iev0<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `IEV1` field.
    #[inline(always)]
    pub fn set_iev1<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `IEV2` field.
    #[inline(always)]
    pub fn set_iev2<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `IEV3` field.
    #[inline(always)]
    pub fn set_iev3<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `IEV4` field.
    #[inline(always)]
    pub fn set_iev4<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `IEV5` field.
    #[inline(always)]
    pub fn set_iev5<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `IEV6` field.
    #[inline(always)]
    pub fn set_iev6<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `IEV7` field.
    #[inline(always)]
    pub fn set_iev7<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `IEV8` field.
    #[inline(always)]
    pub fn set_iev8<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `IEV9` field.
    #[inline(always)]
    pub fn set_iev9<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `IEV10` field.
    #[inline(always)]
    pub fn set_iev10<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `IEV11` field.
    #[inline(always)]
    pub fn set_iev11<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_iev_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register IE implementation


/// Register `IE`: Interrupt mask register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_ie {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_ie { }

impl GPIO0_ie {
    
    // Getters
    /// Fetch the value of the `IE` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_ie_Get {
        GPIO0_ie_Get::new(self)
    }

    
    /// Get value of `MASK0` field.
    #[inline(always)]
    pub fn mask0(&self) -> bool {
        GPIO0_ie_Get::new(self).mask0()
    }
    
    /// Get value of `MASK1` field.
    #[inline(always)]
    pub fn mask1(&self) -> bool {
        GPIO0_ie_Get::new(self).mask1()
    }
    
    /// Get value of `MASK2` field.
    #[inline(always)]
    pub fn mask2(&self) -> bool {
        GPIO0_ie_Get::new(self).mask2()
    }
    
    /// Get value of `MASK3` field.
    #[inline(always)]
    pub fn mask3(&self) -> bool {
        GPIO0_ie_Get::new(self).mask3()
    }
    
    /// Get value of `MASK4` field.
    #[inline(always)]
    pub fn mask4(&self) -> bool {
        GPIO0_ie_Get::new(self).mask4()
    }
    
    /// Get value of `MASK5` field.
    #[inline(always)]
    pub fn mask5(&self) -> bool {
        GPIO0_ie_Get::new(self).mask5()
    }
    
    /// Get value of `MASK6` field.
    #[inline(always)]
    pub fn mask6(&self) -> bool {
        GPIO0_ie_Get::new(self).mask6()
    }
    
    /// Get value of `MASK7` field.
    #[inline(always)]
    pub fn mask7(&self) -> bool {
        GPIO0_ie_Get::new(self).mask7()
    }
    
    /// Get value of `MASK8` field.
    #[inline(always)]
    pub fn mask8(&self) -> bool {
        GPIO0_ie_Get::new(self).mask8()
    }
    
    /// Get value of `MASK9` field.
    #[inline(always)]
    pub fn mask9(&self) -> bool {
        GPIO0_ie_Get::new(self).mask9()
    }
    
    /// Get value of `MASK10` field.
    #[inline(always)]
    pub fn mask10(&self) -> bool {
        GPIO0_ie_Get::new(self).mask10()
    }
    
    /// Get value of `MASK11` field.
    #[inline(always)]
    pub fn mask11(&self) -> bool {
        GPIO0_ie_Get::new(self).mask11()
    }
    

    
    // Setters
    /// Create new updater that ignores current value of the `IE` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> GPIO0_ie_Update {
        GPIO0_ie_Update::new_ignoring_state(self)
    }

    
    /// Set value of `MASK0` field.
    #[inline(always)]
    pub fn set_mask0<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask0(new_value);
        setter
    }
    
    /// Set value of `MASK1` field.
    #[inline(always)]
    pub fn set_mask1<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask1(new_value);
        setter
    }
    
    /// Set value of `MASK2` field.
    #[inline(always)]
    pub fn set_mask2<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask2(new_value);
        setter
    }
    
    /// Set value of `MASK3` field.
    #[inline(always)]
    pub fn set_mask3<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask3(new_value);
        setter
    }
    
    /// Set value of `MASK4` field.
    #[inline(always)]
    pub fn set_mask4<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask4(new_value);
        setter
    }
    
    /// Set value of `MASK5` field.
    #[inline(always)]
    pub fn set_mask5<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask5(new_value);
        setter
    }
    
    /// Set value of `MASK6` field.
    #[inline(always)]
    pub fn set_mask6<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask6(new_value);
        setter
    }
    
    /// Set value of `MASK7` field.
    #[inline(always)]
    pub fn set_mask7<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask7(new_value);
        setter
    }
    
    /// Set value of `MASK8` field.
    #[inline(always)]
    pub fn set_mask8<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask8(new_value);
        setter
    }
    
    /// Set value of `MASK9` field.
    #[inline(always)]
    pub fn set_mask9<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask9(new_value);
        setter
    }
    
    /// Set value of `MASK10` field.
    #[inline(always)]
    pub fn set_mask10<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask10(new_value);
        setter
    }
    
    /// Set value of `MASK11` field.
    #[inline(always)]
    pub fn set_mask11<'a>(&'a mut self, new_value: bool) -> GPIO0_ie_Update<'a> {
        let mut setter: GPIO0_ie_Update = GPIO0_ie_Update::new(self);
        setter.set_mask11(new_value);
        setter
    }
    

    }


// Getter for GPIO0_ie
/// `IE`: Interrupt mask register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_ie_Get {
    value: u32,
}

impl GPIO0_ie_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_ie) -> GPIO0_ie_Get {
        GPIO0_ie_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MASK0` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `MASK1` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `MASK2` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `MASK3` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `MASK4` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `MASK5` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `MASK6` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `MASK7` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `MASK8` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `MASK9` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `MASK10` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `MASK11` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked.
    #[inline(always)]
    pub fn mask11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_ie_Get { }


// Updater for GPIO0_ie
/// Updater for `IE` register.
#[allow(non_camel_case_types)]
pub struct GPIO0_ie_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a GPIO0_ie,
}

/// This performs the register update.
impl <'a> Drop for GPIO0_ie_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> GPIO0_ie_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a GPIO0_ie) -> GPIO0_ie_Update<'a> {
        GPIO0_ie_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a GPIO0_ie) -> GPIO0_ie_Update<'a> {
        GPIO0_ie_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `MASK0` field.
    #[inline(always)]
    pub fn set_mask0<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `MASK1` field.
    #[inline(always)]
    pub fn set_mask1<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `MASK2` field.
    #[inline(always)]
    pub fn set_mask2<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `MASK3` field.
    #[inline(always)]
    pub fn set_mask3<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `MASK4` field.
    #[inline(always)]
    pub fn set_mask4<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `MASK5` field.
    #[inline(always)]
    pub fn set_mask5<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `MASK6` field.
    #[inline(always)]
    pub fn set_mask6<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `MASK7` field.
    #[inline(always)]
    pub fn set_mask7<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `MASK8` field.
    #[inline(always)]
    pub fn set_mask8<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `MASK9` field.
    #[inline(always)]
    pub fn set_mask9<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `MASK10` field.
    #[inline(always)]
    pub fn set_mask10<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `MASK11` field.
    #[inline(always)]
    pub fn set_mask11<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ie_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}







// Register RIS implementation


/// Register `RIS`: Raw interrupt status register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_ris {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_ris { }

impl GPIO0_ris {
    
    // Getters
    /// Fetch the value of the `RIS` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_ris_Get {
        GPIO0_ris_Get::new(self)
    }

    
    /// Get value of `RAWST0` field.
    #[inline(always)]
    pub fn rawst0(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst0()
    }
    
    /// Get value of `RAWST1` field.
    #[inline(always)]
    pub fn rawst1(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst1()
    }
    
    /// Get value of `RAWST2` field.
    #[inline(always)]
    pub fn rawst2(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst2()
    }
    
    /// Get value of `RAWST3` field.
    #[inline(always)]
    pub fn rawst3(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst3()
    }
    
    /// Get value of `RAWST4` field.
    #[inline(always)]
    pub fn rawst4(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst4()
    }
    
    /// Get value of `RAWST5` field.
    #[inline(always)]
    pub fn rawst5(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst5()
    }
    
    /// Get value of `RAWST6` field.
    #[inline(always)]
    pub fn rawst6(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst6()
    }
    
    /// Get value of `RAWST7` field.
    #[inline(always)]
    pub fn rawst7(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst7()
    }
    
    /// Get value of `RAWST8` field.
    #[inline(always)]
    pub fn rawst8(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst8()
    }
    
    /// Get value of `RAWST9` field.
    #[inline(always)]
    pub fn rawst9(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst9()
    }
    
    /// Get value of `RAWST10` field.
    #[inline(always)]
    pub fn rawst10(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst10()
    }
    
    /// Get value of `RAWST11` field.
    #[inline(always)]
    pub fn rawst11(&self) -> bool {
        GPIO0_ris_Get::new(self).rawst11()
    }
    

    }


// Getter for GPIO0_ris
/// `RIS`: Raw interrupt status register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_ris_Get {
    value: u32,
}

impl GPIO0_ris_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_ris) -> GPIO0_ris_Get {
        GPIO0_ris_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `RAWST0` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `RAWST1` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `RAWST2` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `RAWST3` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `RAWST4` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `RAWST5` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `RAWST6` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `RAWST7` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `RAWST8` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `RAWST9` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `RAWST10` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `RAWST11` field: Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x.
    #[inline(always)]
    pub fn rawst11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_ris_Get { }







// Register MIS implementation


/// Register `MIS`: Masked interrupt status register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_mis {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_mis { }

impl GPIO0_mis {
    
    // Getters
    /// Fetch the value of the `MIS` register.
    #[inline(always)]
    pub fn get(&self) -> GPIO0_mis_Get {
        GPIO0_mis_Get::new(self)
    }

    
    /// Get value of `MASK0` field.
    #[inline(always)]
    pub fn mask0(&self) -> bool {
        GPIO0_mis_Get::new(self).mask0()
    }
    
    /// Get value of `MASK1` field.
    #[inline(always)]
    pub fn mask1(&self) -> bool {
        GPIO0_mis_Get::new(self).mask1()
    }
    
    /// Get value of `MASK2` field.
    #[inline(always)]
    pub fn mask2(&self) -> bool {
        GPIO0_mis_Get::new(self).mask2()
    }
    
    /// Get value of `MASK3` field.
    #[inline(always)]
    pub fn mask3(&self) -> bool {
        GPIO0_mis_Get::new(self).mask3()
    }
    
    /// Get value of `MASK4` field.
    #[inline(always)]
    pub fn mask4(&self) -> bool {
        GPIO0_mis_Get::new(self).mask4()
    }
    
    /// Get value of `MASK5` field.
    #[inline(always)]
    pub fn mask5(&self) -> bool {
        GPIO0_mis_Get::new(self).mask5()
    }
    
    /// Get value of `MASK6` field.
    #[inline(always)]
    pub fn mask6(&self) -> bool {
        GPIO0_mis_Get::new(self).mask6()
    }
    
    /// Get value of `MASK7` field.
    #[inline(always)]
    pub fn mask7(&self) -> bool {
        GPIO0_mis_Get::new(self).mask7()
    }
    
    /// Get value of `MASK8` field.
    #[inline(always)]
    pub fn mask8(&self) -> bool {
        GPIO0_mis_Get::new(self).mask8()
    }
    
    /// Get value of `MASK9` field.
    #[inline(always)]
    pub fn mask9(&self) -> bool {
        GPIO0_mis_Get::new(self).mask9()
    }
    
    /// Get value of `MASK10` field.
    #[inline(always)]
    pub fn mask10(&self) -> bool {
        GPIO0_mis_Get::new(self).mask10()
    }
    
    /// Get value of `MASK11` field.
    #[inline(always)]
    pub fn mask11(&self) -> bool {
        GPIO0_mis_Get::new(self).mask11()
    }
    

    }


// Getter for GPIO0_mis
/// `MIS`: Masked interrupt status register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
pub struct GPIO0_mis_Get {
    value: u32,
}

impl GPIO0_mis_Get {
    /// Create a getter reflecting the current value of the given register.
    #[inline(always)]
    pub fn new(reg: &GPIO0_mis) -> GPIO0_mis_Get {
        GPIO0_mis_Get{ value: reg.value.get() }
    }

    /// Get the raw value of the register.
    #[inline(always)]
    pub fn raw(&self) -> u32 { self.value }

    /// Get value of `MASK0` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask0(&self) -> bool {
        (self.value >> 0) & 1 != 0
        }
    /// Get value of `MASK1` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask1(&self) -> bool {
        (self.value >> 1) & 1 != 0
        }
    /// Get value of `MASK2` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask2(&self) -> bool {
        (self.value >> 2) & 1 != 0
        }
    /// Get value of `MASK3` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask3(&self) -> bool {
        (self.value >> 3) & 1 != 0
        }
    /// Get value of `MASK4` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask4(&self) -> bool {
        (self.value >> 4) & 1 != 0
        }
    /// Get value of `MASK5` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask5(&self) -> bool {
        (self.value >> 5) & 1 != 0
        }
    /// Get value of `MASK6` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask6(&self) -> bool {
        (self.value >> 6) & 1 != 0
        }
    /// Get value of `MASK7` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask7(&self) -> bool {
        (self.value >> 7) & 1 != 0
        }
    /// Get value of `MASK8` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask8(&self) -> bool {
        (self.value >> 8) & 1 != 0
        }
    /// Get value of `MASK9` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask9(&self) -> bool {
        (self.value >> 9) & 1 != 0
        }
    /// Get value of `MASK10` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask10(&self) -> bool {
        (self.value >> 10) & 1 != 0
        }
    /// Get value of `MASK11` field: Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x.
    #[inline(always)]
    pub fn mask11(&self) -> bool {
        (self.value >> 11) & 1 != 0
        }
    }

impl ::core::marker::Copy for GPIO0_mis_Get { }







// Register IC implementation


/// Register `IC`: Interrupt clear register for port n
#[derive(Clone)]
#[allow(non_camel_case_types)]
#[repr(C)]
pub struct GPIO0_ic {
    value: ::volatile_cell::VolatileCell<u32>,
}

impl ::core::marker::Copy for GPIO0_ic { }

impl GPIO0_ic {
    
    // Setters
    /// Create new updater that ignores current value of the `IC` register.
    #[inline(always)]
    pub fn ignoring_state(&self) -> GPIO0_ic_Update {
        GPIO0_ic_Update::new_ignoring_state(self)
    }

    
    /// Set value of `CLR0` field.
    #[inline(always)]
    pub fn set_clr0<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr0(new_value);
        setter
    }
    
    /// Set value of `CLR1` field.
    #[inline(always)]
    pub fn set_clr1<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr1(new_value);
        setter
    }
    
    /// Set value of `CLR2` field.
    #[inline(always)]
    pub fn set_clr2<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr2(new_value);
        setter
    }
    
    /// Set value of `CLR3` field.
    #[inline(always)]
    pub fn set_clr3<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr3(new_value);
        setter
    }
    
    /// Set value of `CLR4` field.
    #[inline(always)]
    pub fn set_clr4<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr4(new_value);
        setter
    }
    
    /// Set value of `CLR5` field.
    #[inline(always)]
    pub fn set_clr5<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr5(new_value);
        setter
    }
    
    /// Set value of `CLR6` field.
    #[inline(always)]
    pub fn set_clr6<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr6(new_value);
        setter
    }
    
    /// Set value of `CLR7` field.
    #[inline(always)]
    pub fn set_clr7<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr7(new_value);
        setter
    }
    
    /// Set value of `CLR8` field.
    #[inline(always)]
    pub fn set_clr8<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr8(new_value);
        setter
    }
    
    /// Set value of `CLR9` field.
    #[inline(always)]
    pub fn set_clr9<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr9(new_value);
        setter
    }
    
    /// Set value of `CLR10` field.
    #[inline(always)]
    pub fn set_clr10<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr10(new_value);
        setter
    }
    
    /// Set value of `CLR11` field.
    #[inline(always)]
    pub fn set_clr11<'a>(&'a mut self, new_value: bool) -> GPIO0_ic_Update<'a> {
        let mut setter: GPIO0_ic_Update = GPIO0_ic_Update::new(self);
        setter.set_clr11(new_value);
        setter
    }
    

    }


// Updater for GPIO0_ic
/// Updater for `IC` register.
#[allow(non_camel_case_types)]
pub struct GPIO0_ic_Update<'a> {
    value: u32,
    mask: u32,
    write_only: bool,
    reg: &'a GPIO0_ic,
}

/// This performs the register update.
impl <'a> Drop for GPIO0_ic_Update<'a> {
    #[inline(always)]
    fn drop(&mut self) {
        let clear_mask: u32 = 0u32 as u32;
        if self.mask != 0 {
            let v: u32 =
                if self.write_only { 0 } else { self.reg.value.get() } &
                    !clear_mask & !self.mask;
            self.reg.value.set(self.value | v);
        }
    }
}

impl <'a> GPIO0_ic_Update<'a> {
    /// Create a new updater.
    #[inline(always)]
    pub fn new(reg: &'a GPIO0_ic) -> GPIO0_ic_Update<'a> {
        GPIO0_ic_Update{ value: 0, mask: 0, write_only: false, reg: reg }
    }

    /// Create a new updater that ignores current state.
    #[inline(always)]
    pub fn new_ignoring_state(reg: &'a GPIO0_ic) -> GPIO0_ic_Update<'a> {
        GPIO0_ic_Update{ value: 0, mask: 0, write_only: true, reg: reg }
    }

    /// Set value of `CLR0` field.
    #[inline(always)]
    pub fn set_clr0<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 0))
                   | ((new_value as u32) & 1) << 0;
        self.mask |= 1 << 0;
        self
    }
    /// Set value of `CLR1` field.
    #[inline(always)]
    pub fn set_clr1<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 1))
                   | ((new_value as u32) & 1) << 1;
        self.mask |= 1 << 1;
        self
    }
    /// Set value of `CLR2` field.
    #[inline(always)]
    pub fn set_clr2<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 2))
                   | ((new_value as u32) & 1) << 2;
        self.mask |= 1 << 2;
        self
    }
    /// Set value of `CLR3` field.
    #[inline(always)]
    pub fn set_clr3<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 3))
                   | ((new_value as u32) & 1) << 3;
        self.mask |= 1 << 3;
        self
    }
    /// Set value of `CLR4` field.
    #[inline(always)]
    pub fn set_clr4<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 4))
                   | ((new_value as u32) & 1) << 4;
        self.mask |= 1 << 4;
        self
    }
    /// Set value of `CLR5` field.
    #[inline(always)]
    pub fn set_clr5<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 5))
                   | ((new_value as u32) & 1) << 5;
        self.mask |= 1 << 5;
        self
    }
    /// Set value of `CLR6` field.
    #[inline(always)]
    pub fn set_clr6<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 6))
                   | ((new_value as u32) & 1) << 6;
        self.mask |= 1 << 6;
        self
    }
    /// Set value of `CLR7` field.
    #[inline(always)]
    pub fn set_clr7<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 7))
                   | ((new_value as u32) & 1) << 7;
        self.mask |= 1 << 7;
        self
    }
    /// Set value of `CLR8` field.
    #[inline(always)]
    pub fn set_clr8<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 8))
                   | ((new_value as u32) & 1) << 8;
        self.mask |= 1 << 8;
        self
    }
    /// Set value of `CLR9` field.
    #[inline(always)]
    pub fn set_clr9<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 9))
                   | ((new_value as u32) & 1) << 9;
        self.mask |= 1 << 9;
        self
    }
    /// Set value of `CLR10` field.
    #[inline(always)]
    pub fn set_clr10<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 10))
                   | ((new_value as u32) & 1) << 10;
        self.mask |= 1 << 10;
        self
    }
    /// Set value of `CLR11` field.
    #[inline(always)]
    pub fn set_clr11<'b>(&'b mut self, new_value: bool) -> &'b mut GPIO0_ic_Update<'a> {
        self.value = (self.value & !(1 << 11))
                   | ((new_value as u32) & 1) << 11;
        self.mask |= 1 << 11;
        self
    }
    /// Commit changes to register.
    #[inline(always)]
    pub fn done(self) { }
}





// Peripheral GPIO0 implementation

/// GPIO0
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct GPIO0;

impl GPIO0 {
    /// Port n data register for pins PIOn_0 to PIOn_11
    #[inline(always)]
    pub fn data() -> &'static mut GPIO0_data {
        unsafe { ::core::intrinsics::transmute(0x50003ffc as usize) }
    }
    /// Data direction register for port n
    #[inline(always)]
    pub fn dir() -> &'static mut GPIO0_dir {
        unsafe { ::core::intrinsics::transmute(0x50008000 as usize) }
    }
    /// Interrupt sense register for port n
    #[inline(always)]
    pub fn is() -> &'static mut GPIO0_is {
        unsafe { ::core::intrinsics::transmute(0x50008004 as usize) }
    }
    /// Interrupt both edges register for port n
    #[inline(always)]
    pub fn ibe() -> &'static mut GPIO0_ibe {
        unsafe { ::core::intrinsics::transmute(0x50008008 as usize) }
    }
    /// Interrupt event register for port n
    #[inline(always)]
    pub fn iev() -> &'static mut GPIO0_iev {
        unsafe { ::core::intrinsics::transmute(0x5000800c as usize) }
    }
    /// Interrupt mask register for port n
    #[inline(always)]
    pub fn ie() -> &'static mut GPIO0_ie {
        unsafe { ::core::intrinsics::transmute(0x50008010 as usize) }
    }
    /// Raw interrupt status register for port n
    #[inline(always)]
    pub fn ris() -> &'static mut GPIO0_ris {
        unsafe { ::core::intrinsics::transmute(0x50008014 as usize) }
    }
    /// Masked interrupt status register for port n
    #[inline(always)]
    pub fn mis() -> &'static mut GPIO0_mis {
        unsafe { ::core::intrinsics::transmute(0x50008018 as usize) }
    }
    /// Interrupt clear register for port n
    #[inline(always)]
    pub fn ic() -> &'static mut GPIO0_ic {
        unsafe { ::core::intrinsics::transmute(0x5000801c as usize) }
    }
    }



// Registers for GPIO1





















// Peripheral GPIO1 implementation

/// LPC11xx, LPC11Cxx, LPC11xxL, LPC11xxXL
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct GPIO1;

impl GPIO1 {
    /// Port n data register for pins PIOn_0 to PIOn_11
    #[inline(always)]
    pub fn data() -> &'static mut GPIO0_data {
        unsafe { ::core::intrinsics::transmute(0x50013ffc as usize) }
    }
    /// Data direction register for port n
    #[inline(always)]
    pub fn dir() -> &'static mut GPIO0_dir {
        unsafe { ::core::intrinsics::transmute(0x50018000 as usize) }
    }
    /// Interrupt sense register for port n
    #[inline(always)]
    pub fn is() -> &'static mut GPIO0_is {
        unsafe { ::core::intrinsics::transmute(0x50018004 as usize) }
    }
    /// Interrupt both edges register for port n
    #[inline(always)]
    pub fn ibe() -> &'static mut GPIO0_ibe {
        unsafe { ::core::intrinsics::transmute(0x50018008 as usize) }
    }
    /// Interrupt event register for port n
    #[inline(always)]
    pub fn iev() -> &'static mut GPIO0_iev {
        unsafe { ::core::intrinsics::transmute(0x5001800c as usize) }
    }
    /// Interrupt mask register for port n
    #[inline(always)]
    pub fn ie() -> &'static mut GPIO0_ie {
        unsafe { ::core::intrinsics::transmute(0x50018010 as usize) }
    }
    /// Raw interrupt status register for port n
    #[inline(always)]
    pub fn ris() -> &'static mut GPIO0_ris {
        unsafe { ::core::intrinsics::transmute(0x50018014 as usize) }
    }
    /// Masked interrupt status register for port n
    #[inline(always)]
    pub fn mis() -> &'static mut GPIO0_mis {
        unsafe { ::core::intrinsics::transmute(0x50018018 as usize) }
    }
    /// Interrupt clear register for port n
    #[inline(always)]
    pub fn ic() -> &'static mut GPIO0_ic {
        unsafe { ::core::intrinsics::transmute(0x5001801c as usize) }
    }
    }



// Registers for GPIO2





















// Peripheral GPIO2 implementation

/// LPC11xx, LPC11Cxx, LPC11xxL, LPC11xxXL
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct GPIO2;

impl GPIO2 {
    /// Port n data register for pins PIOn_0 to PIOn_11
    #[inline(always)]
    pub fn data() -> &'static mut GPIO0_data {
        unsafe { ::core::intrinsics::transmute(0x50023ffc as usize) }
    }
    /// Data direction register for port n
    #[inline(always)]
    pub fn dir() -> &'static mut GPIO0_dir {
        unsafe { ::core::intrinsics::transmute(0x50028000 as usize) }
    }
    /// Interrupt sense register for port n
    #[inline(always)]
    pub fn is() -> &'static mut GPIO0_is {
        unsafe { ::core::intrinsics::transmute(0x50028004 as usize) }
    }
    /// Interrupt both edges register for port n
    #[inline(always)]
    pub fn ibe() -> &'static mut GPIO0_ibe {
        unsafe { ::core::intrinsics::transmute(0x50028008 as usize) }
    }
    /// Interrupt event register for port n
    #[inline(always)]
    pub fn iev() -> &'static mut GPIO0_iev {
        unsafe { ::core::intrinsics::transmute(0x5002800c as usize) }
    }
    /// Interrupt mask register for port n
    #[inline(always)]
    pub fn ie() -> &'static mut GPIO0_ie {
        unsafe { ::core::intrinsics::transmute(0x50028010 as usize) }
    }
    /// Raw interrupt status register for port n
    #[inline(always)]
    pub fn ris() -> &'static mut GPIO0_ris {
        unsafe { ::core::intrinsics::transmute(0x50028014 as usize) }
    }
    /// Masked interrupt status register for port n
    #[inline(always)]
    pub fn mis() -> &'static mut GPIO0_mis {
        unsafe { ::core::intrinsics::transmute(0x50028018 as usize) }
    }
    /// Interrupt clear register for port n
    #[inline(always)]
    pub fn ic() -> &'static mut GPIO0_ic {
        unsafe { ::core::intrinsics::transmute(0x5002801c as usize) }
    }
    }



// Registers for GPIO3





















// Peripheral GPIO3 implementation

/// LPC11xx, LPC11Cxx, LPC11xxL, LPC11xxXL
#[allow(non_camel_case_types, missing_docs)]
#[repr(C)]
pub struct GPIO3;

impl GPIO3 {
    /// Port n data register for pins PIOn_0 to PIOn_11
    #[inline(always)]
    pub fn data() -> &'static mut GPIO0_data {
        unsafe { ::core::intrinsics::transmute(0x50033ffc as usize) }
    }
    /// Data direction register for port n
    #[inline(always)]
    pub fn dir() -> &'static mut GPIO0_dir {
        unsafe { ::core::intrinsics::transmute(0x50038000 as usize) }
    }
    /// Interrupt sense register for port n
    #[inline(always)]
    pub fn is() -> &'static mut GPIO0_is {
        unsafe { ::core::intrinsics::transmute(0x50038004 as usize) }
    }
    /// Interrupt both edges register for port n
    #[inline(always)]
    pub fn ibe() -> &'static mut GPIO0_ibe {
        unsafe { ::core::intrinsics::transmute(0x50038008 as usize) }
    }
    /// Interrupt event register for port n
    #[inline(always)]
    pub fn iev() -> &'static mut GPIO0_iev {
        unsafe { ::core::intrinsics::transmute(0x5003800c as usize) }
    }
    /// Interrupt mask register for port n
    #[inline(always)]
    pub fn ie() -> &'static mut GPIO0_ie {
        unsafe { ::core::intrinsics::transmute(0x50038010 as usize) }
    }
    /// Raw interrupt status register for port n
    #[inline(always)]
    pub fn ris() -> &'static mut GPIO0_ris {
        unsafe { ::core::intrinsics::transmute(0x50038014 as usize) }
    }
    /// Masked interrupt status register for port n
    #[inline(always)]
    pub fn mis() -> &'static mut GPIO0_mis {
        unsafe { ::core::intrinsics::transmute(0x50038018 as usize) }
    }
    /// Interrupt clear register for port n
    #[inline(always)]
    pub fn ic() -> &'static mut GPIO0_ic {
        unsafe { ::core::intrinsics::transmute(0x5003801c as usize) }
    }
    }


